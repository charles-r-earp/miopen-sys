/* automatically generated by rust-bindgen 0.54.1 */

#![allow(warnings)]
use std::fmt::Debug;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const DEFINE_NO_DEPRECATED: u32 = 0;
pub const hipblasVersionMajor: u32 = 0;
pub const hipblaseVersionMinor: u32 = 28;
pub const hipblasVersionPatch: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const __HIP_ARCH_HAS_GLOBAL_INT32_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_GLOBAL_FLOAT_ATOMIC_EXCH__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_INT32_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_FLOAT_ATOMIC_EXCH__: u32 = 0;
pub const __HIP_ARCH_HAS_FLOAT_ATOMIC_ADD__: u32 = 0;
pub const __HIP_ARCH_HAS_GLOBAL_INT64_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_INT64_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_DOUBLES__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_VOTE__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_BALLOT__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_SHUFFLE__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_FUNNEL_SHIFT__: u32 = 0;
pub const __HIP_ARCH_HAS_THREAD_FENCE_SYSTEM__: u32 = 0;
pub const __HIP_ARCH_HAS_SYNC_THREAD_EXT__: u32 = 0;
pub const __HIP_ARCH_HAS_SURFACE_FUNCS__: u32 = 0;
pub const __HIP_ARCH_HAS_3DGRID__: u32 = 0;
pub const __HIP_ARCH_HAS_DYNAMIC_PARALLEL__: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const GENERIC_GRID_LAUNCH: u32 = 1;
pub const __HIP_ROCclr__: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const HIP_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const HIP_TRSF_READ_AS_INTEGER: u32 = 1;
pub const HIP_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const HIP_TRSF_SRGB: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const hipTextureType1D: u32 = 1;
pub const hipTextureType2D: u32 = 2;
pub const hipTextureType3D: u32 = 3;
pub const hipTextureTypeCubemap: u32 = 12;
pub const hipTextureType1DLayered: u32 = 241;
pub const hipTextureType2DLayered: u32 = 242;
pub const hipTextureTypeCubemapLayered: u32 = 252;
pub const HIP_IMAGE_OBJECT_SIZE_DWORD: u32 = 12;
pub const HIP_SAMPLER_OBJECT_SIZE_DWORD: u32 = 8;
pub const HIP_SAMPLER_OBJECT_OFFSET_DWORD: u32 = 12;
pub const HIP_TEXTURE_OBJECT_SIZE_DWORD: u32 = 20;
pub const DEPRECATED_MSG : & 'static [ u8 ; 205usize ] = b"This API is marked as deprecated and may not be supported in future releases. For more details please refer https://github.com/ROCm-Developer-Tools/HIP/blob/master/docs/markdown/hip_deprecated_api_list.md\0" ;
pub const hipIpcMemLazyEnablePeerAccess: u32 = 0;
pub const HIP_IPC_HANDLE_SIZE: u32 = 64;
pub const hipStreamDefault: u32 = 0;
pub const hipStreamNonBlocking: u32 = 1;
pub const hipEventDefault: u32 = 0;
pub const hipEventBlockingSync: u32 = 1;
pub const hipEventDisableTiming: u32 = 2;
pub const hipEventInterprocess: u32 = 4;
pub const hipEventReleaseToDevice: u32 = 1073741824;
pub const hipEventReleaseToSystem: u32 = 2147483648;
pub const hipHostMallocDefault: u32 = 0;
pub const hipHostMallocPortable: u32 = 1;
pub const hipHostMallocMapped: u32 = 2;
pub const hipHostMallocWriteCombined: u32 = 4;
pub const hipHostMallocCoherent: u32 = 1073741824;
pub const hipHostMallocNonCoherent: u32 = 2147483648;
pub const hipMemAttachGlobal: u32 = 0;
pub const hipMemAttachHost: u32 = 1;
pub const hipDeviceMallocDefault: u32 = 0;
pub const hipDeviceMallocFinegrained: u32 = 1;
pub const hipHostRegisterDefault: u32 = 0;
pub const hipHostRegisterPortable: u32 = 1;
pub const hipHostRegisterMapped: u32 = 2;
pub const hipHostRegisterIoMemory: u32 = 4;
pub const hipExtHostRegisterCoarseGrained: u32 = 8;
pub const hipDeviceScheduleAuto: u32 = 0;
pub const hipDeviceScheduleSpin: u32 = 1;
pub const hipDeviceScheduleYield: u32 = 2;
pub const hipDeviceScheduleBlockingSync: u32 = 4;
pub const hipDeviceScheduleMask: u32 = 7;
pub const hipDeviceMapHost: u32 = 8;
pub const hipDeviceLmemResizeToMax: u32 = 22;
pub const hipArrayDefault: u32 = 0;
pub const hipArrayLayered: u32 = 1;
pub const hipArraySurfaceLoadStore: u32 = 2;
pub const hipArrayCubemap: u32 = 4;
pub const hipArrayTextureGather: u32 = 8;
pub const hipOccupancyDefault: u32 = 0;
pub const hipCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const hipCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const USE_PEER_NON_UNIFIED: u32 = 1;
pub const MIOPEN_BACKEND_OPENCL: u32 = 0;
pub const MIOPEN_BACKEND_HCC: u32 = 0;
pub const MIOPEN_BACKEND_HIP: u32 = 1;
pub const MIOPEN_USE_MIOPENGEMM: u32 = 0;
pub const MIOPEN_USE_ROCBLAS: u32 = 1;
pub const MIOPEN_BUILD_DEV: u32 = 0;
pub const MIOPEN_GPU_SYNC: u32 = 0;
pub const MIOPEN_ENABLE_SQLITE: u32 = 1;
pub const MIOPEN_ENABLE_SQLITE_KERN_CACHE: u32 = 1;
pub const MIOPEN_DEBUG_FIND_DB_CACHING: u32 = 1;
pub const MIOPEN_USE_SCGEMM: u32 = 0;
pub const MIOPEN_HCC_ENABLE_COV3: u32 = 0;
pub const MIOPEN_USE_RNE_BFLOAT16: u32 = 1;
pub const MIOPEN_AMDGCN_ASSEMBLER: &'static [u8; 25usize] = b"/opt/rocm/llvm/bin/clang\0";
pub const HIP_OC_COMPILER: &'static [u8; 30usize] = b"/opt/rocm-3.5.0/bin/clang-ocl\0";
pub const MIOPEN_HIP_COMPILER: &'static [u8; 33usize] = b"/opt/rocm-3.5.0/llvm/bin/clang++\0";
pub const MIOPEN_OFFLOADBUNDLER_BIN: &'static [u8; 41usize] =
    b"/opt/rocm/llvm/bin/clang-offload-bundler\0";
pub const MIOPEN_CACHE_DIR: &'static [u8; 17usize] = b"~/.cache/miopen/\0";
pub const MIOPEN_NDEBUG: u32 = 0;
pub const MIOPEN_ALLOC_BUFFERS: u32 = 0;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __c: ::libc::c_int,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::libc::c_void,
        __c: ::libc::c_int,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::libc::c_void,
        __s2: *const ::libc::c_void,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::libc::c_void,
        __c: ::libc::c_int,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::libc::c_ushort,
    pub __ctype_tolower: *const ::libc::c_int,
    pub __ctype_toupper: *const ::libc::c_int,
    pub __names: [*const ::libc::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __l: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::libc::c_char, __n: ::libc::c_ulong) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::libc::c_char, __reject: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::libc::c_char, __accept: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::libc::c_char,
        __accept: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::libc::c_char,
        __needle: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::libc::c_char, __delim: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
        __save_ptr: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
        __save_ptr: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::libc::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::libc::c_int,
        __buf: *mut ::libc::c_char,
        __buflen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::libc::c_int, __l: locale_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::libc::c_void,
        __s2: *const ::libc::c_void,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::libc::c_void, __dest: *mut ::libc::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::libc::c_void, __n: ::libc::c_ulong);
}
extern "C" {
    pub fn index(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ffs(__i: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::libc::c_longlong) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __loc: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::libc::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
pub const HIP_SUCCESS: _bindgen_ty_1 = 0;
pub const HIP_ERROR_INVALID_VALUE: _bindgen_ty_1 = 1;
pub const HIP_ERROR_NOT_INITIALIZED: _bindgen_ty_1 = 2;
pub const HIP_ERROR_LAUNCH_OUT_OF_RESOURCES: _bindgen_ty_1 = 3;
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceArch_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_hipDeviceArch_t() {
    assert_eq!(
        ::std::mem::size_of::<hipDeviceArch_t>(),
        4usize,
        concat!("Size of: ", stringify!(hipDeviceArch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipDeviceArch_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hipDeviceArch_t))
    );
}
impl hipDeviceArch_t {
    #[inline]
    pub fn hasGlobalInt32Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt32Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalFloatAtomicExch(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalFloatAtomicExch(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt32Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt32Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedFloatAtomicExch(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedFloatAtomicExch(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFloatAtomicAdd(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFloatAtomicAdd(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalInt64Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt64Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt64Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt64Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDoubles(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDoubles(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpVote(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpVote(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpBallot(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpBallot(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpShuffle(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpShuffle(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFunnelShift(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFunnelShift(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasThreadFenceSystem(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasThreadFenceSystem(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSyncThreadsExt(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSyncThreadsExt(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSurfaceFuncs(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSurfaceFuncs(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dGrid(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has3dGrid(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDynamicParallelism(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDynamicParallelism(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hasGlobalInt32Atomics: ::libc::c_uint,
        hasGlobalFloatAtomicExch: ::libc::c_uint,
        hasSharedInt32Atomics: ::libc::c_uint,
        hasSharedFloatAtomicExch: ::libc::c_uint,
        hasFloatAtomicAdd: ::libc::c_uint,
        hasGlobalInt64Atomics: ::libc::c_uint,
        hasSharedInt64Atomics: ::libc::c_uint,
        hasDoubles: ::libc::c_uint,
        hasWarpVote: ::libc::c_uint,
        hasWarpBallot: ::libc::c_uint,
        hasWarpShuffle: ::libc::c_uint,
        hasFunnelShift: ::libc::c_uint,
        hasThreadFenceSystem: ::libc::c_uint,
        hasSyncThreadsExt: ::libc::c_uint,
        hasSurfaceFuncs: ::libc::c_uint,
        has3dGrid: ::libc::c_uint,
        hasDynamicParallelism: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hasGlobalInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt32Atomics) };
            hasGlobalInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hasGlobalFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasGlobalFloatAtomicExch) };
            hasGlobalFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hasSharedInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt32Atomics) };
            hasSharedInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hasSharedFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasSharedFloatAtomicExch) };
            hasSharedFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hasFloatAtomicAdd: u32 = unsafe { ::std::mem::transmute(hasFloatAtomicAdd) };
            hasFloatAtomicAdd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasGlobalInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt64Atomics) };
            hasGlobalInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasSharedInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt64Atomics) };
            hasSharedInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasDoubles: u32 = unsafe { ::std::mem::transmute(hasDoubles) };
            hasDoubles as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hasWarpVote: u32 = unsafe { ::std::mem::transmute(hasWarpVote) };
            hasWarpVote as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hasWarpBallot: u32 = unsafe { ::std::mem::transmute(hasWarpBallot) };
            hasWarpBallot as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hasWarpShuffle: u32 = unsafe { ::std::mem::transmute(hasWarpShuffle) };
            hasWarpShuffle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hasFunnelShift: u32 = unsafe { ::std::mem::transmute(hasFunnelShift) };
            hasFunnelShift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hasThreadFenceSystem: u32 = unsafe { ::std::mem::transmute(hasThreadFenceSystem) };
            hasThreadFenceSystem as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasSyncThreadsExt: u32 = unsafe { ::std::mem::transmute(hasSyncThreadsExt) };
            hasSyncThreadsExt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hasSurfaceFuncs: u32 = unsafe { ::std::mem::transmute(hasSurfaceFuncs) };
            hasSurfaceFuncs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let has3dGrid: u32 = unsafe { ::std::mem::transmute(has3dGrid) };
            has3dGrid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let hasDynamicParallelism: u32 =
                unsafe { ::std::mem::transmute(hasDynamicParallelism) };
            hasDynamicParallelism as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " hipDeviceProp"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipDeviceProp_t {
    #[doc = "< Device name."]
    pub name: [::libc::c_char; 256usize],
    #[doc = "< Size of global memory region (in bytes)."]
    pub totalGlobalMem: usize,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub sharedMemPerBlock: usize,
    #[doc = "< Registers per block."]
    pub regsPerBlock: ::libc::c_int,
    #[doc = "< Warp size."]
    pub warpSize: ::libc::c_int,
    #[doc = "< Max work items per work group or workgroup max size."]
    pub maxThreadsPerBlock: ::libc::c_int,
    #[doc = "< Max number of threads in each dimension (XYZ) of a block."]
    pub maxThreadsDim: [::libc::c_int; 3usize],
    #[doc = "< Max grid dimensions (XYZ)."]
    pub maxGridSize: [::libc::c_int; 3usize],
    #[doc = "< Max clock frequency of the multiProcessors in khz."]
    pub clockRate: ::libc::c_int,
    #[doc = "< Max global memory clock frequency in khz."]
    pub memoryClockRate: ::libc::c_int,
    #[doc = "< Global memory bus width in bits."]
    pub memoryBusWidth: ::libc::c_int,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability.  On HCC, this is an approximation and features may"]
    #[doc = "< differ from CUDA CC.  See the arch feature flags for portable ways to query"]
    #[doc = "< feature caps."]
    pub major: ::libc::c_int,
    #[doc = "< Minor compute capability.  On HCC, this is an approximation and features may"]
    #[doc = "< differ from CUDA CC.  See the arch feature flags for portable ways to query"]
    #[doc = "< feature caps."]
    pub minor: ::libc::c_int,
    #[doc = "< Number of multi-processors (compute units)."]
    pub multiProcessorCount: ::libc::c_int,
    #[doc = "< L2 cache size."]
    pub l2CacheSize: ::libc::c_int,
    #[doc = "< Maximum resident threads per multi-processor."]
    pub maxThreadsPerMultiProcessor: ::libc::c_int,
    #[doc = "< Compute mode."]
    pub computeMode: ::libc::c_int,
    #[doc = "< Frequency in khz of the timer used by the device-side \"clock*\""]
    #[doc = "< instructions.  New for HIP."]
    pub clockInstructionRate: ::libc::c_int,
    #[doc = "< Architectural feature flags.  New for HIP."]
    pub arch: hipDeviceArch_t,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    pub concurrentKernels: ::libc::c_int,
    #[doc = "< PCI Domain ID"]
    pub pciDomainID: ::libc::c_int,
    #[doc = "< PCI Bus ID."]
    pub pciBusID: ::libc::c_int,
    #[doc = "< PCI Device ID."]
    pub pciDeviceID: ::libc::c_int,
    #[doc = "< Maximum Shared Memory Per Multiprocessor."]
    pub maxSharedMemoryPerMultiProcessor: usize,
    #[doc = "< 1 if device is on a multi-GPU board, 0 if not."]
    pub isMultiGpuBoard: ::libc::c_int,
    #[doc = "< Check whether HIP can map host memory"]
    pub canMapHostMemory: ::libc::c_int,
    #[doc = "< AMD GCN Arch Value. Eg: 803, 701"]
    pub gcnArch: ::libc::c_int,
    #[doc = "< APU vs dGPU"]
    pub integrated: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch"]
    pub cooperativeLaunch: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple devices"]
    pub cooperativeMultiDeviceLaunch: ::libc::c_int,
    #[doc = "< Maximum number of elements in 1D images"]
    pub maxTexture1D: ::libc::c_int,
    #[doc = "< Maximum dimensions (width, height) of 2D images, in image elements"]
    pub maxTexture2D: [::libc::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, depth) of 3D images, in image elements"]
    pub maxTexture3D: [::libc::c_int; 3usize],
    #[doc = "< Addres of HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    pub hdpMemFlushCntl: *mut ::libc::c_uint,
    #[doc = "< Addres of HDP_REG_COHERENCY_FLUSH_CNTL register"]
    pub hdpRegFlushCntl: *mut ::libc::c_uint,
    #[doc = "<Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: usize,
    #[doc = "<Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "<Pitch alignment requirement for texture references bound to pitched memory"]
    pub texturePitchAlignment: usize,
    #[doc = "<Run time limit for kernels executed on the device"]
    pub kernelExecTimeoutEnabled: ::libc::c_int,
    #[doc = "<Device has ECC support enabled"]
    pub ECCEnabled: ::libc::c_int,
    #[doc = "< 1:If device is Tesla device using TCC driver, else 0"]
    pub tccDriver: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedFunc: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedGridDim: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedBlockDim: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedSharedMem: ::libc::c_int,
    #[doc = "< 1: if it is a large PCI bar device, else 0"]
    pub isLargeBar: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_hipDeviceProp_t() {
    assert_eq!(
        ::std::mem::size_of::<hipDeviceProp_t>(),
        504usize,
        concat!("Size of: ", stringify!(hipDeviceProp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipDeviceProp_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipDeviceProp_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).totalGlobalMem as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(totalGlobalMem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).sharedMemPerBlock as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).regsPerBlock as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).warpSize as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(warpSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).maxThreadsPerBlock as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxThreadsDim as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxGridSize as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).clockRate as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).memoryClockRate as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(memoryClockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).memoryBusWidth as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(memoryBusWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).totalConstMem as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(totalConstMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).major as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).minor as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).multiProcessorCount as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(multiProcessorCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).l2CacheSize as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(l2CacheSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).maxThreadsPerMultiProcessor as *const _
                as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxThreadsPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).computeMode as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(computeMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).clockInstructionRate as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(clockInstructionRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).arch as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).concurrentKernels as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(concurrentKernels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).pciDomainID as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(pciDomainID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).pciBusID as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(pciBusID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).pciDeviceID as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(pciDeviceID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).maxSharedMemoryPerMultiProcessor as *const _
                as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxSharedMemoryPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).isMultiGpuBoard as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(isMultiGpuBoard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).canMapHostMemory as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(canMapHostMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).gcnArch as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(gcnArch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).integrated as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(integrated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeLaunch as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeLaunch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceLaunch as *const _
                as usize
        },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceLaunch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxTexture1D as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxTexture1D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxTexture2D as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxTexture2D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxTexture3D as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxTexture3D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).hdpMemFlushCntl as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(hdpMemFlushCntl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).hdpRegFlushCntl as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(hdpRegFlushCntl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).memPitch as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).textureAlignment as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(textureAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).texturePitchAlignment as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(texturePitchAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).kernelExecTimeoutEnabled as *const _
                as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(kernelExecTimeoutEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).ECCEnabled as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(ECCEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).tccDriver as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(tccDriver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceUnmatchedFunc
                as *const _ as usize
        },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceUnmatchedGridDim
                as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedGridDim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceUnmatchedBlockDim
                as *const _ as usize
        },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedBlockDim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceUnmatchedSharedMem
                as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedSharedMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).isLargeBar as *const _ as usize },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(isLargeBar)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Memory type (for pointer attributes)"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipMemoryType {
    #[doc = "< Memory is physically located on host"]
    hipMemoryTypeHost = 0,
    #[doc = "< Memory is physically located on device. (see deviceId for specific"]
    #[doc = "< device)"]
    hipMemoryTypeDevice = 1,
    #[doc = "< Array memory, physically located on device. (see deviceId for specific"]
    #[doc = "< device)"]
    hipMemoryTypeArray = 2,
    #[doc = "< Not used currently"]
    hipMemoryTypeUnified = 3,
}
#[doc = " Pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPointerAttribute_t {
    pub memoryType: hipMemoryType,
    pub device: ::libc::c_int,
    pub devicePointer: *mut ::libc::c_void,
    pub hostPointer: *mut ::libc::c_void,
    pub isManaged: ::libc::c_int,
    pub allocationFlags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipPointerAttribute_t() {
    assert_eq!(
        ::std::mem::size_of::<hipPointerAttribute_t>(),
        32usize,
        concat!("Size of: ", stringify!(hipPointerAttribute_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPointerAttribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPointerAttribute_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipPointerAttribute_t>())).memoryType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(memoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPointerAttribute_t>())).device as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipPointerAttribute_t>())).devicePointer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(devicePointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipPointerAttribute_t>())).hostPointer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(hostPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPointerAttribute_t>())).isManaged as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(isManaged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipPointerAttribute_t>())).allocationFlags as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(allocationFlags)
        )
    );
}
impl hipError_t {
    pub const hipErrorMemoryAllocation: hipError_t = hipError_t::hipErrorOutOfMemory;
}
impl hipError_t {
    pub const hipErrorInitializationError: hipError_t = hipError_t::hipErrorNotInitialized;
}
impl hipError_t {
    pub const hipErrorMapBufferObjectFailed: hipError_t = hipError_t::hipErrorMapFailed;
}
impl hipError_t {
    pub const hipErrorInvalidResourceHandle: hipError_t = hipError_t::hipErrorInvalidHandle;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipError_t {
    #[doc = "< Successful completion."]
    hipSuccess = 0,
    #[doc = "< One or more of the parameters passed to the API call is NULL"]
    #[doc = "< or not in an acceptable range."]
    hipErrorInvalidValue = 1,
    hipErrorOutOfMemory = 2,
    hipErrorNotInitialized = 3,
    hipErrorDeinitialized = 4,
    hipErrorProfilerDisabled = 5,
    hipErrorProfilerNotInitialized = 6,
    hipErrorProfilerAlreadyStarted = 7,
    hipErrorProfilerAlreadyStopped = 8,
    hipErrorInvalidConfiguration = 9,
    hipErrorInvalidSymbol = 13,
    #[doc = "< Invalid Device Pointer"]
    hipErrorInvalidDevicePointer = 17,
    #[doc = "< Invalid memory copy direction"]
    hipErrorInvalidMemcpyDirection = 21,
    hipErrorInsufficientDriver = 35,
    hipErrorMissingConfiguration = 52,
    hipErrorPriorLaunchFailure = 53,
    hipErrorInvalidDeviceFunction = 98,
    #[doc = "< Call to hipGetDeviceCount returned 0 devices"]
    hipErrorNoDevice = 100,
    #[doc = "< DeviceID must be in range 0...#compute-devices."]
    hipErrorInvalidDevice = 101,
    hipErrorInvalidImage = 200,
    #[doc = "< Produced when input context is invalid."]
    hipErrorInvalidContext = 201,
    hipErrorContextAlreadyCurrent = 202,
    hipErrorMapFailed = 205,
    hipErrorUnmapFailed = 206,
    hipErrorArrayIsMapped = 207,
    hipErrorAlreadyMapped = 208,
    hipErrorNoBinaryForGpu = 209,
    hipErrorAlreadyAcquired = 210,
    hipErrorNotMapped = 211,
    hipErrorNotMappedAsArray = 212,
    hipErrorNotMappedAsPointer = 213,
    hipErrorECCNotCorrectable = 214,
    hipErrorUnsupportedLimit = 215,
    hipErrorContextAlreadyInUse = 216,
    hipErrorPeerAccessUnsupported = 217,
    #[doc = "< In CUDA DRV, it is CUDA_ERROR_INVALID_PTX"]
    hipErrorInvalidKernelFile = 218,
    hipErrorInvalidGraphicsContext = 219,
    hipErrorInvalidSource = 300,
    hipErrorFileNotFound = 301,
    hipErrorSharedObjectSymbolNotFound = 302,
    hipErrorSharedObjectInitFailed = 303,
    hipErrorOperatingSystem = 304,
    hipErrorInvalidHandle = 400,
    hipErrorNotFound = 500,
    #[doc = "< Indicates that asynchronous operations enqueued earlier are not"]
    #[doc = "< ready.  This is not actually an error, but is used to distinguish"]
    #[doc = "< from hipSuccess (which indicates completion).  APIs that return"]
    #[doc = "< this error include hipEventQuery and hipStreamQuery."]
    hipErrorNotReady = 600,
    hipErrorIllegalAddress = 700,
    #[doc = "< Out of resources error."]
    hipErrorLaunchOutOfResources = 701,
    hipErrorLaunchTimeOut = 702,
    hipErrorPeerAccessAlreadyEnabled = 704,
    hipErrorPeerAccessNotEnabled = 705,
    hipErrorSetOnActiveProcess = 708,
    #[doc = "< Produced when the kernel calls assert."]
    hipErrorAssert = 710,
    hipErrorHostMemoryAlreadyRegistered = 712,
    hipErrorHostMemoryNotRegistered = 713,
    hipErrorLaunchFailure = 719,
    hipErrorCooperativeLaunchTooLarge = 720,
    #[doc = "< Produced when the hip API is not supported/implemented"]
    hipErrorNotSupported = 801,
    hipErrorUnknown = 999,
    #[doc = "< HSA runtime memory call returned error.  Typically not seen"]
    #[doc = "< in production systems."]
    hipErrorRuntimeMemory = 1052,
    #[doc = "< HSA runtime call other than memory returned error.  Typically"]
    #[doc = "< not seen in production systems."]
    hipErrorRuntimeOther = 1053,
    #[doc = "< Marker that more error codes are needed."]
    hipErrorTbd = 1054,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipDeviceAttribute_t {
    #[doc = "< Maximum number of threads per block."]
    hipDeviceAttributeMaxThreadsPerBlock = 0,
    #[doc = "< Maximum x-dimension of a block."]
    hipDeviceAttributeMaxBlockDimX = 1,
    #[doc = "< Maximum y-dimension of a block."]
    hipDeviceAttributeMaxBlockDimY = 2,
    #[doc = "< Maximum z-dimension of a block."]
    hipDeviceAttributeMaxBlockDimZ = 3,
    #[doc = "< Maximum x-dimension of a grid."]
    hipDeviceAttributeMaxGridDimX = 4,
    #[doc = "< Maximum y-dimension of a grid."]
    hipDeviceAttributeMaxGridDimY = 5,
    #[doc = "< Maximum z-dimension of a grid."]
    hipDeviceAttributeMaxGridDimZ = 6,
    #[doc = "< Maximum shared memory available per block in"]
    #[doc = "< bytes."]
    hipDeviceAttributeMaxSharedMemoryPerBlock = 7,
    #[doc = "< Constant memory size in bytes."]
    hipDeviceAttributeTotalConstantMemory = 8,
    #[doc = "< Warp size in threads."]
    hipDeviceAttributeWarpSize = 9,
    #[doc = "< Maximum number of 32-bit registers available to a"]
    #[doc = "< thread block. This number is shared by all thread"]
    #[doc = "< blocks simultaneously resident on a"]
    #[doc = "< multiprocessor."]
    hipDeviceAttributeMaxRegistersPerBlock = 10,
    #[doc = "< Peak clock frequency in kilohertz."]
    hipDeviceAttributeClockRate = 11,
    #[doc = "< Peak memory clock frequency in kilohertz."]
    hipDeviceAttributeMemoryClockRate = 12,
    #[doc = "< Global memory bus width in bits."]
    hipDeviceAttributeMemoryBusWidth = 13,
    #[doc = "< Number of multiprocessors on the device."]
    hipDeviceAttributeMultiprocessorCount = 14,
    #[doc = "< Compute mode that device is currently in."]
    hipDeviceAttributeComputeMode = 15,
    #[doc = "< Size of L2 cache in bytes. 0 if the device doesn't have L2"]
    #[doc = "< cache."]
    hipDeviceAttributeL2CacheSize = 16,
    #[doc = "< Maximum resident threads per"]
    #[doc = "< multiprocessor."]
    hipDeviceAttributeMaxThreadsPerMultiProcessor = 17,
    #[doc = "< Major compute capability version number."]
    hipDeviceAttributeComputeCapabilityMajor = 18,
    #[doc = "< Minor compute capability version number."]
    hipDeviceAttributeComputeCapabilityMinor = 19,
    #[doc = "< Device can possibly execute multiple kernels"]
    #[doc = "< concurrently."]
    hipDeviceAttributeConcurrentKernels = 20,
    #[doc = "< PCI Bus ID."]
    hipDeviceAttributePciBusId = 21,
    #[doc = "< PCI Device ID."]
    hipDeviceAttributePciDeviceId = 22,
    #[doc = "< Maximum Shared Memory Per"]
    #[doc = "< Multiprocessor."]
    hipDeviceAttributeMaxSharedMemoryPerMultiprocessor = 23,
    #[doc = "< Multiple GPU devices."]
    hipDeviceAttributeIsMultiGpuBoard = 24,
    #[doc = "< iGPU"]
    hipDeviceAttributeIntegrated = 25,
    #[doc = "< Support cooperative launch"]
    hipDeviceAttributeCooperativeLaunch = 26,
    #[doc = "< Support cooperative launch on multiple devices"]
    hipDeviceAttributeCooperativeMultiDeviceLaunch = 27,
    #[doc = "< Maximum number of elements in 1D images"]
    hipDeviceAttributeMaxTexture1DWidth = 28,
    #[doc = "< Maximum dimension width of 2D images in image elements"]
    hipDeviceAttributeMaxTexture2DWidth = 29,
    #[doc = "< Maximum dimension height of 2D images in image elements"]
    hipDeviceAttributeMaxTexture2DHeight = 30,
    #[doc = "< Maximum dimension width of 3D images in image elements"]
    hipDeviceAttributeMaxTexture3DWidth = 31,
    #[doc = "< Maximum dimensions height of 3D images in image elements"]
    hipDeviceAttributeMaxTexture3DHeight = 32,
    #[doc = "< Maximum dimensions depth of 3D images in image elements"]
    hipDeviceAttributeMaxTexture3DDepth = 33,
    #[doc = "< Address of the HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpMemFlushCntl = 34,
    #[doc = "< Address of the HDP_REG_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpRegFlushCntl = 35,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    hipDeviceAttributeMaxPitch = 36,
    #[doc = "<Alignment requirement for textures"]
    hipDeviceAttributeTextureAlignment = 37,
    #[doc = "<Pitch alignment requirement for 2D texture references bound to pitched memory;"]
    hipDeviceAttributeTexturePitchAlignment = 38,
    #[doc = "<Run time limit for kernels executed on the device"]
    hipDeviceAttributeKernelExecTimeout = 39,
    #[doc = "<Device can map host memory into device address space"]
    hipDeviceAttributeCanMapHostMemory = 40,
    #[doc = "<Device has ECC support enabled"]
    hipDeviceAttributeEccEnabled = 41,
    #[doc = "< Supports cooperative launch on multiple"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc = 42,
    #[doc = "< Supports cooperative launch on multiple"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim = 43,
    #[doc = "< Supports cooperative launch on multiple"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim = 44,
    #[doc = "< Supports cooperative launch on multiple"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem = 45,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipComputeMode {
    hipComputeModeDefault = 0,
    hipComputeModeExclusive = 1,
    hipComputeModeProhibited = 2,
    hipComputeModeExclusiveProcess = 3,
}
pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __intmax_t = ::libc::c_long;
pub type __uintmax_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
pub type __sig_atomic_t = ::libc::c_int;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type hipDeviceptr_t = *mut ::libc::c_void;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipChannelFormatKind {
    hipChannelFormatKindSigned = 0,
    hipChannelFormatKindUnsigned = 1,
    hipChannelFormatKindFloat = 2,
    hipChannelFormatKindNone = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipChannelFormatDesc {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
    pub f: hipChannelFormatKind,
}
#[test]
fn bindgen_test_layout_hipChannelFormatDesc() {
    assert_eq!(
        ::std::mem::size_of::<hipChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(hipChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(hipChannelFormatDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).f as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(f)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipArray_Format {
    HIP_AD_FORMAT_UNSIGNED_INT8 = 1,
    HIP_AD_FORMAT_UNSIGNED_INT16 = 2,
    HIP_AD_FORMAT_UNSIGNED_INT32 = 3,
    HIP_AD_FORMAT_SIGNED_INT8 = 8,
    HIP_AD_FORMAT_SIGNED_INT16 = 9,
    HIP_AD_FORMAT_SIGNED_INT32 = 10,
    HIP_AD_FORMAT_HALF = 16,
    HIP_AD_FORMAT_FLOAT = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_HIP_ARRAY_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<HIP_ARRAY_DESCRIPTOR>(),
        24usize,
        concat!("Size of: ", stringify!(HIP_ARRAY_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_ARRAY_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_ARRAY_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY_DESCRIPTOR>())).Width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY_DESCRIPTOR>())).Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY_DESCRIPTOR>())).Format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_ARRAY_DESCRIPTOR>())).NumChannels as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(NumChannels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY3D_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::libc::c_uint,
    pub Flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_HIP_ARRAY3D_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<HIP_ARRAY3D_DESCRIPTOR>(),
        40usize,
        concat!("Size of: ", stringify!(HIP_ARRAY3D_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_ARRAY3D_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_ARRAY3D_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).NumChannels as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArray {
    pub data: *mut ::libc::c_void,
    pub desc: hipChannelFormatDesc,
    pub type_: ::libc::c_uint,
    pub width: ::libc::c_uint,
    pub height: ::libc::c_uint,
    pub depth: ::libc::c_uint,
    pub Format: hipArray_Format,
    pub NumChannels: ::libc::c_uint,
    pub isDrv: bool,
    pub textureType: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipArray() {
    assert_eq!(
        ::std::mem::size_of::<hipArray>(),
        64usize,
        concat!("Size of: ", stringify!(hipArray))
    );
    assert_eq!(
        ::std::mem::align_of::<hipArray>(),
        8usize,
        concat!("Alignment of ", stringify!(hipArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).type_ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).width as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).height as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).depth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).Format as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).NumChannels as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).isDrv as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(isDrv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).textureType as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(textureType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hip_Memcpy2D {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::libc::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: *mut hipArray,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::libc::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: *mut hipArray,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
#[test]
fn bindgen_test_layout_hip_Memcpy2D() {
    assert_eq!(
        ::std::mem::size_of::<hip_Memcpy2D>(),
        128usize,
        concat!("Size of: ", stringify!(hip_Memcpy2D))
    );
    assert_eq!(
        ::std::mem::align_of::<hip_Memcpy2D>(),
        8usize,
        concat!("Alignment of ", stringify!(hip_Memcpy2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcMemoryType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcHost as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcDevice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcArray as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcPitch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstXInBytes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstY as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstMemoryType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstHost as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstDevice as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstArray as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstPitch as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).WidthInBytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).Height as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(Height)
        )
    );
}
pub type hipArray_t = *mut hipArray;
pub type hipArray_const_t = *const hipArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMipmappedArray {
    pub data: *mut ::libc::c_void,
    pub desc: hipChannelFormatDesc,
    pub width: ::libc::c_uint,
    pub height: ::libc::c_uint,
    pub depth: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipMipmappedArray() {
    assert_eq!(
        ::std::mem::size_of::<hipMipmappedArray>(),
        40usize,
        concat!("Size of: ", stringify!(hipMipmappedArray))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMipmappedArray>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMipmappedArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).width as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).height as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).depth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(depth)
        )
    );
}
pub type hipMipmappedArray_t = *mut hipMipmappedArray;
pub type hipMipmappedArray_const_t = *const hipMipmappedArray;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip resource types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipResourceType {
    hipResourceTypeArray = 0,
    hipResourceTypeMipmappedArray = 1,
    hipResourceTypeLinear = 2,
    hipResourceTypePitch2D = 3,
}
#[doc = "< Array resoure"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_ARRAY: HIPresourcetype_enum = 0;
#[doc = "< Mipmapped array resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY: HIPresourcetype_enum = 1;
#[doc = "< Linear resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_LINEAR: HIPresourcetype_enum = 2;
#[doc = "< Pitch 2D resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_PITCH2D: HIPresourcetype_enum = 3;
pub type HIPresourcetype_enum = u32;
pub use self::HIPresourcetype_enum as HIPresourcetype;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_WRAP: HIPaddress_mode_enum = 0;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_CLAMP: HIPaddress_mode_enum = 1;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_MIRROR: HIPaddress_mode_enum = 2;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_BORDER: HIPaddress_mode_enum = 3;
#[doc = " hip address modes"]
pub type HIPaddress_mode_enum = u32;
#[doc = " hip address modes"]
pub use self::HIPaddress_mode_enum as HIPaddress_mode;
pub const HIPfilter_mode_enum_HIP_TR_FILTER_MODE_POINT: HIPfilter_mode_enum = 0;
pub const HIPfilter_mode_enum_HIP_TR_FILTER_MODE_LINEAR: HIPfilter_mode_enum = 1;
#[doc = " hip filter modes"]
pub type HIPfilter_mode_enum = u32;
#[doc = " hip filter modes"]
pub use self::HIPfilter_mode_enum as HIPfilter_mode;
#[doc = " Texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [HIPaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: HIPfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::libc::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::libc::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: HIPfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::libc::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_HIP_TEXTURE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<HIP_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(HIP_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(HIP_TEXTURE_DESC_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).addressMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).filterMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).maxAnisotropy as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).mipmapFilterMode as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).mipmapLevelBias as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).minMipmapLevelClamp as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).maxMipmapLevelClamp as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).borderColor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Texture descriptor"]
pub type HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture resource view formats"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipResourceViewFormat {
    hipResViewFormatNone = 0,
    hipResViewFormatUnsignedChar1 = 1,
    hipResViewFormatUnsignedChar2 = 2,
    hipResViewFormatUnsignedChar4 = 3,
    hipResViewFormatSignedChar1 = 4,
    hipResViewFormatSignedChar2 = 5,
    hipResViewFormatSignedChar4 = 6,
    hipResViewFormatUnsignedShort1 = 7,
    hipResViewFormatUnsignedShort2 = 8,
    hipResViewFormatUnsignedShort4 = 9,
    hipResViewFormatSignedShort1 = 10,
    hipResViewFormatSignedShort2 = 11,
    hipResViewFormatSignedShort4 = 12,
    hipResViewFormatUnsignedInt1 = 13,
    hipResViewFormatUnsignedInt2 = 14,
    hipResViewFormatUnsignedInt4 = 15,
    hipResViewFormatSignedInt1 = 16,
    hipResViewFormatSignedInt2 = 17,
    hipResViewFormatSignedInt4 = 18,
    hipResViewFormatHalf1 = 19,
    hipResViewFormatHalf2 = 20,
    hipResViewFormatHalf4 = 21,
    hipResViewFormatFloat1 = 22,
    hipResViewFormatFloat2 = 23,
    hipResViewFormatFloat4 = 24,
    hipResViewFormatUnsignedBlockCompressed1 = 25,
    hipResViewFormatUnsignedBlockCompressed2 = 26,
    hipResViewFormatUnsignedBlockCompressed3 = 27,
    hipResViewFormatUnsignedBlockCompressed4 = 28,
    hipResViewFormatSignedBlockCompressed4 = 29,
    hipResViewFormatUnsignedBlockCompressed5 = 30,
    hipResViewFormatSignedBlockCompressed5 = 31,
    hipResViewFormatUnsignedBlockCompressed6H = 32,
    hipResViewFormatSignedBlockCompressed6H = 33,
    hipResViewFormatUnsignedBlockCompressed7 = 34,
}
#[doc = "< No resource view format (use underlying resource format)"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_NONE: HIPresourceViewFormat_enum = 0;
#[doc = "< 1 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X8: HIPresourceViewFormat_enum = 1;
#[doc = "< 2 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X8: HIPresourceViewFormat_enum = 2;
#[doc = "< 4 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X8: HIPresourceViewFormat_enum = 3;
#[doc = "< 1 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X8: HIPresourceViewFormat_enum = 4;
#[doc = "< 2 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X8: HIPresourceViewFormat_enum = 5;
#[doc = "< 4 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X8: HIPresourceViewFormat_enum = 6;
#[doc = "< 1 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X16: HIPresourceViewFormat_enum = 7;
#[doc = "< 2 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X16: HIPresourceViewFormat_enum = 8;
#[doc = "< 4 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X16: HIPresourceViewFormat_enum = 9;
#[doc = "< 1 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X16: HIPresourceViewFormat_enum = 10;
#[doc = "< 2 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X16: HIPresourceViewFormat_enum = 11;
#[doc = "< 4 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X16: HIPresourceViewFormat_enum = 12;
#[doc = "< 1 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X32: HIPresourceViewFormat_enum = 13;
#[doc = "< 2 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X32: HIPresourceViewFormat_enum = 14;
#[doc = "< 4 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X32: HIPresourceViewFormat_enum = 15;
#[doc = "< 1 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X32: HIPresourceViewFormat_enum = 16;
#[doc = "< 2 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X32: HIPresourceViewFormat_enum = 17;
#[doc = "< 4 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X32: HIPresourceViewFormat_enum = 18;
#[doc = "< 1 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_1X16: HIPresourceViewFormat_enum =
    19;
#[doc = "< 2 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_2X16: HIPresourceViewFormat_enum =
    20;
#[doc = "< 4 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_4X16: HIPresourceViewFormat_enum =
    21;
#[doc = "< 1 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_1X32: HIPresourceViewFormat_enum =
    22;
#[doc = "< 2 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_2X32: HIPresourceViewFormat_enum =
    23;
#[doc = "< 4 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_4X32: HIPresourceViewFormat_enum =
    24;
#[doc = "< Block compressed 1"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC1: HIPresourceViewFormat_enum =
    25;
#[doc = "< Block compressed 2"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC2: HIPresourceViewFormat_enum =
    26;
#[doc = "< Block compressed 3"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC3: HIPresourceViewFormat_enum =
    27;
#[doc = "< Block compressed 4 unsigned"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC4: HIPresourceViewFormat_enum =
    28;
#[doc = "< Block compressed 4 signed"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC4: HIPresourceViewFormat_enum =
    29;
#[doc = "< Block compressed 5 unsigned"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC5: HIPresourceViewFormat_enum =
    30;
#[doc = "< Block compressed 5 signed"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC5: HIPresourceViewFormat_enum =
    31;
#[doc = "< Block compressed 6 unsigned half-float"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H: HIPresourceViewFormat_enum =
    32;
#[doc = "< Block compressed 6 signed half-float"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC6H: HIPresourceViewFormat_enum =
    33;
#[doc = "< Block compressed 7"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC7: HIPresourceViewFormat_enum =
    34;
pub type HIPresourceViewFormat_enum = u32;
pub use self::HIPresourceViewFormat_enum as HIPresourceViewFormat;
#[doc = " HIP resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipResourceDesc {
    pub resType: hipResourceType,
    pub res: hipResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipResourceDesc__bindgen_ty_1 {
    pub array: hipResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: hipResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: hipResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: hipResourceDesc__bindgen_ty_1__bindgen_ty_4,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: hipArray_t,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_1>())).array
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: hipMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_2>())).mipmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mipmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: hipChannelFormatDesc,
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>())).desc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>())).sizeInBytes
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: hipChannelFormatDesc,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).desc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).pitchInBytes
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(hipResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1>())).array as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1>())).mipmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1>())).linear as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1>())).pitch2D as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
}
#[test]
fn bindgen_test_layout_hipResourceDesc() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(hipResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceDesc>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceDesc>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc),
            "::",
            stringify!(res)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: HIPresourcetype,
    pub res: HIP_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HIP_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< HIP array"]
    pub hArray: hipArray_t,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>())).hArray
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HIP mipmapped array"]
    pub hMipmappedArray: hipMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>()))
                .hMipmappedArray as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hMipmappedArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::libc::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).numChannels
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).sizeInBytes
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::libc::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).numChannels
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>()))
                .pitchInBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::libc::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).array as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).mipmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).linear as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).pitch2D as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_RESOURCE_DESC_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st;
#[doc = " hip resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceViewDesc {
    pub format: hipResourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::libc::c_uint,
    pub lastMipmapLevel: ::libc::c_uint,
    pub firstLayer: ::libc::c_uint,
    pub lastLayer: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipResourceViewDesc() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(hipResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceViewDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceViewDesc>())).firstMipmapLevel as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceViewDesc>())).lastMipmapLevel as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).firstLayer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).lastLayer as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(lastLayer)
        )
    );
}
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: HIPresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::libc::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::libc::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::libc::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_VIEW_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).format as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).firstMipmapLevel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).lastMipmapLevel as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).firstLayer as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).lastLayer as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).reserved as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Resource view descriptor"]
pub type HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Memory copy types"]
#[doc = ""]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipMemcpyKind {
    #[doc = "< Host-to-Host Copy"]
    hipMemcpyHostToHost = 0,
    #[doc = "< Host-to-Device Copy"]
    hipMemcpyHostToDevice = 1,
    #[doc = "< Device-to-Host Copy"]
    hipMemcpyDeviceToHost = 2,
    #[doc = "< Device-to-Device Copy"]
    hipMemcpyDeviceToDevice = 3,
    hipMemcpyDefault = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPitchedPtr {
    pub ptr: *mut ::libc::c_void,
    pub pitch: usize,
    pub xsize: usize,
    pub ysize: usize,
}
#[test]
fn bindgen_test_layout_hipPitchedPtr() {
    assert_eq!(
        ::std::mem::size_of::<hipPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(hipPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPitchedPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPitchedPtr>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPitchedPtr>())).pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPitchedPtr>())).xsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPitchedPtr>())).ysize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(ysize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_hipExtent() {
    assert_eq!(
        ::std::mem::size_of::<hipExtent>(),
        24usize,
        concat!("Size of: ", stringify!(hipExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(hipExtent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipExtent>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipExtent>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipExtent>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPos {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[test]
fn bindgen_test_layout_hipPos() {
    assert_eq!(
        ::std::mem::size_of::<hipPos>(),
        24usize,
        concat!("Size of: ", stringify!(hipPos))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPos>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPos>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPos>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPos>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemcpy3DParms {
    pub srcArray: hipArray_t,
    pub srcPos: hipPos,
    pub srcPtr: hipPitchedPtr,
    pub dstArray: hipArray_t,
    pub dstPos: hipPos,
    pub dstPtr: hipPitchedPtr,
    pub extent: hipExtent,
    pub kind: hipMemcpyKind,
}
#[test]
fn bindgen_test_layout_hipMemcpy3DParms() {
    assert_eq!(
        ::std::mem::size_of::<hipMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(hipMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemcpy3DParms))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).srcArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).srcPos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).srcPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).dstArray as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).dstPos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).dstPtr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).extent as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).kind as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(kind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_MEMCPY3D {
    pub srcXInBytes: ::libc::c_uint,
    pub srcY: ::libc::c_uint,
    pub srcZ: ::libc::c_uint,
    pub srcLOD: ::libc::c_uint,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::libc::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: hipArray_t,
    pub srcPitch: ::libc::c_uint,
    pub srcHeight: ::libc::c_uint,
    pub dstXInBytes: ::libc::c_uint,
    pub dstY: ::libc::c_uint,
    pub dstZ: ::libc::c_uint,
    pub dstLOD: ::libc::c_uint,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::libc::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: hipArray_t,
    pub dstPitch: ::libc::c_uint,
    pub dstHeight: ::libc::c_uint,
    pub WidthInBytes: ::libc::c_uint,
    pub Height: ::libc::c_uint,
    pub Depth: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_HIP_MEMCPY3D() {
    assert_eq!(
        ::std::mem::size_of::<HIP_MEMCPY3D>(),
        128usize,
        concat!("Size of: ", stringify!(HIP_MEMCPY3D))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_MEMCPY3D>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_MEMCPY3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcLOD as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcMemoryType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcHost as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcDevice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcArray as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcPitch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcHeight as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstXInBytes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstY as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstZ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstLOD as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstMemoryType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstHost as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstDevice as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstArray as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstPitch as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstHeight as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).WidthInBytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).Height as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).Depth as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(Depth)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipFunction_attribute {
    HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    HIP_FUNC_ATTRIBUTE_NUM_REGS = 4,
    HIP_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    HIP_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    HIP_FUNC_ATTRIBUTE_MAX = 10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar1 {
    pub x: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar1() {
    assert_eq!(
        ::std::mem::size_of::<uchar1>(),
        1usize,
        concat!("Size of: ", stringify!(uchar1))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar1>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar2 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar2() {
    assert_eq!(
        ::std::mem::size_of::<uchar2>(),
        2usize,
        concat!("Size of: ", stringify!(uchar2))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar2>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar2>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar3 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
    pub z: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar3() {
    assert_eq!(
        ::std::mem::size_of::<uchar3>(),
        3usize,
        concat!("Size of: ", stringify!(uchar3))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar3>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar3>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar3>())).z as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar4 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
    pub z: ::libc::c_uchar,
    pub w: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar4() {
    assert_eq!(
        ::std::mem::size_of::<uchar4>(),
        4usize,
        concat!("Size of: ", stringify!(uchar4))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar4>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar4>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar4>())).z as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar4>())).w as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char1 {
    pub x: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_char1() {
    assert_eq!(
        ::std::mem::size_of::<char1>(),
        1usize,
        concat!("Size of: ", stringify!(char1))
    );
    assert_eq!(
        ::std::mem::align_of::<char1>(),
        1usize,
        concat!("Alignment of ", stringify!(char1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char2 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_char2() {
    assert_eq!(
        ::std::mem::size_of::<char2>(),
        2usize,
        concat!("Size of: ", stringify!(char2))
    );
    assert_eq!(
        ::std::mem::align_of::<char2>(),
        1usize,
        concat!("Alignment of ", stringify!(char2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char2>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char3 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
    pub z: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_char3() {
    assert_eq!(
        ::std::mem::size_of::<char3>(),
        3usize,
        concat!("Size of: ", stringify!(char3))
    );
    assert_eq!(
        ::std::mem::align_of::<char3>(),
        1usize,
        concat!("Alignment of ", stringify!(char3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char3>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char3>())).z as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char4 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
    pub z: ::libc::c_char,
    pub w: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_char4() {
    assert_eq!(
        ::std::mem::size_of::<char4>(),
        4usize,
        concat!("Size of: ", stringify!(char4))
    );
    assert_eq!(
        ::std::mem::align_of::<char4>(),
        1usize,
        concat!("Alignment of ", stringify!(char4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char4>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char4>())).z as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char4>())).w as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort1 {
    pub x: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort1() {
    assert_eq!(
        ::std::mem::size_of::<ushort1>(),
        2usize,
        concat!("Size of: ", stringify!(ushort1))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort1>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort2 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort2() {
    assert_eq!(
        ::std::mem::size_of::<ushort2>(),
        4usize,
        concat!("Size of: ", stringify!(ushort2))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort2>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort2>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort3 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
    pub z: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort3() {
    assert_eq!(
        ::std::mem::size_of::<ushort3>(),
        6usize,
        concat!("Size of: ", stringify!(ushort3))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort3>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort3>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort3>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort4 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
    pub z: ::libc::c_ushort,
    pub w: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort4() {
    assert_eq!(
        ::std::mem::size_of::<ushort4>(),
        8usize,
        concat!("Size of: ", stringify!(ushort4))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort4>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort4>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort4>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort4>())).w as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short1 {
    pub x: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_short1() {
    assert_eq!(
        ::std::mem::size_of::<short1>(),
        2usize,
        concat!("Size of: ", stringify!(short1))
    );
    assert_eq!(
        ::std::mem::align_of::<short1>(),
        2usize,
        concat!("Alignment of ", stringify!(short1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short2 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_short2() {
    assert_eq!(
        ::std::mem::size_of::<short2>(),
        4usize,
        concat!("Size of: ", stringify!(short2))
    );
    assert_eq!(
        ::std::mem::align_of::<short2>(),
        2usize,
        concat!("Alignment of ", stringify!(short2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short2>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short3 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
    pub z: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_short3() {
    assert_eq!(
        ::std::mem::size_of::<short3>(),
        6usize,
        concat!("Size of: ", stringify!(short3))
    );
    assert_eq!(
        ::std::mem::align_of::<short3>(),
        2usize,
        concat!("Alignment of ", stringify!(short3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short3>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short3>())).z as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short4 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
    pub z: ::libc::c_short,
    pub w: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_short4() {
    assert_eq!(
        ::std::mem::size_of::<short4>(),
        8usize,
        concat!("Size of: ", stringify!(short4))
    );
    assert_eq!(
        ::std::mem::align_of::<short4>(),
        2usize,
        concat!("Alignment of ", stringify!(short4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short4>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short4>())).z as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short4>())).w as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint1 {
    pub x: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_uint1() {
    assert_eq!(
        ::std::mem::size_of::<uint1>(),
        4usize,
        concat!("Size of: ", stringify!(uint1))
    );
    assert_eq!(
        ::std::mem::align_of::<uint1>(),
        4usize,
        concat!("Alignment of ", stringify!(uint1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint2 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_uint2() {
    assert_eq!(
        ::std::mem::size_of::<uint2>(),
        8usize,
        concat!("Size of: ", stringify!(uint2))
    );
    assert_eq!(
        ::std::mem::align_of::<uint2>(),
        4usize,
        concat!("Alignment of ", stringify!(uint2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint3 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_uint3() {
    assert_eq!(
        ::std::mem::size_of::<uint3>(),
        12usize,
        concat!("Size of: ", stringify!(uint3))
    );
    assert_eq!(
        ::std::mem::align_of::<uint3>(),
        4usize,
        concat!("Alignment of ", stringify!(uint3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint4 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
    pub w: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_uint4() {
    assert_eq!(
        ::std::mem::size_of::<uint4>(),
        16usize,
        concat!("Size of: ", stringify!(uint4))
    );
    assert_eq!(
        ::std::mem::align_of::<uint4>(),
        4usize,
        concat!("Alignment of ", stringify!(uint4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint4>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint4>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint4>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int1 {
    pub x: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_int1() {
    assert_eq!(
        ::std::mem::size_of::<int1>(),
        4usize,
        concat!("Size of: ", stringify!(int1))
    );
    assert_eq!(
        ::std::mem::align_of::<int1>(),
        4usize,
        concat!("Alignment of ", stringify!(int1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int2 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_int2() {
    assert_eq!(
        ::std::mem::size_of::<int2>(),
        8usize,
        concat!("Size of: ", stringify!(int2))
    );
    assert_eq!(
        ::std::mem::align_of::<int2>(),
        4usize,
        concat!("Alignment of ", stringify!(int2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int3 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_int3() {
    assert_eq!(
        ::std::mem::size_of::<int3>(),
        12usize,
        concat!("Size of: ", stringify!(int3))
    );
    assert_eq!(
        ::std::mem::align_of::<int3>(),
        4usize,
        concat!("Alignment of ", stringify!(int3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int4 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_int4() {
    assert_eq!(
        ::std::mem::size_of::<int4>(),
        16usize,
        concat!("Size of: ", stringify!(int4))
    );
    assert_eq!(
        ::std::mem::align_of::<int4>(),
        4usize,
        concat!("Alignment of ", stringify!(int4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int4>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int4>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int4>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong1 {
    pub x: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong1() {
    assert_eq!(
        ::std::mem::size_of::<ulong1>(),
        8usize,
        concat!("Size of: ", stringify!(ulong1))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong1>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong2 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong2() {
    assert_eq!(
        ::std::mem::size_of::<ulong2>(),
        16usize,
        concat!("Size of: ", stringify!(ulong2))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong2>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong2>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong3 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
    pub z: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong3() {
    assert_eq!(
        ::std::mem::size_of::<ulong3>(),
        24usize,
        concat!("Size of: ", stringify!(ulong3))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong3>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong3>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong3>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong4 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
    pub z: ::libc::c_ulong,
    pub w: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong4() {
    assert_eq!(
        ::std::mem::size_of::<ulong4>(),
        32usize,
        concat!("Size of: ", stringify!(ulong4))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong4>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong4>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong4>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong4>())).w as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long1 {
    pub x: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_long1() {
    assert_eq!(
        ::std::mem::size_of::<long1>(),
        8usize,
        concat!("Size of: ", stringify!(long1))
    );
    assert_eq!(
        ::std::mem::align_of::<long1>(),
        8usize,
        concat!("Alignment of ", stringify!(long1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long2 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_long2() {
    assert_eq!(
        ::std::mem::size_of::<long2>(),
        16usize,
        concat!("Size of: ", stringify!(long2))
    );
    assert_eq!(
        ::std::mem::align_of::<long2>(),
        8usize,
        concat!("Alignment of ", stringify!(long2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long2>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long3 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
    pub z: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_long3() {
    assert_eq!(
        ::std::mem::size_of::<long3>(),
        24usize,
        concat!("Size of: ", stringify!(long3))
    );
    assert_eq!(
        ::std::mem::align_of::<long3>(),
        8usize,
        concat!("Alignment of ", stringify!(long3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long3>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long3>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long4 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
    pub z: ::libc::c_long,
    pub w: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_long4() {
    assert_eq!(
        ::std::mem::size_of::<long4>(),
        32usize,
        concat!("Size of: ", stringify!(long4))
    );
    assert_eq!(
        ::std::mem::align_of::<long4>(),
        8usize,
        concat!("Alignment of ", stringify!(long4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long4>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long4>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long4>())).w as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong1 {
    pub x: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong1() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong1>(),
        8usize,
        concat!("Size of: ", stringify!(ulonglong1))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong1>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong2 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong2() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong2>(),
        16usize,
        concat!("Size of: ", stringify!(ulonglong2))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong2>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong2>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong3 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
    pub z: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong3() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong3>(),
        24usize,
        concat!("Size of: ", stringify!(ulonglong3))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong3>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong3>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong3>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong4 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
    pub z: ::libc::c_ulonglong,
    pub w: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong4() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong4>(),
        32usize,
        concat!("Size of: ", stringify!(ulonglong4))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong4>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong4>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong4>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong4>())).w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong1 {
    pub x: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong1() {
    assert_eq!(
        ::std::mem::size_of::<longlong1>(),
        8usize,
        concat!("Size of: ", stringify!(longlong1))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong1>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong2 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong2() {
    assert_eq!(
        ::std::mem::size_of::<longlong2>(),
        16usize,
        concat!("Size of: ", stringify!(longlong2))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong2>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong2>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong3 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
    pub z: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong3() {
    assert_eq!(
        ::std::mem::size_of::<longlong3>(),
        24usize,
        concat!("Size of: ", stringify!(longlong3))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong3>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong3>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong3>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong4 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
    pub z: ::libc::c_longlong,
    pub w: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong4() {
    assert_eq!(
        ::std::mem::size_of::<longlong4>(),
        32usize,
        concat!("Size of: ", stringify!(longlong4))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong4>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong4>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong4>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong4>())).w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float1 {
    pub x: f32,
}
#[test]
fn bindgen_test_layout_float1() {
    assert_eq!(
        ::std::mem::size_of::<float1>(),
        4usize,
        concat!("Size of: ", stringify!(float1))
    );
    assert_eq!(
        ::std::mem::align_of::<float1>(),
        4usize,
        concat!("Alignment of ", stringify!(float1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_float2() {
    assert_eq!(
        ::std::mem::size_of::<float2>(),
        8usize,
        concat!("Size of: ", stringify!(float2))
    );
    assert_eq!(
        ::std::mem::align_of::<float2>(),
        4usize,
        concat!("Alignment of ", stringify!(float2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_float3() {
    assert_eq!(
        ::std::mem::size_of::<float3>(),
        12usize,
        concat!("Size of: ", stringify!(float3))
    );
    assert_eq!(
        ::std::mem::align_of::<float3>(),
        4usize,
        concat!("Alignment of ", stringify!(float3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_float4() {
    assert_eq!(
        ::std::mem::size_of::<float4>(),
        16usize,
        concat!("Size of: ", stringify!(float4))
    );
    assert_eq!(
        ::std::mem::align_of::<float4>(),
        4usize,
        concat!("Alignment of ", stringify!(float4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float4>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float4>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float4>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double1 {
    pub x: f64,
}
#[test]
fn bindgen_test_layout_double1() {
    assert_eq!(
        ::std::mem::size_of::<double1>(),
        8usize,
        concat!("Size of: ", stringify!(double1))
    );
    assert_eq!(
        ::std::mem::align_of::<double1>(),
        8usize,
        concat!("Alignment of ", stringify!(double1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_double2() {
    assert_eq!(
        ::std::mem::size_of::<double2>(),
        16usize,
        concat!("Size of: ", stringify!(double2))
    );
    assert_eq!(
        ::std::mem::align_of::<double2>(),
        8usize,
        concat!("Alignment of ", stringify!(double2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double2>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_double3() {
    assert_eq!(
        ::std::mem::size_of::<double3>(),
        24usize,
        concat!("Size of: ", stringify!(double3))
    );
    assert_eq!(
        ::std::mem::align_of::<double3>(),
        8usize,
        concat!("Alignment of ", stringify!(double3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double3>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double3>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double4 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_double4() {
    assert_eq!(
        ::std::mem::size_of::<double4>(),
        32usize,
        concat!("Size of: ", stringify!(double4))
    );
    assert_eq!(
        ::std::mem::align_of::<double4>(),
        8usize,
        concat!("Alignment of ", stringify!(double4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double4>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double4>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double4>())).w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(w)
        )
    );
}
extern "C" {
    pub fn hipCreateChannelDesc(
        x: ::libc::c_int,
        y: ::libc::c_int,
        z: ::libc::c_int,
        w: ::libc::c_int,
        f: hipChannelFormatKind,
    ) -> hipChannelFormatDesc;
}
#[doc = " An opaque value that represents a hip texture object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_texture {
    _unused: [u8; 0],
}
pub type hipTextureObject_t = *mut __hip_texture;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture address modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipTextureAddressMode {
    hipAddressModeWrap = 0,
    hipAddressModeClamp = 1,
    hipAddressModeMirror = 2,
    hipAddressModeBorder = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture filter modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipTextureFilterMode {
    hipFilterModePoint = 0,
    hipFilterModeLinear = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture read modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipTextureReadMode {
    hipReadModeElementType = 0,
    hipReadModeNormalizedFloat = 1,
}
#[doc = " hip texture reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textureReference {
    pub normalized: ::libc::c_int,
    pub readMode: hipTextureReadMode,
    pub filterMode: hipTextureFilterMode,
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub channelDesc: hipChannelFormatDesc,
    pub sRGB: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub textureObject: hipTextureObject_t,
    pub numChannels: ::libc::c_int,
    pub format: hipArray_Format,
}
#[test]
fn bindgen_test_layout_textureReference() {
    assert_eq!(
        ::std::mem::size_of::<textureReference>(),
        88usize,
        concat!("Size of: ", stringify!(textureReference))
    );
    assert_eq!(
        ::std::mem::align_of::<textureReference>(),
        8usize,
        concat!("Alignment of ", stringify!(textureReference))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).normalized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(normalized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).readMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(readMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).filterMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).addressMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).channelDesc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(channelDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).sRGB as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(sRGB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).maxAnisotropy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).mipmapFilterMode as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).mipmapLevelBias as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).minMipmapLevelClamp as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).maxMipmapLevelClamp as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).textureObject as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(textureObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).numChannels as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).format as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(format)
        )
    );
}
#[doc = " hip texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipTextureDesc {
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub filterMode: hipTextureFilterMode,
    pub readMode: hipTextureReadMode,
    pub sRGB: ::libc::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
}
#[test]
fn bindgen_test_layout_hipTextureDesc() {
    assert_eq!(
        ::std::mem::size_of::<hipTextureDesc>(),
        64usize,
        concat!("Size of: ", stringify!(hipTextureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipTextureDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(hipTextureDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).addressMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).filterMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).readMode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(readMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).sRGB as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(sRGB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).borderColor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).normalizedCoords as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(normalizedCoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).maxAnisotropy as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).mipmapFilterMode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).mipmapLevelBias as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipTextureDesc>())).minMipmapLevelClamp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipTextureDesc>())).maxMipmapLevelClamp as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
}
#[doc = " An opaque value that represents a hip surface object"]
pub type hipSurfaceObject_t = ::libc::c_ulonglong;
#[doc = " hip surface reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct surfaceReference {
    pub surfaceObject: hipSurfaceObject_t,
}
#[test]
fn bindgen_test_layout_surfaceReference() {
    assert_eq!(
        ::std::mem::size_of::<surfaceReference>(),
        8usize,
        concat!("Size of: ", stringify!(surfaceReference))
    );
    assert_eq!(
        ::std::mem::align_of::<surfaceReference>(),
        8usize,
        concat!("Alignment of ", stringify!(surfaceReference))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<surfaceReference>())).surfaceObject as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(surfaceReference),
            "::",
            stringify!(surfaceObject)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip surface boundary modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipSurfaceBoundaryMode {
    hipBoundaryModeZero = 0,
    hipBoundaryModeTrap = 1,
    hipBoundaryModeClamp = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipCtx_t {
    _unused: [u8; 0],
}
pub type hipCtx_t = *mut ihipCtx_t;
pub type hipDevice_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipIpcMemHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_hipIpcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<hipIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(hipIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(hipIpcMemHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipIpcMemHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipIpcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type hipIpcMemHandle_t = hipIpcMemHandle_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipIpcEventHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_hipIpcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<hipIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(hipIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(hipIpcEventHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipIpcEventHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipIpcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type hipIpcEventHandle_t = hipIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModule_t {
    _unused: [u8; 0],
}
pub type hipModule_t = *mut ihipModule_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModuleSymbol_t {
    _unused: [u8; 0],
}
pub type hipFunction_t = *mut ihipModuleSymbol_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipFuncAttributes {
    pub binaryVersion: ::libc::c_int,
    pub cacheModeCA: ::libc::c_int,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxDynamicSharedSizeBytes: ::libc::c_int,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub numRegs: ::libc::c_int,
    pub preferredShmemCarveout: ::libc::c_int,
    pub ptxVersion: ::libc::c_int,
    pub sharedSizeBytes: usize,
}
#[test]
fn bindgen_test_layout_hipFuncAttributes() {
    assert_eq!(
        ::std::mem::size_of::<hipFuncAttributes>(),
        56usize,
        concat!("Size of: ", stringify!(hipFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<hipFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(hipFuncAttributes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipFuncAttributes>())).binaryVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(binaryVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipFuncAttributes>())).cacheModeCA as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(cacheModeCA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).constSizeBytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(constSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).localSizeBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(localSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).maxDynamicSharedSizeBytes as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(maxDynamicSharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).maxThreadsPerBlock as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipFuncAttributes>())).numRegs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(numRegs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).preferredShmemCarveout as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(preferredShmemCarveout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipFuncAttributes>())).ptxVersion as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(ptxVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).sharedSizeBytes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(sharedSizeBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipEvent_t {
    _unused: [u8; 0],
}
pub type hipEvent_t = *mut ihipEvent_t;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipLimit_t {
    hipLimitMallocHeapSize = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipJitOption {
    hipJitOptionMaxRegisters = 0,
    hipJitOptionThreadsPerBlock = 1,
    hipJitOptionWallTime = 2,
    hipJitOptionInfoLogBuffer = 3,
    hipJitOptionInfoLogBufferSizeBytes = 4,
    hipJitOptionErrorLogBuffer = 5,
    hipJitOptionErrorLogBufferSizeBytes = 6,
    hipJitOptionOptimizationLevel = 7,
    hipJitOptionTargetFromContext = 8,
    hipJitOptionTarget = 9,
    hipJitOptionFallbackStrategy = 10,
    hipJitOptionGenerateDebugInfo = 11,
    hipJitOptionLogVerbose = 12,
    hipJitOptionGenerateLineInfo = 13,
    hipJitOptionCacheMode = 14,
    hipJitOptionSm3xOpt = 15,
    hipJitOptionFastCompile = 16,
    hipJitOptionNumOptions = 17,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipFuncCache_t {
    #[doc = "< no preference for shared memory or L1 (default)"]
    hipFuncCachePreferNone = 0,
    #[doc = "< prefer larger shared memory and smaller L1 cache"]
    hipFuncCachePreferShared = 1,
    #[doc = "< prefer larger L1 cache and smaller shared memory"]
    hipFuncCachePreferL1 = 2,
    #[doc = "< prefer equal size L1 cache and shared memory"]
    hipFuncCachePreferEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipSharedMemConfig {
    #[doc = "< The compiler selects a device-specific value for the banking."]
    hipSharedMemBankSizeDefault = 0,
    #[doc = "< Shared mem is banked at 4-bytes intervals and performs best"]
    #[doc = "< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeFourByte = 1,
    #[doc = "< Shared mem is banked at 8-byte intervals and performs best"]
    #[doc = "< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeEightByte = 2,
}
#[doc = " Struct for data in 3D"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    #[doc = "< x"]
    pub x: u32,
    #[doc = "< y"]
    pub y: u32,
    #[doc = "< z"]
    pub z: u32,
}
#[test]
fn bindgen_test_layout_dim3() {
    assert_eq!(
        ::std::mem::size_of::<dim3>(),
        12usize,
        concat!("Size of: ", stringify!(dim3))
    );
    assert_eq!(
        ::std::mem::align_of::<dim3>(),
        4usize,
        concat!("Alignment of ", stringify!(dim3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipLaunchParams_t {
    #[doc = "< Device function symbol"]
    pub func: *mut ::libc::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::libc::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: hipStream_t,
}
#[test]
fn bindgen_test_layout_hipLaunchParams_t() {
    assert_eq!(
        ::std::mem::size_of::<hipLaunchParams_t>(),
        56usize,
        concat!("Size of: ", stringify!(hipLaunchParams_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipLaunchParams_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipLaunchParams_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).gridDim as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).blockDim as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).sharedMem as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(sharedMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).stream as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(stream)
        )
    );
}
pub type hipLaunchParams = hipLaunchParams_t;
extern "C" {
    #[doc = " @brief Waits on all active streams on current device"]
    #[doc = ""]
    #[doc = " When this command is invoked, the host thread gets blocked until all the commands associated"]
    #[doc = " with streams associated with the device. HIP does not support multiple blocking modes (yet!)."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipSetDevice, hipDeviceReset"]
    pub fn hipDeviceSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief The state of current device is discarded and updated to a fresh state."]
    #[doc = ""]
    #[doc = " Calling this function deletes all streams created, memory allocated, kernels running, events"]
    #[doc = " created. Make sure that no other thread is using the device or streams, memory, kernels, events"]
    #[doc = " associated with the current device."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipDeviceSynchronize"]
    pub fn hipDeviceReset() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set default device to be used for subsequent hip API calls from this thread."]
    #[doc = ""]
    #[doc = " @param[in] deviceId Valid device in range 0...hipGetDeviceCount()."]
    #[doc = ""]
    #[doc = " Sets @p device as the default device for the calling host thread.  Valid device id's are 0..."]
    #[doc = " (hipGetDeviceCount()-1)."]
    #[doc = ""]
    #[doc = " Many HIP APIs implicitly use the \"default device\" :"]
    #[doc = ""]
    #[doc = " - Any device memory subsequently allocated from this host thread (using hipMalloc) will be"]
    #[doc = " allocated on device."]
    #[doc = " - Any streams or events created from this host thread will be associated with device."]
    #[doc = " - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device"]
    #[doc = " (unless a specific stream is specified, in which case the device associated with that stream will"]
    #[doc = " be used)."]
    #[doc = ""]
    #[doc = " This function may be called from any host thread.  Multiple host threads may use the same device."]
    #[doc = " This function does no synchronization with the previous or new device, and has very little"]
    #[doc = " runtime overhead. Applications can use hipSetDevice to quickly switch the default device before"]
    #[doc = " making a HIP runtime call which uses the default device."]
    #[doc = ""]
    #[doc = " The default device is stored in thread-local-storage for each thread."]
    #[doc = " Thread-pool implementations may inherit the default device of the previous thread.  A good"]
    #[doc = " practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known"]
    #[doc = " standard device."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorDeviceAlreadyInUse"]
    #[doc = ""]
    #[doc = " @see hipGetDevice, hipGetDeviceCount"]
    pub fn hipSetDevice(deviceId: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the default device id for the calling host thread."]
    #[doc = ""]
    #[doc = " @param [out] device *device is written with the default device"]
    #[doc = ""]
    #[doc = " HIP maintains an default device for each thread using thread-local-storage."]
    #[doc = " This device is used implicitly for HIP runtime APIs called by this thread."]
    #[doc = " hipGetDevice returns in * @p device the default device for the calling host thread."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipSetDevice, hipGetDevicesizeBytes"]
    pub fn hipGetDevice(deviceId: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return number of compute-capable devices."]
    #[doc = ""]
    #[doc = " @param [output] count Returns number of compute-capable devices."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNoDevice"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Returns in @p *count the number of devices that have ability to run compute commands.  If there"]
    #[doc = " are no such devices, then @ref hipGetDeviceCount will return #hipErrorNoDevice. If 1 or more"]
    #[doc = " devices can be found, then hipGetDeviceCount returns #hipSuccess."]
    pub fn hipGetDeviceCount(count: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query for a specific device attribute."]
    #[doc = ""]
    #[doc = " @param [out] pi pointer to value to return"]
    #[doc = " @param [in] attr attribute to query"]
    #[doc = " @param [in] deviceId which device to query for information"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetAttribute(
        pi: *mut ::libc::c_int,
        attr: hipDeviceAttribute_t,
        deviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns device properties."]
    #[doc = ""]
    #[doc = " @param [out] prop written with device properties"]
    #[doc = " @param [in]  deviceId which device to query for information"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidDevice"]
    #[doc = " @bug HCC always returns 0 for maxThreadsPerMultiProcessor"]
    #[doc = " @bug HCC always returns 0 for regsPerBlock"]
    #[doc = " @bug HCC always returns 0 for l2CacheSize"]
    #[doc = ""]
    #[doc = " Populates hipGetDeviceProperties with information for the specified device."]
    pub fn hipGetDeviceProperties(
        prop: *mut hipDeviceProp_t,
        deviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition."]
    #[doc = ""]
    #[doc = " @param [in] cacheConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipDeviceSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [in] cacheConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipDeviceGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Resource limits of current device"]
    #[doc = ""]
    #[doc = " @param [out] pValue"]
    #[doc = " @param [in]  limit"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue"]
    #[doc = " Note: Currently, only hipLimitMallocHeapSize is available"]
    #[doc = ""]
    pub fn hipDeviceGetLimit(pValue: *mut usize, limit: hipLimit_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [in] config;"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipFuncSetCacheConfig(func: *const ::libc::c_void, config: hipFuncCache_t)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns bank width of shared memory for current device"]
    #[doc = ""]
    #[doc = " @param [out] pConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    pub fn hipDeviceGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The bank width of shared memory on current device is set"]
    #[doc = ""]
    #[doc = " @param [in] config"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    pub fn hipDeviceSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The current device behavior is changed according the flags passed."]
    #[doc = ""]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " The schedule flags impact how HIP waits for the completion of a command running on a device."]
    #[doc = " hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted the"]
    #[doc = " work until the command completes.  This offers the lowest latency, but will consume a CPU core"]
    #[doc = " and may increase power. hipDeviceScheduleYield        : The HIP runtime will yield the CPU to"]
    #[doc = " system so that other tasks can use it.  This may increase latency to detect the completion but"]
    #[doc = " will consume less power and is friendlier to other tasks in the system."]
    #[doc = " hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield."]
    #[doc = " hipDeviceScheduleAuto         : Use a hueristic to select between Spin and Yield modes.  If the"]
    #[doc = " number of HIP contexts is greater than the number of logical processors in the system, use Spin"]
    #[doc = " scheduling.  Else use Yield scheduling."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " hipDeviceMapHost              : Allow mapping host memory.  On ROCM, this is always allowed and"]
    #[doc = " the flag is ignored. hipDeviceLmemResizeToMax      : @warning ROCm silently ignores this flag."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorSetOnActiveProcess"]
    #[doc = ""]
    #[doc = ""]
    pub fn hipSetDeviceFlags(flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Device which matches hipDeviceProp_t is returned"]
    #[doc = ""]
    #[doc = " @param [out] device ID"]
    #[doc = " @param [in]  device properties pointer"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipChooseDevice(device: *mut ::libc::c_int, prop: *const hipDeviceProp_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the link type and hop count between two devices"]
    #[doc = ""]
    #[doc = " @param [in] device1 Ordinal for device1"]
    #[doc = " @param [in] device2 Ordinal for device2"]
    #[doc = " @param [out] linktype Returns the link type (See hsa_amd_link_info_type_t) between the two devices"]
    #[doc = " @param [out] hopcount Returns the hop count between the two devices"]
    #[doc = ""]
    #[doc = " Queries and returns the HSA link type and the hop count between the two specified devices."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipInvalidDevice, #hipErrorRuntimeOther"]
    pub fn hipExtGetLinkTypeAndHopCount(
        device1: ::libc::c_int,
        device2: ::libc::c_int,
        linktype: *mut u32,
        hopcount: *mut u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call and resets the stored error code to"]
    #[doc = " #hipSuccess"]
    #[doc = ""]
    #[doc = " @returns return code from last HIP called from the active host thread"]
    #[doc = ""]
    #[doc = " Returns the last error that has been returned by any of the runtime calls in the same host"]
    #[doc = " thread, and then resets the saved error to #hipSuccess."]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call."]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " Returns the last error that has been returned by any of the runtime calls in the same host"]
    #[doc = " thread. Unlike hipGetLastError, this function does not reset the saved error code."]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipPeekAtLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return name of the specified error code in text form."]
    #[doc = ""]
    #[doc = " @param hip_error Error code to convert to name."]
    #[doc = " @return const char pointer to the NULL-terminated error name"]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorName(hip_error: hipError_t) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred"]
    #[doc = ""]
    #[doc = " @param hipError Error code to convert to string."]
    #[doc = " @return const char pointer to the NULL-terminated error string"]
    #[doc = ""]
    #[doc = " @warning : on HCC, this function returns the name of the error (same as hipGetErrorName)"]
    #[doc = ""]
    #[doc = " @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorString(hipError: hipError_t) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the"]
    #[doc = " newly created stream."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to"]
    #[doc = " reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on"]
    #[doc = " the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory"]
    #[doc = " used by the stream, applicaiton must call hipStreamDestroy."]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreate(stream: *mut hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Pointer to new stream"]
    #[doc = " @param[in ] flags to control stream creation."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to"]
    #[doc = " reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on"]
    #[doc = " the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory"]
    #[doc = " used by the stream, applicaiton must call hipStreamDestroy. Flags controls behavior of the"]
    #[doc = " stream.  See #hipStreamDefault, #hipStreamNonBlocking."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithFlags(stream: *mut hipStream_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified priority."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Pointer to new stream"]
    #[doc = " @param[in ] flags to control stream creation."]
    #[doc = " @param[in ] priority of the stream. Lower numbers represent higher priorities."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream with the specified priority.  @p stream returns an opaque handle"]
    #[doc = " that can be used to reference the newly created stream in subsequent hipStream* commands.  The"]
    #[doc = " stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope."]
    #[doc = " To release the memory used by the stream, applicaiton must call hipStreamDestroy. Flags controls"]
    #[doc = " behavior of the stream.  See #hipStreamDefault, #hipStreamNonBlocking."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithPriority(
        stream: *mut hipStream_t,
        flags: ::libc::c_uint,
        priority: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns numerical values that correspond to the least and greatest stream priority."]
    #[doc = ""]
    #[doc = " @param[in, out] leastPriority pointer in which value corresponding to least priority is returned."]
    #[doc = " @param[in, out] greatestPriority pointer in which value corresponding to greatest priority is returned."]
    #[doc = ""]
    #[doc = " Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least"]
    #[doc = " and greatest stream priority respectively. Stream priorities follow a convention where lower numbers"]
    #[doc = " imply greater priorities. The range of meaningful stream priorities is given by"]
    #[doc = " [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value"]
    #[doc = " that is outside the the meaningful range as specified by this API, the priority is automatically"]
    #[doc = " clamped to within the valid range."]
    pub fn hipDeviceGetStreamPriorityRange(
        leastPriority: *mut ::libc::c_int,
        greatestPriority: *mut ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys the specified stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the"]
    #[doc = " newly created stream."]
    #[doc = " @return #hipSuccess #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Destroys the specified stream."]
    #[doc = ""]
    #[doc = " If commands are still executing on the specified stream, some may complete execution before the"]
    #[doc = " queue is deleted."]
    #[doc = ""]
    #[doc = " The queue may be destroyed while some commands are still inflight, or may wait for all commands"]
    #[doc = " queued to the stream before destroying it."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamQuery, hipStreamWaitEvent,"]
    #[doc = " hipStreamSynchronize"]
    pub fn hipStreamDestroy(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return #hipSuccess if all of the operations in the specified @p stream have completed, or"]
    #[doc = " #hipErrorNotReady if not."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to query"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This is thread-safe and returns a snapshot of the current state of the queue.  However, if other"]
    #[doc = " host threads are sending work to the stream, the status may change immediately after the function"]
    #[doc = " is called.  It is typically used for debug."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamSynchronize,"]
    #[doc = " hipStreamDestroy"]
    pub fn hipStreamQuery(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Wait for all commands in stream to complete."]
    #[doc = ""]
    #[doc = " @param[in] stream stream identifier."]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This command is host-synchronous : the host will block until the specified stream is empty."]
    #[doc = ""]
    #[doc = " This command follows standard null-stream semantics.  Specifically, specifying the null stream"]
    #[doc = " will cause the command to wait for other streams on the same device to complete all pending"]
    #[doc = " operations."]
    #[doc = ""]
    #[doc = " This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active"]
    #[doc = " or blocking."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamDestroy"]
    #[doc = ""]
    pub fn hipStreamSynchronize(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Make the specified compute stream wait for an event"]
    #[doc = ""]
    #[doc = " @param[in] stream stream to make wait."]
    #[doc = " @param[in] event event to wait on"]
    #[doc = " @param[in] flags control operation [must be 0]"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This function inserts a wait operation into the specified stream."]
    #[doc = " All future work submitted to @p stream will wait until @p event reports completion before"]
    #[doc = " beginning execution."]
    #[doc = ""]
    #[doc = " This function only waits for commands in the current stream to complete.  Notably,, this function"]
    #[doc = " does not impliciy wait for commands in the default stream to complete, even if the specified"]
    #[doc = " stream is created with hipStreamNonBlocking = 0."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamDestroy"]
    pub fn hipStreamWaitEvent(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags associated with this stream."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to be queried"]
    #[doc = " @param[in,out] flags Pointer to an unsigned integer in which the stream's flags are returned"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Return flags associated with this stream in *@p flags."]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetFlags(stream: hipStream_t, flags: *mut ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query the priority of a stream."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to be queried"]
    #[doc = " @param[in,out] priority Pointer to an unsigned integer in which the stream's priority is returned"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Query the priority of a stream. The priority is returned in in priority."]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetPriority(stream: hipStream_t, priority: *mut ::libc::c_int) -> hipError_t;
}
#[doc = " Stream CallBack struct"]
pub type hipStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(stream: hipStream_t, status: hipError_t, userData: *mut ::libc::c_void),
>;
extern "C" {
    #[doc = " @brief Adds a callback to be called on the host after all currently enqueued"]
    #[doc = " items in the stream have completed.  For each"]
    #[doc = " cudaStreamAddCallback call, a callback will be executed exactly once."]
    #[doc = " The callback will block later work in the stream until it is finished."]
    #[doc = " @param[in] stream   - Stream to add callback to"]
    #[doc = " @param[in] callback - The function to call once preceding stream operations are complete"]
    #[doc = " @param[in] userData - User specified data to be passed to the callback function"]
    #[doc = " @param[in] flags    - Reserved for future use, must be 0"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorNotSupported"]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamQuery, hipStreamSynchronize,"]
    #[doc = " hipStreamWaitEvent, hipStreamDestroy, hipStreamCreateWithPriority"]
    #[doc = ""]
    pub fn hipStreamAddCallback(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an event with the specified flags"]
    #[doc = ""]
    #[doc = " @param[in,out] event Returns the newly created event."]
    #[doc = " @param[in] flags     Flags to control event behavior.  Valid values are #hipEventDefault,"]
    #[doc = "#hipEventBlockingSync, #hipEventDisableTiming, #hipEventInterprocess"]
    #[doc = ""]
    #[doc = " #hipEventDefault : Default flag.  The event will use active synchronization and will support"]
    #[doc = "timing.  Blocking synchronization provides lowest possible latency at the expense of dedicating a"]
    #[doc = "CPU to poll on the event."]
    #[doc = " #hipEventBlockingSync : The event will use blocking synchronization : if hipEventSynchronize is"]
    #[doc = "called on this event, the thread will block until the event completes.  This can increase latency"]
    #[doc = "for the synchroniation but can result in lower power and more resources for other CPU threads."]
    #[doc = " #hipEventDisableTiming : Disable recording of timing information.  On ROCM platform, timing"]
    #[doc = "information is always recorded and this flag has no performance benefit."]
    #[doc = ""]
    #[doc = " @warning On HCC platform, hipEventInterprocess support is under development.  Use of this flag"]
    #[doc = "will return an error."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = "#hipErrorLaunchFailure, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventSynchronize, hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreateWithFlags(event: *mut hipEvent_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = "  Create an event"]
    #[doc = ""]
    #[doc = " @param[in,out] event Returns the newly created event."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorLaunchFailure, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = " @see hipEventCreateWithFlags, hipEventRecord, hipEventQuery, hipEventSynchronize,"]
    #[doc = " hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreate(event: *mut hipEvent_t) -> hipError_t;
}
extern "C" {
    pub fn hipEventRecord(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroy the specified event."]
    #[doc = ""]
    #[doc = "  @param[in] event Event to destroy."]
    #[doc = "  @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = "  Releases memory associated with the event.  If the event is recording but has not completed"]
    #[doc = " recording when hipEventDestroy() is called, the function will return immediately and the"]
    #[doc = " completion_future resources will be released later, when the hipDevice is synchronized."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize, hipEventRecord,"]
    #[doc = " hipEventElapsedTime"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    pub fn hipEventDestroy(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Wait for an event to complete."]
    #[doc = ""]
    #[doc = "  This function will block until the event is ready, waiting for all previous work in the stream"]
    #[doc = " specified when event was recorded with hipEventRecord()."]
    #[doc = ""]
    #[doc = "  If hipEventRecord() has not been called on @p event, this function returns immediately."]
    #[doc = ""]
    #[doc = "  TODO-hcc - This function needs to support hipEventBlockingSync parameter."]
    #[doc = ""]
    #[doc = "  @param[in] event Event on which to wait."]
    #[doc = "  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,"]
    #[doc = " #hipErrorInvalidHandle, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = "  @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,"]
    #[doc = " hipEventElapsedTime"]
    pub fn hipEventSynchronize(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the elapsed time between two events."]
    #[doc = ""]
    #[doc = " @param[out] ms : Return time between start and stop in ms."]
    #[doc = " @param[in]   start : Start event."]
    #[doc = " @param[in]   stop  : Stop event."]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotReady, #hipErrorInvalidHandle,"]
    #[doc = " #hipErrorNotInitialized, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = " Computes the elapsed time between two events. Time is computed in ms, with"]
    #[doc = " a resolution of approximately 1 us."]
    #[doc = ""]
    #[doc = " Events which are recorded in a NULL stream will block until all commands"]
    #[doc = " on all other streams complete execution, and then record the timestamp."]
    #[doc = ""]
    #[doc = " Events which are recorded in a non-NULL stream will record their timestamp"]
    #[doc = " when they reach the head of the specified stream, after all previous"]
    #[doc = " commands in that stream have completed executing.  Thus the time that"]
    #[doc = " the event recorded may be significantly after the host calls hipEventRecord()."]
    #[doc = ""]
    #[doc = " If hipEventRecord() has not been called on either event, then #hipErrorInvalidHandle is"]
    #[doc = " returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been"]
    #[doc = " recorded on one or both events (that is, hipEventQuery() would return #hipErrorNotReady on at"]
    #[doc = " least one of the events), then #hipErrorNotReady is returned."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,"]
    #[doc = " hipEventSynchronize"]
    pub fn hipEventElapsedTime(ms: *mut f32, start: hipEvent_t, stop: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query event status"]
    #[doc = ""]
    #[doc = " @param[in] event Event to query."]
    #[doc = " @returns #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorNotInitialized, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = " Query the status of the specified event.  This function will return #hipErrorNotReady if all"]
    #[doc = " commands in the appropriate stream (specified to hipEventRecord()) have completed.  If that work"]
    #[doc = " has not completed, or if hipEventRecord() was not called on the event, then #hipSuccess is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventRecord, hipEventDestroy,"]
    #[doc = " hipEventSynchronize, hipEventElapsedTime"]
    pub fn hipEventQuery(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return attributes for the specified pointer"]
    #[doc = ""]
    #[doc = "  @param[out] attributes for the specified pointer"]
    #[doc = "  @param[in]  pointer to get attributes for"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipGetDeviceCount, hipGetDevice, hipSetDevice, hipChooseDevice"]
    pub fn hipPointerGetAttributes(
        attributes: *mut hipPointerAttribute_t,
        ptr: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)"]
    #[doc = ""]
    #[doc = "  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,"]
    #[doc = " hipHostFree, hipHostMalloc"]
    pub fn hipMalloc(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)"]
    #[doc = ""]
    #[doc = "  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,"]
    #[doc = " hipHostFree, hipHostMalloc"]
    pub fn hipExtMallocWithFlags(
        ptr: *mut *mut ::libc::c_void,
        sizeBytes: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipMallocHost(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipMemAllocHost(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of host memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipSetDeviceFlags, hipHostFree"]
    pub fn hipHostMalloc(
        ptr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocates memory that will be automatically managed by the Unified Memory system."]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated managed memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags must be either hipMemAttachGlobal/hipMemAttachHost"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    pub fn hipMallocManaged(
        devPtr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of host memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipHostAlloc(
        ptr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Get Device pointer from Host Pointer allocated through hipHostMalloc"]
    #[doc = ""]
    #[doc = "  @param[out] dstPtr Device Pointer mapped to passed host pointer"]
    #[doc = "  @param[in]  hstPtr Host Pointer allocated through hipHostMalloc"]
    #[doc = "  @param[in]  flags Flags to be passed for extension"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipSetDeviceFlags, hipHostMalloc"]
    pub fn hipHostGetDevicePointer(
        devPtr: *mut *mut ::libc::c_void,
        hstPtr: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return flags associated with host pointer"]
    #[doc = ""]
    #[doc = "  @param[out] flagsPtr Memory location to store flags"]
    #[doc = "  @param[in]  hostPtr Host Pointer allocated through hipHostMalloc"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipHostMalloc"]
    pub fn hipHostGetFlags(
        flagsPtr: *mut ::libc::c_uint,
        hostPtr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Register host memory so it can be accessed from the current device."]
    #[doc = ""]
    #[doc = "  @param[out] hostPtr Pointer to host memory to be registered."]
    #[doc = "  @param[in] sizeBytes size of the host memory"]
    #[doc = "  @param[in] flags.  See below."]
    #[doc = ""]
    #[doc = "  Flags:"]
    #[doc = "  - #hipHostRegisterDefault   Memory is Mapped and Portable"]
    #[doc = "  - #hipHostRegisterPortable  Memory is considered registered by all contexts.  HIP only supports"]
    #[doc = " one context so this is always assumed true."]
    #[doc = "  - #hipHostRegisterMapped    Map the allocation into the address space for the current device."]
    #[doc = " The device pointer can be obtained with #hipHostGetDevicePointer."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  After registering the memory, use #hipHostGetDevicePointer to obtain the mapped device pointer."]
    #[doc = "  On many systems, the mapped device pointer will have a different value than the mapped host"]
    #[doc = " pointer.  Applications must use the device pointer in device code, and the host pointer in device"]
    #[doc = " code."]
    #[doc = ""]
    #[doc = "  On some systems, registered memory is pinned.  On some systems, registered memory may not be"]
    #[doc = " actually be pinned but uses OS or hardware facilities to all GPU access to the host memory."]
    #[doc = ""]
    #[doc = "  Developers are strongly encouraged to register memory blocks which are aligned to the host"]
    #[doc = " cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction)."]
    #[doc = ""]
    #[doc = "  If registering non-aligned pointers, the application must take care when register pointers from"]
    #[doc = " the same cache line on different devices.  HIP's coarse-grained synchronization model does not"]
    #[doc = " guarantee correct results if different devices write to different parts of the same cache block -"]
    #[doc = " typically one of the writes will \"win\" and overwrite data from the other registered memory"]
    #[doc = " region."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipHostUnregister, hipHostGetFlags, hipHostGetDevicePointer"]
    pub fn hipHostRegister(
        hostPtr: *mut ::libc::c_void,
        sizeBytes: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Un-register host pointer"]
    #[doc = ""]
    #[doc = "  @param[in] hostPtr Host pointer previously registered with #hipHostRegister"]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipHostRegister"]
    pub fn hipHostUnregister(hostPtr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory"]
    #[doc = "  Padding may occur to ensure alighnment requirements are met for the given row"]
    #[doc = "  The change in width size due to padding will be returned in *pitch."]
    #[doc = "  Currently the alignment is set to 128 bytes"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated device memory"]
    #[doc = "  @param[out] pitch Pitch for allocation (in bytes)"]
    #[doc = "  @param[in]  width Requested pitched allocation width (in bytes)"]
    #[doc = "  @param[in]  height Requested pitched allocation height"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMallocPitch(
        ptr: *mut *mut ::libc::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory"]
    #[doc = "  Padding may occur to ensure alighnment requirements are met for the given row"]
    #[doc = "  The change in width size due to padding will be returned in *pitch."]
    #[doc = "  Currently the alignment is set to 128 bytes"]
    #[doc = ""]
    #[doc = "  @param[out] dptr Pointer to the allocated device memory"]
    #[doc = "  @param[out] pitch Pitch for allocation (in bytes)"]
    #[doc = "  @param[in]  width Requested pitched allocation width (in bytes)"]
    #[doc = "  @param[in]  height Requested pitched allocation height"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = "  The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array."]
    #[doc = "  Given the row and column of an array element of type T, the address is computed as:"]
    #[doc = "  T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;"]
    #[doc = ""]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMemAllocPitch(
        dptr: *mut hipDeviceptr_t,
        pitch: *mut usize,
        widthInBytes: usize,
        height: usize,
        elementSizeBytes: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip memory allocation API."]
    #[doc = "  This API performs an implicit hipDeviceSynchronize() call."]
    #[doc = "  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess"]
    #[doc = "  @return #hipErrorInvalidDevicePointer (if pointer is invalid, including host pointers allocated"]
    #[doc = " with hipHostMalloc)"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipFree(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API.  [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess,"]
    #[doc = "          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with"]
    #[doc = "hipMalloc)"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostFree() instead"]
    pub fn hipFreeHost(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API"]
    #[doc = "  This API performs an implicit hipDeviceSynchronize() call."]
    #[doc = "  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess,"]
    #[doc = "          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with"]
    #[doc = " hipMalloc)"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipHostFree(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst."]
    #[doc = ""]
    #[doc = "  It supports memory from host to device,"]
    #[doc = "  device to host, device to device and host to host"]
    #[doc = "  The src and dst must not overlap."]
    #[doc = ""]
    #[doc = "  For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice)."]
    #[doc = "  For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the"]
    #[doc = " device where the src data is physically located. For optimal peer-to-peer copies, the copy device"]
    #[doc = " must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy"]
    #[doc = " agent as the current device and src/dest as the peerDevice argument.  if this is not done, the"]
    #[doc = " hipMemcpy will still work, but will perform the copy using a staging buffer on the host."]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]  src Data being copy from"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @param[in]  copyType Memory copy type"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknowni"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpy(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyWithStream(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoD(
        dst: hipDeviceptr_t,
        src: *mut ::libc::c_void,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoH(
        dst: *mut ::libc::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoD(dst: hipDeviceptr_t, src: hipDeviceptr_t, sizeBytes: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoDAsync(
        dst: hipDeviceptr_t,
        src: *mut ::libc::c_void,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoHAsync(
        dst: *mut ::libc::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoDAsync(
        dst: hipDeviceptr_t,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief returns device memory pointer and size of the kernel present in the module with symbol @p"]
    #[doc = " name"]
    #[doc = ""]
    #[doc = " @param [out] dptr"]
    #[doc = " @param [out] bytes"]
    #[doc = " @param [in] hmod"]
    #[doc = " @param [in] name"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorNotInitialized"]
    pub fn hipModuleGetGlobal(
        arg1: *mut *mut ::libc::c_void,
        arg2: *mut usize,
        arg3: hipModule_t,
        arg4: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst asynchronously."]
    #[doc = ""]
    #[doc = "  @warning If host or dest are not pinned, the memory copy will be performed synchronously.  For"]
    #[doc = " best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously."]
    #[doc = ""]
    #[doc = "  @warning on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies."]
    #[doc = "  For hipMemcpy, the copy is always performed by the device associated with the specified stream."]
    #[doc = ""]
    #[doc = "  For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a"]
    #[doc = " attached to the device where the src data is physically located. For optimal peer-to-peer copies,"]
    #[doc = " the copy device must be able to access the src and dst pointers (by calling"]
    #[doc = " hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice"]
    #[doc = " argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a"]
    #[doc = " staging buffer on the host."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being copy to"]
    #[doc = "  @param[in]  src Data being copy from"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @param[in]  accelerator_view Accelerator view which the copy is being enqueued"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknown"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpy2DFromArray, hipMemcpyArrayToArray, hipMemcpy2DArrayToArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyFromSymbol, hipMemcpy2DAsync, hipMemcpyToArrayAsync, hipMemcpy2DToArrayAsync,"]
    #[doc = " hipMemcpyFromArrayAsync, hipMemcpy2DFromArrayAsync, hipMemcpyToSymbolAsync,"]
    #[doc = " hipMemcpyFromSymbolAsync"]
    pub fn hipMemcpyAsync(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemset(
        dst: *mut ::libc::c_void,
        value: ::libc::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8(dest: hipDeviceptr_t, value: ::libc::c_uchar, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = " hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8Async(
        dest: hipDeviceptr_t,
        value: ::libc::c_uchar,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " short value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16(dest: hipDeviceptr_t, value: ::libc::c_ushort, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " short value value."]
    #[doc = ""]
    #[doc = " hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16Async(
        dest: hipDeviceptr_t,
        value: ::libc::c_ushort,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dest with the constant integer"]
    #[doc = " value for specified number of times."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD32(dest: hipDeviceptr_t, value: ::libc::c_int, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  value - Value to set for each byte of specified memory"]
    #[doc = "  @param[in]  sizeBytes - Size in bytes to set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemsetAsync(
        dst: *mut ::libc::c_void,
        value: ::libc::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dev with the constant integer"]
    #[doc = " value for specified number of times."]
    #[doc = ""]
    #[doc = "  hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  value - Value to set for each byte of specified memory"]
    #[doc = "  @param[in]  count - number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemsetD32Async(
        dst: hipDeviceptr_t,
        value: ::libc::c_int,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dst with the constant value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  pitch - data size in bytes"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  width"]
    #[doc = "  @param[in]  height"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset2D(
        dst: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by dst with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in]  dst Pointer to device memory"]
    #[doc = "  @param[in]  pitch - data size in bytes"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  width"]
    #[doc = "  @param[in]  height"]
    #[doc = "  @param[in]  stream"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset2DAsync(
        dst: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in] pitchedDevPtr"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  extent"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset3D(
        pitchedDevPtr: hipPitchedPtr,
        value: ::libc::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in] pitchedDevPtr"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  extent"]
    #[doc = "  @param[in]  stream"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset3DAsync(
        pitchedDevPtr: hipPitchedPtr,
        value: ::libc::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query memory info."]
    #[doc = " Return snapshot of free memory, and total allocatable memory on the device."]
    #[doc = ""]
    #[doc = " Returns in *free a snapshot of the current free memory."]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = " @warning On HCC, the free memory only accounts for memory allocated by this process and may be"]
    #[doc = "optimistic."]
    pub fn hipMemGetInfo(free: *mut usize, total: *mut usize) -> hipError_t;
}
extern "C" {
    pub fn hipMemPtrGetInfo(ptr: *mut ::libc::c_void, size: *mut usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device."]
    #[doc = ""]
    #[doc = "  @param[out]  array  Pointer to allocated array in device memory"]
    #[doc = "  @param[in]   desc   Requested channel format"]
    #[doc = "  @param[in]   width  Requested array allocation width"]
    #[doc = "  @param[in]   height Requested array allocation height"]
    #[doc = "  @param[in]   flags  Requested properties of allocated array"]
    #[doc = "  @return      #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMallocArray(
        array: *mut *mut hipArray,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipArrayCreate(
        pHandle: *mut *mut hipArray,
        pAllocateArray: *const HIP_ARRAY_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipArray3DCreate(
        array: *mut *mut hipArray,
        pAllocateArray: *const HIP_ARRAY3D_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMalloc3D(pitchedDevPtr: *mut hipPitchedPtr, extent: hipExtent) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Frees an array on the device."]
    #[doc = ""]
    #[doc = "  @param[in]  array  Pointer to array to free"]
    #[doc = "  @return     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipHostMalloc, hipHostFree"]
    pub fn hipFreeArray(array: *mut hipArray) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees a mipmapped array on the device"]
    #[doc = ""]
    #[doc = " @param[in] mipmappedArray - Pointer to mipmapped array to free"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipFreeMipmappedArray(mipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device."]
    #[doc = ""]
    #[doc = "  @param[out]  array  Pointer to allocated array in device memory"]
    #[doc = "  @param[in]   desc   Requested channel format"]
    #[doc = "  @param[in]   extent Requested array allocation width, height and depth"]
    #[doc = "  @param[in]   flags  Requested properties of allocated array"]
    #[doc = "  @return      #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMalloc3DArray(
        array: *mut *mut hipArray,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocate a mipmapped array on the device"]
    #[doc = ""]
    #[doc = " @param[out] mipmappedArray  - Pointer to allocated mipmapped array in device memory"]
    #[doc = " @param[in]  desc            - Requested channel format"]
    #[doc = " @param[in]  extent          - Requested allocation size (width field in elements)"]
    #[doc = " @param[in]  numLevels       - Number of mipmap levels to allocate"]
    #[doc = " @param[in]  flags           - Flags for extensions"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation"]
    pub fn hipMallocMipmappedArray(
        mipmappedArray: *mut hipMipmappedArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        numLevels: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a mipmap level of a HIP mipmapped array"]
    #[doc = ""]
    #[doc = " @param[out] levelArray     - Returned mipmap level HIP array"]
    #[doc = " @param[in]  mipmappedArray - HIP mipmapped array"]
    #[doc = " @param[in]  level          - Mipmap level"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipGetMipmappedArrayLevel(
        levelArray: *mut hipArray_t,
        mipmappedArray: hipMipmappedArray_const_t,
        level: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2D(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays."]
    #[doc = "  @param[in]   pCopy Parameters for the memory copy"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2D(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays."]
    #[doc = "  @param[in]   pCopy Parameters for the memory copy"]
    #[doc = "  @param[in]   stream Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2DAsync(pCopy: *const hip_Memcpy2D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @param[in]   stream Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DAsync(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DToArray(
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyToArray(
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   srcArray  Source memory address"]
    #[doc = "  @param[in]   woffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   count     Size in bytes to copy"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyFromArray(
        dst: *mut ::libc::c_void,
        srcArray: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   dpitch    Pitch of destination memory"]
    #[doc = "  @param[in]   src       Source memory address"]
    #[doc = "  @param[in]   wOffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   width     Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height    Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArray(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   dpitch    Pitch of destination memory"]
    #[doc = "  @param[in]   src       Source memory address"]
    #[doc = "  @param[in]   wOffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   width     Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height    Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @param[in]   stream    Accelerator view which the copy is being enqueued"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArrayAsync(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   srcArray  Source array"]
    #[doc = "  @param[in]   srcoffset Offset in bytes of source array"]
    #[doc = "  @param[in]   count     Size of memory copy in bytes"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyAtoH(
        dst: *mut ::libc::c_void,
        srcArray: *mut hipArray,
        srcOffset: usize,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dstArray   Destination memory address"]
    #[doc = "  @param[in]   dstOffset  Offset in bytes of destination array"]
    #[doc = "  @param[in]   srcHost    Source host pointer"]
    #[doc = "  @param[in]   count      Size of memory copy in bytes"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyHtoA(
        dstArray: *mut hipArray,
        dstOffset: usize,
        srcHost: *const ::libc::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   p   3D memory copy parameters"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy3D(p: *const hipMemcpy3DParms) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   p        3D memory copy parameters"]
    #[doc = "  @param[in]   stream   Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy3DAsync(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   pCopy   3D memory copy parameters"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipDrvMemcpy3D(pCopy: *const HIP_MEMCPY3D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   pCopy    3D memory copy parameters"]
    #[doc = "  @param[in]   stream   Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipDrvMemcpy3DAsync(pCopy: *const HIP_MEMCPY3D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Determine if a device can access a peer's memory."]
    #[doc = ""]
    #[doc = " @param [out] canAccessPeer Returns the peer access capability (0 or 1)"]
    #[doc = " @param [in] device - device from where memory may be accessed."]
    #[doc = " @param [in] peerDevice - device where memory is physically located"]
    #[doc = ""]
    #[doc = " Returns \"1\" in @p canAccessPeer if the specified @p device is capable"]
    #[doc = " of directly accessing memory physically located on peerDevice , or \"0\" if not."]
    #[doc = ""]
    #[doc = " Returns \"0\" in @p canAccessPeer if deviceId == peerDeviceId, and both are valid devices : a"]
    #[doc = " device is not a peer of itself."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess,"]
    #[doc = " @returns #hipErrorInvalidDevice if deviceId or peerDeviceId are not valid devices"]
    pub fn hipDeviceCanAccessPeer(
        canAccessPeer: *mut ::libc::c_int,
        deviceId: ::libc::c_int,
        peerDeviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enable direct access from current device's virtual address space to memory allocations"]
    #[doc = " physically located on a peer device."]
    #[doc = ""]
    #[doc = " Memory which already allocated on peer device will be mapped into the address space of the"]
    #[doc = " current device.  In addition, all future memory allocations on peerDeviceId will be mapped into"]
    #[doc = " the address space of the current device when the memory is allocated. The peer memory remains"]
    #[doc = " accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] peerDeviceId"]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " Returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,"]
    #[doc = " @returns #hipErrorPeerAccessAlreadyEnabled if peer access is already enabled for this device."]
    pub fn hipDeviceEnablePeerAccess(
        peerDeviceId: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current device's virtual address space to memory allocations"]
    #[doc = " physically located on a peer device."]
    #[doc = ""]
    #[doc = " Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been"]
    #[doc = " enabled from the current device."]
    #[doc = ""]
    #[doc = " @param [in] peerDeviceId"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    pub fn hipDeviceDisablePeerAccess(peerDeviceId: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get information on memory allocations."]
    #[doc = ""]
    #[doc = " @param [out] pbase - BAse pointer address"]
    #[doc = " @param [out] psize - Size of allocation"]
    #[doc = " @param [in]  dptr- Device Pointer"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevicePointer"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipMemGetAddressRange(
        pbase: *mut hipDeviceptr_t,
        psize: *mut usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device."]
    #[doc = ""]
    #[doc = " @param [out] dst - Destination device pointer."]
    #[doc = " @param [in] dstDeviceId - Destination device"]
    #[doc = " @param [in] src - Source device pointer"]
    #[doc = " @param [in] srcDeviceId - Source device"]
    #[doc = " @param [in] sizeBytes - Size of memory copy in bytes"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeer(
        dst: *mut ::libc::c_void,
        dstDeviceId: ::libc::c_int,
        src: *const ::libc::c_void,
        srcDeviceId: ::libc::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device."]
    #[doc = ""]
    #[doc = " @param [out] dst - Destination device pointer."]
    #[doc = " @param [in] dstDevice - Destination device"]
    #[doc = " @param [in] src - Source device pointer"]
    #[doc = " @param [in] srcDevice - Source device"]
    #[doc = " @param [in] sizeBytes - Size of memory copy in bytes"]
    #[doc = " @param [in] stream - Stream identifier"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeerAsync(
        dst: *mut ::libc::c_void,
        dstDeviceId: ::libc::c_int,
        src: *const ::libc::c_void,
        srcDevice: ::libc::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Explicitly initializes the HIP runtime."]
    #[doc = ""]
    #[doc = " Most HIP APIs implicitly initialize the HIP runtime."]
    #[doc = " This API provides control over the timing of the initialization."]
    pub fn hipInit(flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create a context and set it as current/ default context"]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = " @param [in] flags"]
    #[doc = " @param [in] associated device handle"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxPushCurrent,"]
    #[doc = " hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxCreate(
        ctx: *mut hipCtx_t,
        flags: ::libc::c_uint,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a HIP context."]
    #[doc = ""]
    #[doc = " @param [in] ctx Context to destroy"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,hipCtxSetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxDestroy(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Pop the current/default context and return the popped context."]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxSetCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxPopCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Push the context to be set as current/ default context"]
    #[doc = ""]
    #[doc = " @param [in] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxPushCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the passed context as current/default"]
    #[doc = ""]
    #[doc = " @param [in] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxSetCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the current/ default context"]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the device associated with current/default context"]
    #[doc = ""]
    #[doc = " @param [out] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize"]
    pub fn hipCtxGetDevice(device: *mut hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP api version."]
    #[doc = ""]
    #[doc = " @param [in]  ctx Context to check"]
    #[doc = " @param [out] apiVersion"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning The HIP feature set does not correspond to an exact CUDA SDK api revision."]
    #[doc = " This function always set *apiVersion to 4 as an approximation though HIP supports"]
    #[doc = " some features which were introduced in later CUDA SDK revisions."]
    #[doc = " HIP apps code should not rely on the api revision number here and should"]
    #[doc = " use arch feature flags to test device capabilities or conditional compilation."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetApiVersion(ctx: hipCtx_t, apiVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [out] cacheConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition."]
    #[doc = ""]
    #[doc = " @param [in] cacheConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Shared memory bank configuration."]
    #[doc = ""]
    #[doc = " @param [in] sharedMemoryConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Shared memory bank configuration."]
    #[doc = ""]
    #[doc = " @param [out] sharedMemoryConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Blocks until the default context has completed all preceding requested tasks."]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning This function waits for all streams on the default context to complete execution, and"]
    #[doc = " then returns."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxGetDevice"]
    pub fn hipCtxSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags used for creating default context."]
    #[doc = ""]
    #[doc = " @param [out] flags"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetFlags(flags: *mut ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enables direct access to memory allocations in a peer context."]
    #[doc = ""]
    #[doc = " Memory which already allocated on peer device will be mapped into the address space of the"]
    #[doc = " current device.  In addition, all future memory allocations on peerDeviceId will be mapped into"]
    #[doc = " the address space of the current device when the memory is allocated. The peer memory remains"]
    #[doc = " accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] peerCtx"]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorPeerAccessAlreadyEnabled"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning PeerToPeer support is experimental."]
    pub fn hipCtxEnablePeerAccess(peerCtx: hipCtx_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current context's virtual address space to memory allocations"]
    #[doc = " physically located on a peer context.Disables direct access to memory allocations in a peer"]
    #[doc = " context and unregisters any registered allocations."]
    #[doc = ""]
    #[doc = " Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been"]
    #[doc = " enabled from the current device."]
    #[doc = ""]
    #[doc = " @param [in] peerCtx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning PeerToPeer support is experimental."]
    pub fn hipCtxDisablePeerAccess(peerCtx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the state of the primary context."]
    #[doc = ""]
    #[doc = " @param [in] Device to get primary context flags for"]
    #[doc = " @param [out] Pointer to store flags"]
    #[doc = " @param [out] Pointer to store context state; 0 = inactive, 1 = active"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxGetState(
        dev: hipDevice_t,
        flags: *mut ::libc::c_uint,
        active: *mut ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [in] Device which primary context is released"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning This function return #hipSuccess though doesn't release the primaryCtx by design on"]
    #[doc = " HIP/HCC path."]
    pub fn hipDevicePrimaryCtxRelease(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [out] Returned context handle of the new context"]
    #[doc = " @param [in] Device which primary context is released"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxRetain(pctx: *mut hipCtx_t, dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Resets the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [in] Device which primary context is reset"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxReset(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set flags for the primary context."]
    #[doc = ""]
    #[doc = " @param [in] Device for which the primary context flags are set"]
    #[doc = " @param [in] New flags for the device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorContextAlreadyInUse"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxSetFlags(dev: hipDevice_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device"]
    #[doc = " @param [out] device"]
    #[doc = " @param [in] ordinal"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGet(device: *mut hipDevice_t, ordinal: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the compute capability of the device"]
    #[doc = " @param [out] major"]
    #[doc = " @param [out] minor"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceComputeCapability(
        major: *mut ::libc::c_int,
        minor: *mut ::libc::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns an identifer string for the device."]
    #[doc = " @param [out] name"]
    #[doc = " @param [in] len"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGetName(
        name: *mut ::libc::c_char,
        len: ::libc::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a PCI Bus Id string for the device, overloaded to take int device ID."]
    #[doc = " @param [out] pciBusId"]
    #[doc = " @param [in] len"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGetPCIBusId(
        pciBusId: *mut ::libc::c_char,
        len: ::libc::c_int,
        device: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device."]
    #[doc = " @param [out] device handle"]
    #[doc = " @param [in] PCI Bus ID"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetByPCIBusId(
        device: *mut ::libc::c_int,
        pciBusId: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the total amount of memory on the device."]
    #[doc = " @param [out] bytes"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceTotalMem(bytes: *mut usize, device: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP driver version."]
    #[doc = ""]
    #[doc = " @param [out] driverVersion"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidValue"]
    #[doc = ""]
    #[doc = " @warning The HIP feature set does not correspond to an exact CUDA SDK driver revision."]
    #[doc = " This function always set *driverVersion to 4 as an approximation though HIP supports"]
    #[doc = " some features which were introduced in later CUDA SDK revisions."]
    #[doc = " HIP apps code should not rely on the driver revision number here and should"]
    #[doc = " use arch feature flags to test device capabilities or conditional compilation."]
    #[doc = ""]
    #[doc = " @see hipRuntimeGetVersion"]
    pub fn hipDriverGetVersion(driverVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP Runtime version."]
    #[doc = ""]
    #[doc = " @param [out] runtimeVersion"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidValue"]
    #[doc = ""]
    #[doc = " @warning On HIP/HCC path this function returns HIP runtime patch version however on"]
    #[doc = " HIP/NVCC path this function return CUDA runtime version."]
    #[doc = ""]
    #[doc = " @see hipDriverGetVersion"]
    pub fn hipRuntimeGetVersion(runtimeVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Loads code object from file into a hipModule_t"]
    #[doc = ""]
    #[doc = " @param [in] fname"]
    #[doc = " @param [out] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorFileNotFound,"]
    #[doc = " hipErrorOutOfMemory, hipErrorSharedObjectInitFailed, hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = ""]
    pub fn hipModuleLoad(module: *mut hipModule_t, fname: *const ::libc::c_char) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees the module"]
    #[doc = ""]
    #[doc = " @param [in] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidValue"]
    #[doc = " module is freed and the code objects associated with it are destroyed"]
    #[doc = ""]
    pub fn hipModuleUnload(module: hipModule_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Function with kname will be extracted if present in module"]
    #[doc = ""]
    #[doc = " @param [in] module"]
    #[doc = " @param [in] kname"]
    #[doc = " @param [out] function"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorNotInitialized,"]
    #[doc = " hipErrorNotFound,"]
    pub fn hipModuleGetFunction(
        function: *mut hipFunction_t,
        module: hipModule_t,
        kname: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out attributes for a given function."]
    #[doc = ""]
    #[doc = " @param [out] attr"]
    #[doc = " @param [in] func"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttributes(
        attr: *mut hipFuncAttributes,
        func: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out a specific attribute for a given function."]
    #[doc = ""]
    #[doc = " @param [out] value"]
    #[doc = " @param [in]  attrib"]
    #[doc = " @param [in]  hfunc"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttribute(
        value: *mut ::libc::c_int,
        attrib: hipFunction_attribute,
        hfunc: hipFunction_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipModuleGetTexRef(
        texRef: *mut *mut textureReference,
        hmod: hipModule_t,
        name: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that"]
    #[doc = " location."]
    #[doc = ""]
    #[doc = " @param [in] image"]
    #[doc = " @param [out] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadData(module: *mut hipModule_t, image: *const ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that"]
    #[doc = " location. Options are not used. hipModuleLoadData is called."]
    #[doc = ""]
    #[doc = " @param [in] image"]
    #[doc = " @param [out] module"]
    #[doc = " @param [in] number of options"]
    #[doc = " @param [in] options for JIT"]
    #[doc = " @param [in] option values for JIT"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadDataEx(
        module: *mut hipModule_t,
        image: *const ::libc::c_void,
        numOptions: ::libc::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed"]
    #[doc = " to kernelparams or extra"]
    #[doc = ""]
    #[doc = " @param [in] f         Kernel to launch."]
    #[doc = " @param [in] gridDimX  X grid dimension specified as multiple of blockDimX."]
    #[doc = " @param [in] gridDimY  Y grid dimension specified as multiple of blockDimY."]
    #[doc = " @param [in] gridDimZ  Z grid dimension specified as multiple of blockDimZ."]
    #[doc = " @param [in] blockDimX X block dimensions specified in work-items"]
    #[doc = " @param [in] blockDimY Y grid dimension specified in work-items"]
    #[doc = " @param [in] blockDimZ Z grid dimension specified in work-items"]
    #[doc = " @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = " kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = " @param [in] kernelParams"]
    #[doc = " @param [in] extra     Pointer to kernel arguments.   These are passed directly to the kernel and"]
    #[doc = " must be in the memory layout and alignment expected by the kernel."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @warning kernellParams argument is not yet implemented in HIP. Please use extra instead. Please"]
    #[doc = " refer to hip_porting_driver_api.md for sample usage."]
    pub fn hipModuleLaunchKernel(
        f: hipFunction_t,
        gridDimX: ::libc::c_uint,
        gridDimY: ::libc::c_uint,
        gridDimZ: ::libc::c_uint,
        blockDimX: ::libc::c_uint,
        blockDimY: ::libc::c_uint,
        blockDimZ: ::libc::c_uint,
        sharedMemBytes: ::libc::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::libc::c_void,
        extra: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (only default supported)"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSizeWithFlags(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  func             Kernel function (hipFunction) for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::libc::c_int,
        f: hipFunction_t,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  f                Kernel function(hipFunction_t) for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (only default supported)"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::libc::c_int,
        f: hipFunction_t,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  func             Kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  f                Kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (currently ignored)"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices and guarantees all specified kernels are dispatched"]
    #[doc = " on respective streams before enqueuing any other work on the specified streams from any other threads"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] hipLaunchParams          List of launch parameters, one per device."]
    #[doc = " @param [in] numDevices               Size of the launchParamsList array."]
    #[doc = " @param [in] flags                    Flags to control launch behavior."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    pub fn hipExtLaunchMultiKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Start recording of profiling information"]
    #[doc = " When using this API, start the profiler with profiling disabled.  (--startdisabled)"]
    #[doc = " @warning : hipProfilerStart API is under development."]
    pub fn hipProfilerStart() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Stop recording of profiling information."]
    #[doc = " When using this API, start the profiler with profiling disabled.  (--startdisabled)"]
    #[doc = " @warning : hipProfilerStop API is under development."]
    pub fn hipProfilerStop() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets an interprocess memory handle for an existing device memory"]
    #[doc = "          allocation"]
    #[doc = ""]
    #[doc = " Takes a pointer to the base of an existing device memory allocation created"]
    #[doc = " with hipMalloc and exports it for use in another process. This is a"]
    #[doc = " lightweight operation and may be called multiple times on an allocation"]
    #[doc = " without adverse effects."]
    #[doc = ""]
    #[doc = " If a region of memory is freed with hipFree and a subsequent call"]
    #[doc = " to hipMalloc returns memory with the same device address,"]
    #[doc = " hipIpcGetMemHandle will return a unique handle for the"]
    #[doc = " new memory."]
    #[doc = ""]
    #[doc = " @param handle - Pointer to user allocated hipIpcMemHandle to return"]
    #[doc = "                    the handle in."]
    #[doc = " @param devPtr - Base pointer to previously allocated device memory"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = " hipErrorOutOfMemory,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = ""]
    pub fn hipIpcGetMemHandle(
        handle: *mut hipIpcMemHandle_t,
        devPtr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Opens an interprocess memory handle exported from another process"]
    #[doc = "          and returns a device pointer usable in the local process."]
    #[doc = ""]
    #[doc = " Maps memory exported from another process with hipIpcGetMemHandle into"]
    #[doc = " the current device address space. For contexts on different devices"]
    #[doc = " hipIpcOpenMemHandle can attempt to enable peer access between the"]
    #[doc = " devices as if the user called hipDeviceEnablePeerAccess. This behavior is"]
    #[doc = " controlled by the hipIpcMemLazyEnablePeerAccess flag."]
    #[doc = " hipDeviceCanAccessPeer can determine if a mapping is possible."]
    #[doc = ""]
    #[doc = " Contexts that may open hipIpcMemHandles are restricted in the following way."]
    #[doc = " hipIpcMemHandles from each device in a given process may only be opened"]
    #[doc = " by one context per device per other process."]
    #[doc = ""]
    #[doc = " Memory returned from hipIpcOpenMemHandle must be freed with"]
    #[doc = " hipIpcCloseMemHandle."]
    #[doc = ""]
    #[doc = " Calling hipFree on an exported memory region before calling"]
    #[doc = " hipIpcCloseMemHandle in the importing context will result in undefined"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param devPtr - Returned device pointer"]
    #[doc = " @param handle - hipIpcMemHandle to open"]
    #[doc = " @param flags  - Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = " hipErrorTooManyPeers"]
    #[doc = ""]
    #[doc = " @note No guarantees are made about the address returned in @p *devPtr."]
    #[doc = " In particular, multiple processes may not receive the same address for the same @p handle."]
    #[doc = ""]
    pub fn hipIpcOpenMemHandle(
        devPtr: *mut *mut ::libc::c_void,
        handle: hipIpcMemHandle_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Close memory mapped with hipIpcOpenMemHandle"]
    #[doc = ""]
    #[doc = " Unmaps memory returnd by hipIpcOpenMemHandle. The original allocation"]
    #[doc = " in the exporting process as well as imported mappings in other processes"]
    #[doc = " will be unaffected."]
    #[doc = ""]
    #[doc = " Any resources used to enable peer access will be freed if this is the"]
    #[doc = " last mapping using them."]
    #[doc = ""]
    #[doc = " @param devPtr - Device pointer returned by hipIpcOpenMemHandle"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = ""]
    pub fn hipIpcCloseMemHandle(devPtr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    pub fn hipIpcGetEventHandle(handle: *mut hipIpcEventHandle_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    pub fn hipIpcOpenEventHandle(event: *mut hipEvent_t, handle: hipIpcEventHandle_t)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Configure a kernel launch."]
    #[doc = ""]
    #[doc = " @param [in] gridDim   grid dimension specified as multiple of blockDim."]
    #[doc = " @param [in] blockDim  block dimensions specified in work-items"]
    #[doc = " @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = " kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn hipConfigureCall(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set a kernel argument."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @param [in] arg    Pointer the argument in host memory."]
    #[doc = " @param [in] size   Size of the argument."]
    #[doc = " @param [in] offset Offset of the argument on the argument stack."]
    #[doc = ""]
    pub fn hipSetupArgument(arg: *const ::libc::c_void, size: usize, offset: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launch a kernel."]
    #[doc = ""]
    #[doc = " @param [in] func Kernel to launch."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn hipLaunchByPtr(func: *const ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Push configuration of a kernel launch."]
    #[doc = ""]
    #[doc = " @param [in] gridDim   grid dimension specified as multiple of blockDim."]
    #[doc = " @param [in] blockDim  block dimensions specified in work-items"]
    #[doc = " @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = " kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn __hipPushCallConfiguration(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Pop configuration of a kernel launch."]
    #[doc = ""]
    #[doc = " @param [out] gridDim   grid dimension specified as multiple of blockDim."]
    #[doc = " @param [out] blockDim  block dimensions specified in work-items"]
    #[doc = " @param [out] sharedMem Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = " kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [out] stream    Stream where the kernel should be dispatched.  May be 0, in which case the"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn __hipPopCallConfiguration(
        gridDim: *mut dim3,
        blockDim: *mut dim3,
        sharedMem: *mut usize,
        stream: *mut hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief C compliant kernel launch API"]
    #[doc = ""]
    #[doc = " @param [in] function_address - kernel stub function pointer."]
    #[doc = " @param [in] numBlocks - number of blocks"]
    #[doc = " @param [in] dimBlocks - dimension of a block"]
    #[doc = " @param [in] args - kernel arguments"]
    #[doc = " @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = "  Kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th"]
    #[doc = "  default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, hipInvalidDevice"]
    #[doc = ""]
    pub fn hipLaunchKernel(
        function_address: *const ::libc::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::libc::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " Callback/Activity API"]
    pub fn hipRegisterApiCallback(
        id: u32,
        fun: *mut ::libc::c_void,
        arg: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipRemoveApiCallback(id: u32) -> hipError_t;
}
extern "C" {
    pub fn hipRegisterActivityCallback(
        id: u32,
        fun: *mut ::libc::c_void,
        arg: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipRemoveActivityCallback(id: u32) -> hipError_t;
}
extern "C" {
    pub fn hipApiName(id: u32) -> *const ::libc::c_char;
}
extern "C" {
    pub fn hipKernelNameRef(f: hipFunction_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn hipKernelNameRefByPtr(
        hostFunction: *const ::libc::c_void,
        stream: hipStream_t,
    ) -> *const ::libc::c_char;
}
pub type hipblasHandle_t = *mut ::libc::c_void;
pub type hipblasHalf = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasBfloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_hipblasBfloat16() {
    assert_eq!(
        ::std::mem::size_of::<hipblasBfloat16>(),
        2usize,
        concat!("Size of: ", stringify!(hipblasBfloat16))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasBfloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(hipblasBfloat16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasBfloat16>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasBfloat16),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasComplex {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_hipblasComplex() {
    assert_eq!(
        ::std::mem::size_of::<hipblasComplex>(),
        8usize,
        concat!("Size of: ", stringify!(hipblasComplex))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasComplex>(),
        4usize,
        concat!("Alignment of ", stringify!(hipblasComplex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasComplex>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasComplex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasComplex>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasComplex),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasDoubleComplex {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_hipblasDoubleComplex() {
    assert_eq!(
        ::std::mem::size_of::<hipblasDoubleComplex>(),
        16usize,
        concat!("Size of: ", stringify!(hipblasDoubleComplex))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasDoubleComplex>(),
        8usize,
        concat!("Alignment of ", stringify!(hipblasDoubleComplex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasDoubleComplex>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasDoubleComplex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasDoubleComplex>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasDoubleComplex),
            "::",
            stringify!(y)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasStatus_t {
    HIPBLAS_STATUS_SUCCESS = 0,
    HIPBLAS_STATUS_NOT_INITIALIZED = 1,
    HIPBLAS_STATUS_ALLOC_FAILED = 2,
    HIPBLAS_STATUS_INVALID_VALUE = 3,
    HIPBLAS_STATUS_MAPPING_ERROR = 4,
    HIPBLAS_STATUS_EXECUTION_FAILED = 5,
    HIPBLAS_STATUS_INTERNAL_ERROR = 6,
    HIPBLAS_STATUS_NOT_SUPPORTED = 7,
    HIPBLAS_STATUS_ARCH_MISMATCH = 8,
    HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasOperation_t {
    HIPBLAS_OP_N = 111,
    HIPBLAS_OP_T = 112,
    HIPBLAS_OP_C = 113,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasPointerMode_t {
    HIPBLAS_POINTER_MODE_HOST = 0,
    HIPBLAS_POINTER_MODE_DEVICE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasFillMode_t {
    HIPBLAS_FILL_MODE_UPPER = 121,
    HIPBLAS_FILL_MODE_LOWER = 122,
    HIPBLAS_FILL_MODE_FULL = 123,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasDiagType_t {
    HIPBLAS_DIAG_NON_UNIT = 131,
    HIPBLAS_DIAG_UNIT = 132,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasSideMode_t {
    HIPBLAS_SIDE_LEFT = 141,
    HIPBLAS_SIDE_RIGHT = 142,
    HIPBLAS_SIDE_BOTH = 143,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasDatatype_t {
    #[doc = "< 16 bit floating point, real"]
    HIPBLAS_R_16F = 150,
    #[doc = "< 32 bit floating point, real"]
    HIPBLAS_R_32F = 151,
    #[doc = "< 64 bit floating point, real"]
    HIPBLAS_R_64F = 152,
    #[doc = "< 16 bit floating point, complex"]
    HIPBLAS_C_16F = 153,
    #[doc = "< 32 bit floating point, complex"]
    HIPBLAS_C_32F = 154,
    #[doc = "< 64 bit floating point, complex"]
    HIPBLAS_C_64F = 155,
    #[doc = "<  8 bit signed integer, real"]
    HIPBLAS_R_8I = 160,
    #[doc = "<  8 bit unsigned integer, real"]
    HIPBLAS_R_8U = 161,
    #[doc = "< 32 bit signed integer, real"]
    HIPBLAS_R_32I = 162,
    #[doc = "< 32 bit unsigned integer, real"]
    HIPBLAS_R_32U = 163,
    #[doc = "<  8 bit signed integer, complex"]
    HIPBLAS_C_8I = 164,
    #[doc = "<  8 bit unsigned integer, complex"]
    HIPBLAS_C_8U = 165,
    #[doc = "< 32 bit signed integer, complex"]
    HIPBLAS_C_32I = 166,
    #[doc = "< 32 bit unsigned integer, complex"]
    HIPBLAS_C_32U = 167,
    #[doc = "< 16 bit bfloat, real"]
    HIPBLAS_R_16B = 168,
    #[doc = "< 16 bit bfloat, complex"]
    HIPBLAS_C_16B = 169,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasGemmAlgo_t {
    HIPBLAS_GEMM_DEFAULT = 160,
}
extern "C" {
    pub fn hipblasCreate(handle: *mut hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDestroy(handle: hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSetStream(handle: hipblasHandle_t, streamId: hipStream_t) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGetStream(handle: hipblasHandle_t, streamId: *mut hipStream_t)
        -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSetPointerMode(
        handle: hipblasHandle_t,
        mode: hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGetPointerMode(
        handle: hipblasHandle_t,
        mode: *mut hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSetVector(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        x: *const ::libc::c_void,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGetVector(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        x: *const ::libc::c_void,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSetMatrix(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGetMatrix(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeam(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        B: *const f32,
        ldb: ::libc::c_int,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeam(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        B: *const f64,
        ldb: ::libc::c_int,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamax(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamax(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamaxBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamin(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamin(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsaminBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasum(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasum(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasumBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::libc::c_int,
        y: *mut hipblasHalf,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasHalf,
        x: *const *const hipblasHalf,
        incx: ::libc::c_int,
        y: *const *mut hipblasHalf,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *mut f32,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *mut f64,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasHalf,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasHalf,
        incx: ::libc::c_int,
        y: *const hipblasHalf,
        incy: ::libc::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasBfloat16,
        incx: ::libc::c_int,
        y: *const hipblasBfloat16,
        incy: ::libc::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasHalf,
        incx: ::libc::c_int,
        y: *const *const hipblasHalf,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasBfloat16,
        incx: ::libc::c_int,
        y: *const *const hipblasBfloat16,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *const f32,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *const f64,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasHalf,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasHalf,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasBfloat16,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasBfloat16,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2Batched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2Batched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        y: *const *mut f32,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        y: *const *mut f64,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotg(
        handle: hipblasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotg(
        handle: hipblasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        b: *mut hipblasComplex,
        c: *mut f32,
        s: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        b: *mut hipblasDoubleComplex,
        c: *mut f64,
        s: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f32,
        b: *const *mut f32,
        c: *const *mut f32,
        s: *const *mut f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f64,
        b: *const *mut f64,
        c: *const *mut f64,
        s: *const *mut f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasComplex,
        b: *const *mut hipblasComplex,
        c: *const *mut f32,
        s: *const *mut hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasDoubleComplex,
        b: *const *mut hipblasDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f32,
        stride_a: ::libc::c_int,
        b: *mut f32,
        stride_b: ::libc::c_int,
        c: *mut f32,
        stride_c: ::libc::c_int,
        s: *mut f32,
        stride_s: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f64,
        stride_a: ::libc::c_int,
        b: *mut f64,
        stride_b: ::libc::c_int,
        c: *mut f64,
        stride_c: ::libc::c_int,
        s: *mut f64,
        stride_s: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        stride_a: ::libc::c_int,
        b: *mut hipblasComplex,
        stride_b: ::libc::c_int,
        c: *mut f32,
        stride_c: ::libc::c_int,
        s: *mut hipblasComplex,
        stride_s: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        stride_a: ::libc::c_int,
        b: *mut hipblasDoubleComplex,
        stride_b: ::libc::c_int,
        c: *mut f64,
        stride_c: ::libc::c_int,
        s: *mut hipblasDoubleComplex,
        stride_s: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotm(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        param: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotm(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        param: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        y: *const *mut f32,
        incy: ::libc::c_int,
        param: *const *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        y: *const *mut f64,
        incy: ::libc::c_int,
        param: *const *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        param: *const f32,
        stride_param: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        param: *const f64,
        stride_param: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmg(
        handle: hipblasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmg(
        handle: hipblasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f32,
        d2: *const *mut f32,
        x1: *const *mut f32,
        y1: *const *const f32,
        param: *const *mut f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f64,
        d2: *const *mut f64,
        x1: *const *mut f64,
        y1: *const *const f64,
        param: *const *mut f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f32,
        stride_d1: ::libc::c_int,
        d2: *mut f32,
        stride_d2: ::libc::c_int,
        x1: *mut f32,
        stride_x1: ::libc::c_int,
        y1: *const f32,
        stride_y1: ::libc::c_int,
        param: *mut f32,
        stride_param: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f64,
        stride_d1: ::libc::c_int,
        d2: *mut f64,
        stride_d2: ::libc::c_int,
        x1: *mut f64,
        stride_x1: ::libc::c_int,
        y1: *const f64,
        stride_y1: ::libc::c_int,
        param: *mut f64,
        stride_param: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswap(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswap(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswapBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut *mut f32,
        incx: ::libc::c_int,
        y: *mut *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut *mut f64,
        incx: ::libc::c_int,
        y: *mut *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *mut *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        stridey: ::libc::c_int,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        stridey: ::libc::c_int,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSger(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDger(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgerBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *const f32,
        incy: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *const f64,
        incy: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        da: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        strideAP: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut hipblasComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        AP: *mut hipblasComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        AP: *const f32,
        strideAP: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        AP: *const f64,
        strideAP: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        AP: *const *mut f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        AP: *const *mut f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut f32,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut f64,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut hipblasComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *const f32,
        incy: ::libc::c_int,
        AP: *const *mut f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *const f64,
        incy: ::libc::c_int,
        AP: *const *mut f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        AP: *mut f32,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        AP: *mut f64,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        stirdeA: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        stirdeA: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stirdeA: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stirdeA: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *const f32,
        incy: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *const f64,
        incy: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f32,
        strideAP: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stride: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f64,
        strideAP: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stride: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasComplex,
        strideAP: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stride: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f32,
        strideAP: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f64,
        strideAP: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasComplex,
        strideAP: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        stridec: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        stridec: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        stridec: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        stridec: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *mut f32,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *mut f64,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *mut f32,
        lda: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *mut f64,
        lda: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *mut f32,
        lda: ::libc::c_int,
        B: *mut *mut f32,
        ldb: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *mut f64,
        lda: ::libc::c_int,
        B: *mut *mut f64,
        ldb: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        B: *mut *mut hipblasComplex,
        ldb: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *mut *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrf(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrf(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrf(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrf(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrfBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *const *mut f32,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *const *mut f64,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        strideP: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        strideP: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        strideP: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        strideP: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeqrf(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        ipiv: *mut f32,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrf(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        ipiv: *mut f64,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrf(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *mut hipblasComplex,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrf(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *mut hipblasDoubleComplex,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        ipiv: *const *mut f32,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        ipiv: *const *mut f64,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *const *mut hipblasComplex,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *const *mut hipblasDoubleComplex,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut f32,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut f64,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut hipblasComplex,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut hipblasDoubleComplex,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasHalf,
        A: *const hipblasHalf,
        lda: ::libc::c_int,
        B: *const hipblasHalf,
        ldb: ::libc::c_int,
        beta: *const hipblasHalf,
        C: *mut hipblasHalf,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasHalf,
        A: *const *const hipblasHalf,
        lda: ::libc::c_int,
        B: *const *const hipblasHalf,
        ldb: ::libc::c_int,
        beta: *const hipblasHalf,
        C: *const *mut hipblasHalf,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasHalf,
        A: *const hipblasHalf,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const hipblasHalf,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const hipblasHalf,
        C: *mut hipblasHalf,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const f32,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const f64,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmEx(
        handle: hipblasHandle_t,
        trans_a: hipblasOperation_t,
        trans_b: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const ::libc::c_void,
        a: *const ::libc::c_void,
        a_type: hipblasDatatype_t,
        lda: ::libc::c_int,
        b: *const ::libc::c_void,
        b_type: hipblasDatatype_t,
        ldb: ::libc::c_int,
        beta: *const ::libc::c_void,
        c: *mut ::libc::c_void,
        c_type: hipblasDatatype_t,
        ldc: ::libc::c_int,
        compute_type: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
pub type miopenAcceleratorQueue_t = hipStream_t;
#[doc = " @ingroup handle"]
#[doc = " @brief Creates the miopenHandle_t type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenHandle {}
#[test]
fn bindgen_test_layout_miopenHandle() {
    assert_eq!(
        ::std::mem::size_of::<miopenHandle>(),
        0usize,
        concat!("Size of: ", stringify!(miopenHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenHandle>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenHandle))
    );
}
pub type miopenHandle_t = *mut miopenHandle;
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenStatus_t"]
#[doc = " Error codes that are returned by all MIOpen API calls."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenStatus_t {
    #[doc = "< No errors"]
    miopenStatusSuccess = 0,
    #[doc = "< Data not initialized."]
    miopenStatusNotInitialized = 1,
    #[doc = "< Incorrect variable value."]
    miopenStatusInvalidValue = 2,
    #[doc = "< Incorrect parameter detected."]
    miopenStatusBadParm = 3,
    #[doc = "< Memory allocation error."]
    miopenStatusAllocFailed = 4,
    #[doc = "< MIOpen failure."]
    miopenStatusInternalError = 5,
    #[doc = "< Use of unimplemented feature."]
    miopenStatusNotImplemented = 6,
    #[doc = "< Unknown error occurred."]
    miopenStatusUnknownError = 7,
    #[doc = "< Unsupported operator for fusion."]
    miopenStatusUnsupportedOp = 8,
}
extern "C" {
    #[doc = " @brief Get character string for an error code."]
    #[doc = ""]
    #[doc = " A function which returns a NULL terminated character string of the error code."]
    #[doc = ""]
    #[doc = " @param error  miopenStatus_t type error status (input)"]
    #[doc = " @return       errorString"]
    pub fn miopenGetErrorString(error: miopenStatus_t) -> *const ::libc::c_char;
}
#[doc = " @brief Custom allocator function"]
#[doc = ""]
#[doc = " This function allow for user-defined custom allocator"]
#[doc = ""]
#[doc = " @param context     A pointer a context (input)"]
#[doc = " @param sizeBytes   Number of bytes to allocate (input)"]
pub type miopenAllocatorFunction = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::libc::c_void, sizeBytes: usize) -> *mut ::libc::c_void,
>;
#[doc = " @brief Custom deallocator function"]
#[doc = ""]
#[doc = " This function allow for user-defined custom deallocation function"]
#[doc = ""]
#[doc = " @param context     A pointer context (input)"]
#[doc = " @param memory      A pointer allocated memory (input)"]
pub type miopenDeallocatorFunction = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::libc::c_void, memory: *mut ::libc::c_void),
>;
extern "C" {
    #[doc = " @brief Method to return version of MIOpen"]
    #[doc = ""]
    #[doc = " The output values of this call follow from the versioning"]
    #[doc = " format major.minor.patch"]
    #[doc = ""]
    #[doc = " Pointers that are NULL will be ignored."]
    #[doc = ""]
    #[doc = " @param major     Major version number (output)"]
    #[doc = " @param minor     Minor version number (output)"]
    #[doc = " @param patch     Patch version number (output)"]
    #[doc = ""]
    #[doc = " @return          miopenStatus_t"]
    pub fn miopenGetVersion(
        major: *mut usize,
        minor: *mut usize,
        patch: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Method to create the MIOpen handle object."]
    #[doc = ""]
    #[doc = " This function creates a MIOpen handle. This is called at the very start to initialize the MIOpen"]
    #[doc = " environment."]
    #[doc = " @param handle     A pointer to a MIOpen handle type (output)"]
    #[doc = ""]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenCreate(handle: *mut miopenHandle_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Create a MIOpen handle with an accelerator stream."]
    #[doc = ""]
    #[doc = " The HIP side uses a hipStream_t type for the stream, while OpenCL will use a"]
    #[doc = " cl_command_queue."]
    #[doc = ""]
    #[doc = " Create a handle with a previously created accelerator command queue."]
    #[doc = " @param handle     A pointer to a MIOpen handle type (output)"]
    #[doc = " @param stream      An accelerator queue type (input)"]
    #[doc = ""]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenCreateWithStream(
        handle: *mut miopenHandle_t,
        stream: miopenAcceleratorQueue_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys the MIOpen handle."]
    #[doc = ""]
    #[doc = " This is called when breaking down the MIOpen environment."]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenDestroy(handle: miopenHandle_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set accelerator command queue previously created"]
    #[doc = ""]
    #[doc = " Set a command queue for an accelerator device"]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @param streamID   An accelerator queue type (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenSetStream(
        handle: miopenHandle_t,
        streamID: miopenAcceleratorQueue_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the previously created accelerator command queue"]
    #[doc = ""]
    #[doc = " Creates a command queue for an accelerator device"]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @param streamID   Pointer to a accelerator queue type (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGetStream(
        handle: miopenHandle_t,
        streamID: *mut miopenAcceleratorQueue_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set allocator for previously created miopenHandle"]
    #[doc = ""]
    #[doc = " Set a command queue for an accelerator device"]
    #[doc = " @param handle     MIOpen handle"]
    #[doc = " @param allocator  A callback function MIOpen will use for internal memory allocations."]
    #[doc = "      The provided callback function should allocate device memory with requested size"]
    #[doc = "      and return a pointer to this memory."]
    #[doc = "      Passing 0 will restore the default MIOpen allocator and deallocator."]
    #[doc = " @param deallocator  A callback function MIOpen will use to for internal memory deallocation."]
    #[doc = "      The provided callback function should free the specified memory pointer"]
    #[doc = " @param allocatorContext  User-specified pointer which is passed to \\p allocator and \\p"]
    #[doc = " deallocator"]
    #[doc = "      This allows the callback function to access state set by the caller to this function,"]
    #[doc = "      for example a stateful heap allocator or a c++ class."]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenSetAllocator(
        handle: miopenHandle_t,
        allocator: miopenAllocatorFunction,
        deallocator: miopenDeallocatorFunction,
        allocatorContext: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get time for last kernel launched"]
    #[doc = ""]
    #[doc = " This function is used only when profiling mode has been enabled."]
    #[doc = " Kernel timings are based on the MIOpen handle and is not thread-safe."]
    #[doc = " In order to use multi-threaded profiling, create an MIOpen handle for each"]
    #[doc = " concurrent thread."]
    #[doc = ""]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @param time       Pointer to a float type to contain kernel time in milliseconds (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGetKernelTime(handle: miopenHandle_t, time: *mut f32) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Enable profiling to retrieve kernel time"]
    #[doc = ""]
    #[doc = " Enable or disable kernel profiling. This profiling is only for kernel time."]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @param enable     Boolean to toggle profiling (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenEnableProfiling(handle: miopenHandle_t, enable: bool) -> miopenStatus_t;
}
#[doc = " @ingroup fusion"]
#[doc = " @brief Creates the miopenFusionOpDescriptor_t type"]
#[doc = ""]
#[doc = " Fusion Operator Descriptor contains the meta-data associated with an operator"]
#[doc = " to be fused in a compute graph"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenFusionOpDescriptor {}
#[test]
fn bindgen_test_layout_miopenFusionOpDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenFusionOpDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenFusionOpDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenFusionOpDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenFusionOpDescriptor))
    );
}
pub type miopenFusionOpDescriptor_t = *mut miopenFusionOpDescriptor;
#[doc = " @ingroup tensor"]
#[doc = " @brief Creates the miopenTensorDescriptor_t type"]
#[doc = ""]
#[doc = " Tensor descriptor is an object that allows the user to specify a layer's size for each"]
#[doc = " dimension and dimension strides. Currently only 4-D fully packed tensors are supported."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenTensorDescriptor {}
#[test]
fn bindgen_test_layout_miopenTensorDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenTensorDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenTensorDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenTensorDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenTensorDescriptor))
    );
}
pub type miopenTensorDescriptor_t = *mut miopenTensorDescriptor;
#[doc = " @ingroup convolutions"]
#[doc = " @brief Creates the miopenConvolutionDescriptor_t type"]
#[doc = ""]
#[doc = " Convolution descriptor is an object that allows the user to specify a layer's padding, stride,"]
#[doc = " and dilation of the convolutional filter. Parameters must all be non-negative."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenConvolutionDescriptor {}
#[test]
fn bindgen_test_layout_miopenConvolutionDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenConvolutionDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenConvolutionDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenConvolutionDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenConvolutionDescriptor))
    );
}
pub type miopenConvolutionDescriptor_t = *mut miopenConvolutionDescriptor;
#[doc = " @ingroup pooling"]
#[doc = " @brief Creates the miopenPoolingDescriptor_t type"]
#[doc = ""]
#[doc = " Pooling descriptor is an object that allows the user to specify the dimension sizes of the"]
#[doc = " pooling windows, paddings, strides, and pooling mode."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenPoolingDescriptor {}
#[test]
fn bindgen_test_layout_miopenPoolingDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenPoolingDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenPoolingDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenPoolingDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenPoolingDescriptor))
    );
}
pub type miopenPoolingDescriptor_t = *mut miopenPoolingDescriptor;
#[doc = " @ingroup LRN"]
#[doc = "  @brief Creates the miopenLRNDescriptor_t type"]
#[doc = ""]
#[doc = " LRN descriptor is an object that allows the user to specify the LRN mode, the number of elements"]
#[doc = " in the normalization window, and the LRN k-parameter."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenLRNDescriptor {}
#[test]
fn bindgen_test_layout_miopenLRNDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenLRNDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenLRNDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenLRNDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenLRNDescriptor))
    );
}
pub type miopenLRNDescriptor_t = *mut miopenLRNDescriptor;
#[doc = " @ingroup activation"]
#[doc = " @brief Creates the miopenActivationDescriptor_t type"]
#[doc = ""]
#[doc = " Activation descriptor is an object that allows the user to specify the activation mode."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenActivationDescriptor {}
#[test]
fn bindgen_test_layout_miopenActivationDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenActivationDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenActivationDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenActivationDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenActivationDescriptor))
    );
}
pub type miopenActivationDescriptor_t = *mut miopenActivationDescriptor;
#[doc = " @ingroup RNN"]
#[doc = " @brief Creates the miopenRNNDescriptor_t type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenRNNDescriptor {}
#[test]
fn bindgen_test_layout_miopenRNNDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenRNNDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenRNNDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenRNNDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenRNNDescriptor))
    );
}
pub type miopenRNNDescriptor_t = *mut miopenRNNDescriptor;
#[doc = " @ingroup LossFunction"]
#[doc = " @brief Creates the miopenCTCLossDescriptor_t type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenCTCLossDescriptor {}
#[test]
fn bindgen_test_layout_miopenCTCLossDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenCTCLossDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenCTCLossDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenCTCLossDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenCTCLossDescriptor))
    );
}
pub type miopenCTCLossDescriptor_t = *mut miopenCTCLossDescriptor;
#[doc = " @ingroup Dropout"]
#[doc = " @brief Creates the miopenDropoutDescriptor_t type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenDropoutDescriptor {}
#[test]
fn bindgen_test_layout_miopenDropoutDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenDropoutDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenDropoutDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenDropoutDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenDropoutDescriptor))
    );
}
pub type miopenDropoutDescriptor_t = *mut miopenDropoutDescriptor;
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup tensor"]
#[doc = " @enum miopenDataType_t"]
#[doc = " MIOpen floating point datatypes. Both 32-bit and 16-bit floats are supported in MIOpen."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenDataType_t {
    #[doc = "< 16-bit floating point (Fully supported)"]
    miopenHalf = 0,
    #[doc = "< 32-bit floating point (Fully supported)"]
    miopenFloat = 1,
    #[doc = "< 32-bit int point (Partially supported)"]
    miopenInt32 = 2,
    #[doc = "< 8-bit int point (Partially supported)"]
    miopenInt8 = 3,
    miopenInt8x4 = 4,
    #[doc = "< 16-bit binary floating point (8-bit exponent, 7-bit fraction)"]
    #[doc = "(Partially supported)"]
    miopenBFloat16 = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup pooling"]
#[doc = " @enum miopenIndexType_t"]
#[doc = " MIOpen index datatypes."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenIndexType_t {
    #[doc = "<  8-bit unsigned"]
    miopenIndexUint8 = 0,
    #[doc = "< 16-bit unsigned"]
    miopenIndexUint16 = 1,
    #[doc = "< 32-bit unsigned"]
    miopenIndexUint32 = 2,
    #[doc = "< 64-bit unsigned"]
    miopenIndexUint64 = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup tensor"]
#[doc = " @enum miopenTensorOp_t"]
#[doc = " Element-wise tensor operation modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenTensorOp_t {
    #[doc = "< Add tensors element-wise"]
    miopenTensorOpAdd = 0,
    #[doc = "< Multiply two tensors element-wise"]
    miopenTensorOpMul = 1,
    #[doc = "< Minimum of tensor element pairs"]
    miopenTensorOpMin = 2,
    #[doc = "< Maximum of tensor element pairs"]
    miopenTensorOpMax = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup convolutions"]
#[doc = "  @enum miopenConvolutionMode_t"]
#[doc = " Convolution mode selection for convolution layer preference."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenConvolutionMode_t {
    #[doc = "< Cross-Correlation convolution"]
    miopenConvolution = 0,
    #[doc = "< Transpose convolutions -- deconvolution"]
    miopenTranspose = 1,
    #[doc = "< Deprecated Group convolution legacy, ToBe Removed"]
    miopenGroupConv = 2,
    #[doc = "< Deprecated Depthwise convolution legacy, ToBe Removed"]
    miopenDepthwise = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup padding"]
#[doc = "  @enum miopenPaddingMode_t"]
#[doc = " Padding mode selection for convolution/Pooling layer preference"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenPaddingMode_t {
    #[doc = "< MIOPEN Default Padding"]
    miopenPaddingDefault = 0,
    #[doc = "< Tensorflow SAME Padding"]
    miopenPaddingSame = 1,
    #[doc = "< Tensorflow VALID Padding"]
    miopenPaddingValid = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup pooling"]
#[doc = " @enum miopenPoolingMode_t"]
#[doc = " Pooling layer mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenPoolingMode_t {
    #[doc = "< Maximum pooling"]
    miopenPoolingMax = 0,
    #[doc = "< Average pooling"]
    miopenPoolingAverage = 1,
    #[doc = "< Inclusive Average pooling"]
    miopenPoolingAverageInclusive = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup LRN"]
#[doc = " @enum miopenLRNMode_t"]
#[doc = " Local Response Normalization layer mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenLRNMode_t {
    #[doc = "< Channel independent"]
    miopenLRNWithinChannel = 0,
    #[doc = "< Cross Channel"]
    miopenLRNCrossChannel = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup batchnorm"]
#[doc = " @enum miopenBatchNormMode_t"]
#[doc = " Batch Normalization layer mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenBatchNormMode_t {
    #[doc = "< Element-wise normalization for fully connected layer"]
    miopenBNPerActivation = 0,
    #[doc = "< Mini-batch spatial normalization for convolutional layers"]
    miopenBNSpatial = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup activation"]
#[doc = " @enum miopenActivationMode_t"]
#[doc = " Activation layer modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenActivationMode_t {
    #[doc = "< No activation, pass through the data"]
    miopenActivationPASTHRU = 0,
    #[doc = "< Sigmoid function: \\f$1 / (1 + e^{-x})\\f$"]
    miopenActivationLOGISTIC = 1,
    #[doc = "< Tanh activation \\f$ \\beta * tanh( \\alpha * x) \\f$"]
    miopenActivationTANH = 2,
    #[doc = "< Rectified Linear Unit \\f$ max(0, x) \\f$"]
    miopenActivationRELU = 3,
    #[doc = "< \\f$log(1 + e^x)\\f$"]
    miopenActivationSOFTRELU = 4,
    #[doc = "< Absolute value \\f$abs(x)\\f$"]
    miopenActivationABS = 5,
    #[doc = "< Scaled and shifted power \\f$(\\alpha + \\beta * x)^{gamma}\\f$"]
    miopenActivationPOWER = 6,
    miopenActivationCLIPPEDRELU = 7,
    miopenActivationLEAKYRELU = 8,
    miopenActivationELU = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup softmax"]
#[doc = " @enum miopenSoftmaxAlgorithm_t"]
#[doc = " Softmax implementation algorithms"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenSoftmaxAlgorithm_t {
    #[doc = "< straightforward softmax"]
    MIOPEN_SOFTMAX_FAST = 0,
    #[doc = "< scaled softmax by maximum value in input domain"]
    MIOPEN_SOFTMAX_ACCURATE = 1,
    #[doc = "< log softmax"]
    MIOPEN_SOFTMAX_LOG = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @ingroup softmax"]
#[doc = " @enum miopenSoftmaxMode_t"]
#[doc = " Softmax modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenSoftmaxMode_t {
    #[doc = "< compute per image (N) across C, H, W"]
    MIOPEN_SOFTMAX_MODE_INSTANCE = 0,
    MIOPEN_SOFTMAX_MODE_CHANNEL = 1,
}
extern "C" {
    #[doc = " @brief Create a Tensor Descriptor"]
    #[doc = ""]
    #[doc = " API for creating an uninitialized tensor descriptor."]
    #[doc = " @param tensorDesc Pointer to a tensor descriptor type (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenCreateTensorDescriptor(
        tensorDesc: *mut miopenTensorDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set shape of 4D tensor"]
    #[doc = ""]
    #[doc = " Interface for setting 4-D tensor shape. MIOpen currently only implements NCHW layout."]
    #[doc = ""]
    #[doc = " @param tensorDesc Tensor descriptor type (output)"]
    #[doc = " @param dataType   MIOpen datatype (input)"]
    #[doc = " @param n          Mini-batch size (input)"]
    #[doc = " @param c          Number of channels (input)"]
    #[doc = " @param h          Data height dimension size (input)"]
    #[doc = " @param w          Data width dimension size (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenSet4dTensorDescriptor(
        tensorDesc: miopenTensorDescriptor_t,
        dataType: miopenDataType_t,
        n: ::libc::c_int,
        c: ::libc::c_int,
        h: ::libc::c_int,
        w: ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the details of the tensor descriptor"]
    #[doc = ""]
    #[doc = " Interface to query the 4-D tensor shape."]
    #[doc = ""]
    #[doc = " @param tensorDesc Tensor descriptor type (input)"]
    #[doc = " @param dataType   MIOpen datatype (input)"]
    #[doc = " @param n          Mini-batch size (output)"]
    #[doc = " @param c          Number of channels (output)"]
    #[doc = " @param h          Data height dimension size (output)"]
    #[doc = " @param w          Data width dimension size (output)"]
    #[doc = " @param nStride    Mini-batch dimension stride (output)"]
    #[doc = " @param cStride    Channel dimension stride (output)"]
    #[doc = " @param hStride    Height dimension stride (output)"]
    #[doc = " @param wStride    Width dimension stride (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGet4dTensorDescriptor(
        tensorDesc: miopenTensorDescriptor_t,
        dataType: *mut miopenDataType_t,
        n: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int,
        nStride: *mut ::libc::c_int,
        cStride: *mut ::libc::c_int,
        hStride: *mut ::libc::c_int,
        wStride: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set shape of N-dimensional tensor"]
    #[doc = ""]
    #[doc = " Interface for setting tensor shape. MIOpen has support for 1, 2, 3, 4, 5 dimensional tensor of"]
    #[doc = " layout."]
    #[doc = " @param tensorDesc   Tensor descriptor type (input)"]
    #[doc = " @param dataType     MIOpen datatype (input)"]
    #[doc = " @param nbDims       Number of dimensions in the dimsA array (input)"]
    #[doc = " @param dimsA        Array containing the size of dimensions (input)"]
    #[doc = " @param stridesA     Array containing the size of stride (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenSetTensorDescriptor(
        tensorDesc: miopenTensorDescriptor_t,
        dataType: miopenDataType_t,
        nbDims: ::libc::c_int,
        dimsA: *mut ::libc::c_int,
        stridesA: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set shape of N-dimensional tensor"]
    #[doc = ""]
    #[doc = " Interface for querying tensor size. MIOpen has support for 1, 2, 3, 4, 5 dimensional tensor of"]
    #[doc = " layout."]
    #[doc = " @param tensorDesc   Tensor descriptor type (input)"]
    #[doc = " @param size         number of elements in tensor described by the descriptor (output)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenGetTensorDescriptorSize(
        tensorDesc: miopenTensorDescriptor_t,
        size: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the details of the N-dimensional tensor descriptor."]
    #[doc = ""]
    #[doc = " @param tensorDesc Tensor descriptor type (input)"]
    #[doc = " @param dataType   MIOpen datatype (input)"]
    #[doc = " @param dimsA      Array containing the size of dimensions (output)"]
    #[doc = " @param stridesA   Array containing the size of stride (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGetTensorDescriptor(
        tensorDesc: miopenTensorDescriptor_t,
        dataType: *mut miopenDataType_t,
        dimsA: *mut ::libc::c_int,
        stridesA: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys the tensor descriptor"]
    #[doc = ""]
    #[doc = " @param tensorDesc Tensor descriptor type (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenDestroyTensorDescriptor(tensorDesc: miopenTensorDescriptor_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute element-wise tensor operations"]
    #[doc = ""]
    #[doc = " This function implements: \\f$ C = op ( alpha1[0] * A, alpha2[0] * B ) + beta[0] * C \\f$"]
    #[doc = ""]
    #[doc = " For Forward Bias one can also use, miopenConvolutionForwardBias()"]
    #[doc = ""]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @param tensorOp   Operation from miopenTensorOp_t (input)"]
    #[doc = " @param alpha1     Tensor A's floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param aDesc      Tensor descriptor for tensor A (input)"]
    #[doc = " @param A          Tensor A (input)"]
    #[doc = " @param alpha2     Tensor B's floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param bDesc      Tensor descriptor for tensor B (input)"]
    #[doc = " @param B          Tensor B (input)"]
    #[doc = " @param beta       Tensor C's floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param cDesc      Tensor descriptor for tensor C (input)"]
    #[doc = " @param C          Tensor C (input and output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenOpTensor(
        handle: miopenHandle_t,
        tensorOp: miopenTensorOp_t,
        alpha1: *const ::libc::c_void,
        aDesc: miopenTensorDescriptor_t,
        A: *const ::libc::c_void,
        alpha2: *const ::libc::c_void,
        bDesc: miopenTensorDescriptor_t,
        B: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        cDesc: miopenTensorDescriptor_t,
        C: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Fills a tensor with a single value."]
    #[doc = ""]
    #[doc = " Supported datatypes are fp32, fp16, and bfp16"]
    #[doc = ""]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @param yDesc      Tensor descriptor for tensor y (input)"]
    #[doc = " @param y          Tensor y (input)"]
    #[doc = " @param alpha      Pointer to fill value (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenSetTensor(
        handle: miopenHandle_t,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        alpha: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Scales all elements in a tensor by a single value."]
    #[doc = ""]
    #[doc = " Supported datatypes are fp32 and fp16"]
    #[doc = ""]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @param yDesc      Tensor descriptor for tensor y (input)"]
    #[doc = " @param y          Tensor y (input and output)"]
    #[doc = " @param alpha      Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenScaleTensor(
        handle: miopenHandle_t,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        alpha: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Returns number of bytes associated with tensor descriptor"]
    #[doc = ""]
    #[doc = " @param tensorDesc Tensor descriptor (input)"]
    #[doc = " @param numBytes   Number of bytes associated with tensor descriptor (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGetTensorNumBytes(
        tensorDesc: miopenTensorDescriptor_t,
        numBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Copies one tensor to another tensor with a different layout/scale."]
    #[doc = ""]
    #[doc = " This function implements:"]
    #[doc = " 1. \\f$ Y = alpha * X + beta * Y \\f$ for fp32 and fp16 datatype"]
    #[doc = " 2. Vectorize/de-vectorize along channel dimension C for int8 datatype"]
    #[doc = ""]
    #[doc = " Currently this is used for transforming from int8 to int8x4 vector datatypes"]
    #[doc = ""]
    #[doc = " @param handle     MIOpen handle (input)"]
    #[doc = " @param alpha      Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param xDesc      Source Tensor descriptor for tensor x (input)"]
    #[doc = " @param x          Source Tensor x (input)"]
    #[doc = " @param beta       Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param yDesc      Destination Tensor descriptor for tensor y (input)"]
    #[doc = " @param y          Destination Tensor y (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenTransformTensor(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a convolution layer descriptor"]
    #[doc = ""]
    #[doc = " @param convDesc   Convolution layer descriptor"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenCreateConvolutionDescriptor(
        convDesc: *mut miopenConvolutionDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a 2-D convolution layer descriptor"]
    #[doc = ""]
    #[doc = " For group/depthwise convolution dilation height and width, only a dilation value of 1 is"]
    #[doc = " supported."]
    #[doc = ""]
    #[doc = " @param convDesc   Convolution layer descriptor (output)"]
    #[doc = " @param c_mode     Convolutional mode (input)"]
    #[doc = " @param pad_h      Height input data padding (input)"]
    #[doc = " @param pad_w      Width input data padding (input)"]
    #[doc = " @param stride_h   Stride for the height of input data (input)"]
    #[doc = " @param stride_w   Stride for the width of input data (input)"]
    #[doc = " @param dilation_h Dilation height (input)"]
    #[doc = " @param dilation_w Dilation width (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenInitConvolutionDescriptor(
        convDesc: miopenConvolutionDescriptor_t,
        c_mode: miopenConvolutionMode_t,
        pad_h: ::libc::c_int,
        pad_w: ::libc::c_int,
        stride_h: ::libc::c_int,
        stride_w: ::libc::c_int,
        dilation_h: ::libc::c_int,
        dilation_w: ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a N-dimensional convolution layer descriptor"]
    #[doc = ""]
    #[doc = " @param convDesc      Convolution layer descriptor (output)"]
    #[doc = " @param spatialDim    Convolutional spatial dimension (input)"]
    #[doc = " @param padA          Array of input data padding (input)"]
    #[doc = " @param strideA       Array of convolution stride (input)"]
    #[doc = " @param dilationA     Array of convolution dilation (input)"]
    #[doc = " @param c_mode        Convolutional mode (input)"]
    #[doc = " @return              miopenStatus_t"]
    pub fn miopenInitConvolutionNdDescriptor(
        convDesc: miopenConvolutionDescriptor_t,
        spatialDim: ::libc::c_int,
        padA: *mut ::libc::c_int,
        strideA: *mut ::libc::c_int,
        dilationA: *mut ::libc::c_int,
        c_mode: miopenConvolutionMode_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Retrieves a 2-D convolution layer descriptor's details"]
    #[doc = ""]
    #[doc = " For group/depthwise convolution dilation height and width, only a dilation value of 1 is"]
    #[doc = " supported."]
    #[doc = ""]
    #[doc = " @param convDesc   Convolution layer descriptor (input)"]
    #[doc = " @param c_mode     Convolutional mode (output)"]
    #[doc = " @param pad_h      Height input data padding (output)"]
    #[doc = " @param pad_w      Width input data padding (output)"]
    #[doc = " @param stride_h   Stride for the height of input data (output)"]
    #[doc = " @param stride_w   Stride for the width of input data (output)"]
    #[doc = " @param dilation_h Dilation height (output)"]
    #[doc = " @param dilation_w Dilation width (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGetConvolutionDescriptor(
        convDesc: miopenConvolutionDescriptor_t,
        c_mode: *mut miopenConvolutionMode_t,
        pad_h: *mut ::libc::c_int,
        pad_w: *mut ::libc::c_int,
        stride_h: *mut ::libc::c_int,
        stride_w: *mut ::libc::c_int,
        dilation_h: *mut ::libc::c_int,
        dilation_w: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Retrieves a N-dimensional convolution layer descriptor's details"]
    #[doc = ""]
    #[doc = " @param convDesc               Convolution layer descriptor (input)"]
    #[doc = " @param requestedSpatialDim    Expected convolution spatial dimension (intput)"]
    #[doc = " @param spatialDim             Convolutional spatial dimension (output)"]
    #[doc = " @param padA                   Array of input data padding (output)"]
    #[doc = " @param strideA                Array of convolution stride (output)"]
    #[doc = " @param dilationA              Array of convolution dilation (output)"]
    #[doc = " @param c_mode                 Convolutional mode (output)"]
    #[doc = " @return                       miopenStatus_t"]
    pub fn miopenGetConvolutionNdDescriptor(
        convDesc: miopenConvolutionDescriptor_t,
        requestedSpatialDim: ::libc::c_int,
        spatialDim: *mut ::libc::c_int,
        padA: *mut ::libc::c_int,
        strideA: *mut ::libc::c_int,
        dilationA: *mut ::libc::c_int,
        c_mode: *mut miopenConvolutionMode_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set the number of groups to be used in Group/Depthwise convolution"]
    #[doc = ""]
    #[doc = " Must be called before all computational APIs of group/depthwise convolution, it is preferable to"]
    #[doc = " call miopenInitConvolutionDescriptor() first, then miopenSetConvolutionGroupCount() to fully"]
    #[doc = " initialize group convolutions. Both Convolution Mode and Transpose Convolution Mode support"]
    #[doc = " group/depthwise convolution. To run depthwise convolution, set groupCount value equal to number of"]
    #[doc = " channels."]
    #[doc = ""]
    #[doc = " @param convDesc   Convolution layer descriptor (output)"]
    #[doc = " @param groupCount      number of groups, in depthwise conv using filter_number/channel_multiplier"]
    #[doc = " (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenSetConvolutionGroupCount(
        convDesc: miopenConvolutionDescriptor_t,
        groupCount: ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set the output padding to be used in 2-D Transpose convolution"]
    #[doc = ""]
    #[doc = " This function is optional for initialization of Transpose convolution. If applicable, it must be"]
    #[doc = " called before all computational APIs of Transpose convolution. It is preferable to call"]
    #[doc = " miopenInitConvolutionDescriptor() first, then miopenSetTransposeConvOutputPadding() to fully"]
    #[doc = " initialize transpose convolutions."]
    #[doc = ""]
    #[doc = " @param convDesc   Convolution layer descriptor (output)"]
    #[doc = " @param adj_h      output padding for the height of output data (input)"]
    #[doc = " @param adj_w      output padding for the width of output data (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenSetTransposeConvOutputPadding(
        convDesc: miopenConvolutionDescriptor_t,
        adj_h: ::libc::c_int,
        adj_w: ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set the output padding to be used in N-dimensional Transpose convolution"]
    #[doc = ""]
    #[doc = " This function is optional for initialization of Transpose convolution. If applicable, it must be"]
    #[doc = " called before all computational APIs of Transpose convolution. It is preferable to call"]
    #[doc = " miopenInitConvolutionNdDescriptor() first, then miopenSetTransposeConvNdOutputPadding() to fully"]
    #[doc = " initialize transpose convolutions. Currently, 2-D and 3-D convolutions are supported."]
    #[doc = ""]
    #[doc = " @param convDesc      Convolution layer descriptor (output)"]
    #[doc = " @param spatialDim    Convolutional spatial dimension (input)"]
    #[doc = " @param adjA          array of output padding for output data (input)"]
    #[doc = " @return              miopenStatus_t"]
    pub fn miopenSetTransposeConvNdOutputPadding(
        convDesc: miopenConvolutionDescriptor_t,
        spatialDim: ::libc::c_int,
        adjA: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the shape of a resulting 4-D tensor from a 2-D convolution"]
    #[doc = ""]
    #[doc = " This function returns the dimensions of the resulting 4D tensor of a 2D"]
    #[doc = " convolution, given the convolution descriptor, the input tensor descriptor"]
    #[doc = " and the filter descriptor. This function can help to setup the output tensor"]
    #[doc = " and allocate the proper amount of memory prior to launch the actual"]
    #[doc = " convolution."]
    #[doc = ""]
    #[doc = " @param convDesc          Convolution layer descriptor (input)"]
    #[doc = " @param inputTensorDesc   Input data tensor descriptor (input)"]
    #[doc = " @param filterDesc        Weight descriptor (input)"]
    #[doc = " @param n                 Mini-batch size (output)"]
    #[doc = " @param c                 Number of channels (output)"]
    #[doc = " @param h                 Data height dimension size (output)"]
    #[doc = " @param w                 Data width dimension size (output)"]
    #[doc = " @return                  miopenStatus_t"]
    pub fn miopenGetConvolutionForwardOutputDim(
        convDesc: miopenConvolutionDescriptor_t,
        inputTensorDesc: miopenTensorDescriptor_t,
        filterDesc: miopenTensorDescriptor_t,
        n: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the shape of a resulting N-dimensional tensor from a (N-2)-dimensional convolution"]
    #[doc = ""]
    #[doc = " This function returns the dimensions of the resulting N-dimensional tensor of a (N-2)-dimensional"]
    #[doc = " convolution, given the convolution descriptor, the input tensor descriptor"]
    #[doc = " and the filter descriptor. It is used to setup the output tensor descriptor prior to executing"]
    #[doc = " the convolution layer."]
    #[doc = ""]
    #[doc = " @param convDesc          Convolution layer descriptor (input)"]
    #[doc = " @param inputTensorDesc   Input data tensor descriptor (input)"]
    #[doc = " @param filterDesc        Weight descriptor (input)"]
    #[doc = " @param nDim              Pointer to Output data tensor dimension (output)"]
    #[doc = " @param outputTensorDimA  Array of Output data tensor length (output)"]
    pub fn miopenGetConvolutionNdForwardOutputDim(
        convDesc: miopenConvolutionDescriptor_t,
        inputTensorDesc: miopenTensorDescriptor_t,
        filterDesc: miopenTensorDescriptor_t,
        nDim: *mut ::libc::c_int,
        outputTensorDimA: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys the tensor descriptor object"]
    #[doc = ""]
    #[doc = " @param convDesc Convolution tensor descriptor type (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenDestroyConvolutionDescriptor(
        convDesc: miopenConvolutionDescriptor_t,
    ) -> miopenStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenConvFwdAlgorithm_t"]
#[doc = " Convolutional algorithm mode for forward propagation. MIOpen use cross-correlation for its"]
#[doc = " convolution implementation."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenConvFwdAlgorithm_t {
    #[doc = "< GEMM variant"]
    miopenConvolutionFwdAlgoGEMM = 0,
    #[doc = "< Direct convolutions"]
    miopenConvolutionFwdAlgoDirect = 1,
    #[doc = "< Fast Fourier Transform indirect convolutions"]
    miopenConvolutionFwdAlgoFFT = 2,
    #[doc = "< Winograd indirect convolutions"]
    miopenConvolutionFwdAlgoWinograd = 3,
    #[doc = "< Implicit GEMM convolutions, fp32 only"]
    miopenConvolutionFwdAlgoImplicitGEMM = 5,
    #[doc = "< Static Compiled GEMM convolutions"]
    miopenConvolutionFwdAlgoStaticCompiledGEMM = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenConvBwdWeightsAlgorithm_t"]
#[doc = " Convolutional algorithm mode for back propagation on weights."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenConvBwdWeightsAlgorithm_t {
    #[doc = "< GEMM variant"]
    miopenConvolutionBwdWeightsAlgoGEMM = 0,
    #[doc = "< Direct convolution algorithm"]
    miopenConvolutionBwdWeightsAlgoDirect = 1,
    #[doc = "< Winograd convolutions"]
    miopenConvolutionBwdWeightsAlgoWinograd = 3,
    #[doc = "< Implicit GEMM convolutions"]
    miopenConvolutionBwdWeightsAlgoImplicitGEMM = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenConvBwdDataAlgorithm_t"]
#[doc = " Convolutional algorithm mode for back propagation on data."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenConvBwdDataAlgorithm_t {
    #[doc = "< GEMM variant"]
    miopenConvolutionBwdDataAlgoGEMM = 0,
    #[doc = "< Direct convolutions"]
    miopenConvolutionBwdDataAlgoDirect = 1,
    #[doc = "< Fast Fourier Transform indirect convolutions"]
    miopenConvolutionBwdDataAlgoFFT = 2,
    #[doc = "< Winograd indirect convolutions"]
    miopenConvolutionBwdDataAlgoWinograd = 3,
    miopenTransposeBwdDataAlgoGEMM = 4,
    #[doc = "< Implicit GEMM convolutions, fp32 only"]
    miopenConvolutionBwdDataAlgoImplicitGEMM = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenConvAlgorithm_t"]
#[doc = " Top-level convolutional algorithm mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenConvAlgorithm_t {
    #[doc = "< GEMM variant"]
    miopenConvolutionAlgoGEMM = 0,
    #[doc = "< Direct convolutions"]
    miopenConvolutionAlgoDirect = 1,
    #[doc = "< Fast Fourier Transform indirect convolutions"]
    miopenConvolutionAlgoFFT = 2,
    #[doc = "< Winograd indirect convolutions"]
    miopenConvolutionAlgoWinograd = 3,
    #[doc = "< Implicit GEMM convolutions, fp32 only"]
    miopenConvolutionAlgoImplicitGEMM = 5,
    #[doc = "< Static Compiled GEMM convolutions"]
    miopenConvolutionAlgoStaticCompiledGEMM = 6,
}
#[doc = " @brief Perf struct for forward, backward filter, or backward data algorithms"]
#[doc = ""]
#[doc = " Contains the union to hold the selected convolution algorithm for forward, or backwards layers,"]
#[doc = " and also contains the time it took to run the algorithm and the workspace required to run the"]
#[doc = " algorithm. The workspace in this structure can be used when executing the convolution layer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct miopenConvAlgoPerf_t {
    pub __bindgen_anon_1: miopenConvAlgoPerf_t__bindgen_ty_1,
    #[doc = "< Time to exectued the selected algorithm represented in the union"]
    pub time: f32,
    #[doc = "< Workspace required to run the selected algorithm represented in the union"]
    pub memory: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union miopenConvAlgoPerf_t__bindgen_ty_1 {
    #[doc = "< Forward convolution algorithm enum selection"]
    pub fwd_algo: miopenConvFwdAlgorithm_t,
    #[doc = "< Back propagation on weights"]
    #[doc = "convolution algorithm enum selection"]
    pub bwd_weights_algo: miopenConvBwdWeightsAlgorithm_t,
    #[doc = "< Back propagation on data convolution algorithm enum selection"]
    pub bwd_data_algo: miopenConvBwdDataAlgorithm_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_miopenConvAlgoPerf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<miopenConvAlgoPerf_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(miopenConvAlgoPerf_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenConvAlgoPerf_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(miopenConvAlgoPerf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<miopenConvAlgoPerf_t__bindgen_ty_1>())).fwd_algo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvAlgoPerf_t__bindgen_ty_1),
            "::",
            stringify!(fwd_algo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<miopenConvAlgoPerf_t__bindgen_ty_1>())).bwd_weights_algo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvAlgoPerf_t__bindgen_ty_1),
            "::",
            stringify!(bwd_weights_algo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<miopenConvAlgoPerf_t__bindgen_ty_1>())).bwd_data_algo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvAlgoPerf_t__bindgen_ty_1),
            "::",
            stringify!(bwd_data_algo)
        )
    );
}
#[test]
fn bindgen_test_layout_miopenConvAlgoPerf_t() {
    assert_eq!(
        ::std::mem::size_of::<miopenConvAlgoPerf_t>(),
        16usize,
        concat!("Size of: ", stringify!(miopenConvAlgoPerf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenConvAlgoPerf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(miopenConvAlgoPerf_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<miopenConvAlgoPerf_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvAlgoPerf_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<miopenConvAlgoPerf_t>())).memory as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvAlgoPerf_t),
            "::",
            stringify!(memory)
        )
    );
}
#[doc = " @brief Performance struct for forward, backward filter, or backward data algorithms in"]
#[doc = " immediate mode"]
#[doc = ""]
#[doc = " Contains a 64-bit integer identifying the solution and the algorithm for the solution,"]
#[doc = " as well as the runtime, workspace size and a boolean flag indicating whether the returned"]
#[doc = " solution is a heuristic or resulting from an actual run"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenConvSolution_t {
    #[doc = "< Represents the approximate time required to execute this solution on the GPU,"]
    #[doc = "in milliseconds. This value may either be based on an acutal kernel run or an"]
    #[doc = "estimate based on a heuristic."]
    pub time: f32,
    #[doc = "< Workspace required to run the selected algorithm represented in the"]
    #[doc = "union"]
    pub workspace_size: usize,
    #[doc = "< Identifier for the returned solution"]
    pub solution_id: u64,
    #[doc = "< The algorithm used to compute the solution"]
    pub algorithm: miopenConvAlgorithm_t,
}
#[test]
fn bindgen_test_layout_miopenConvSolution_t() {
    assert_eq!(
        ::std::mem::size_of::<miopenConvSolution_t>(),
        32usize,
        concat!("Size of: ", stringify!(miopenConvSolution_t))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenConvSolution_t>(),
        8usize,
        concat!("Alignment of ", stringify!(miopenConvSolution_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<miopenConvSolution_t>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvSolution_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<miopenConvSolution_t>())).workspace_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvSolution_t),
            "::",
            stringify!(workspace_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<miopenConvSolution_t>())).solution_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvSolution_t),
            "::",
            stringify!(solution_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<miopenConvSolution_t>())).algorithm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(miopenConvSolution_t),
            "::",
            stringify!(algorithm)
        )
    );
}
extern "C" {
    #[doc = " @brief Query the maximum number of solutions applicable for the given input/output and weights"]
    #[doc = "  tensor descriptor for Convolution in the Forward direction."]
    #[doc = ""]
    #[doc = " This call returns the maximum number of applicable solutions for a forward convolution problem."]
    #[doc = " The \\c solutionCount returned may be used to allocate the memory required for the"]
    #[doc = " \\c miopenConvAlgoPerf_t which is required by miopenConvolutionGetSolution API calls."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param xDesc          Tensor descriptor for input data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param solutionCount  Pointer to memory to return number of applicable solutions (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionForwardGetSolutionCount(
        handle: miopenHandle_t,
        wDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        yDesc: miopenTensorDescriptor_t,
        solutionCount: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the applicable solutions for a convolution configuration described by"]
    #[doc = "  input, output and convolution descriptors."]
    #[doc = ""]
    #[doc = "  The returned solutions array is sorted in the order of decreasing performance. The returned"]
    #[doc = " solutions"]
    #[doc = " might be based"]
    #[doc = "  on heuristics and for more consistent performance results the user the advised to run the Find"]
    #[doc = " step."]
    #[doc = "  The maximum length of the solutions array may be queried using"]
    #[doc = " miopenConvolutionForwardGetSolutionCount"]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param xDesc          Tensor descriptor for input data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param maxSolutionCount The size of the solutions array passed in below (input)"]
    #[doc = " @param solutionCount The size of the solutions array returned (output)"]
    #[doc = " @param solutions      A pointer to an array of type miopenConvSolution_t allocated by the user,"]
    #[doc = "                      filled in by MIOpen with applicable solutions. (output)"]
    #[doc = " @return               miopenStatus_t"]
    #[doc = ""]
    pub fn miopenConvolutionForwardGetSolution(
        handle: miopenHandle_t,
        wDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        yDesc: miopenTensorDescriptor_t,
        maxSolutionCount: usize,
        solutionCount: *mut usize,
        solutions: *mut miopenConvSolution_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Returns the workspace size required for a particular solution id."]
    #[doc = ""]
    #[doc = " This is an optional call for users who may have serialized the solution id and just need the"]
    #[doc = " workspace"]
    #[doc = " size for it. The same information is returned by the miopenConvolutionForwardGetSolution as part"]
    #[doc = " of the"]
    #[doc = " miopenConvSolution_t struct."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param xDesc          Tensor descriptor for input data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param solution_id      ID of the solution for which workspace size is required (input)"]
    #[doc = " @param workSpaceSize  The size of the workspace (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionForwardGetSolutionWorkspaceSize(
        handle: miopenHandle_t,
        wDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        yDesc: miopenTensorDescriptor_t,
        solution_id: u64,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Compiles the solution provided by the user, this solution may be acquired by the"]
    #[doc = " miopenConvolutionForwardGetSolution API call above."]
    #[doc = "   Compiling the solution ensures that the first API call to miopenConvolutionForwardImmediate"]
    #[doc = " does"]
    #[doc = " not cause a compile."]
    #[doc = ""]
    #[doc = "   This is an optional step and may be skipped if a slow first miopenConvolutionForwardImmediate"]
    #[doc = " invocation is acceptable."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param xDesc          Tensor descriptor for input data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param solution_id      ID of the solution to be compiled, as chosen by the user"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionForwardCompileSolution(
        handle: miopenHandle_t,
        wDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        yDesc: miopenTensorDescriptor_t,
        solution_id: u64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Executes the Forward convolution operation based on the provided solution ID."]
    #[doc = ""]
    #[doc = " Supported datatypes are fp32, fp16, bfp16, and int8"]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param w              Weights tensor w (input)"]
    #[doc = " @param xDesc          Tensor descriptor for input data tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y              Data tensor y (output)"]
    #[doc = " @param workSpace      Workspace tensor (input)"]
    #[doc = " @param workSpaceSize  Size of the memory in bytes pointed to by workSpace above"]
    #[doc = " @param solution_id      ID of the solution to be compiled, as chosen by the user"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionForwardImmediate(
        handle: miopenHandle_t,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
        solution_id: u64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the maximum number of solutions applicable for the given input/output and weights"]
    #[doc = "  tensor descriptor for backward Convolution w-r-t Data."]
    #[doc = ""]
    #[doc = "  This call returns the maximum number of applicable solutions for a the convolution problem, the"]
    #[doc = " number"]
    #[doc = "  returned may be used to allocate the memory required for the miopenConvAlgoPert2_t which is"]
    #[doc = " required"]
    #[doc = "  by miopenConvolutionBackwardDataGetSolution API calls."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param solutionCount  Pointer to memory to return number of applicable solutions (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardDataGetSolutionCount(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dxDesc: miopenTensorDescriptor_t,
        solutionCount: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the applicable solutions for a backward convolution w-r-t data as described by"]
    #[doc = "  input, output and convolution descriptors."]
    #[doc = ""]
    #[doc = "  The returned solutions array is sorted in the order of decreasing performance. The returned"]
    #[doc = " solutions"]
    #[doc = "  ns"]
    #[doc = " might be based"]
    #[doc = "  on heuristics and for more consistent performance results the user the advised to run the Find"]
    #[doc = " step."]
    #[doc = "  The maximum length of the solutions array may be queried using"]
    #[doc = " miopenConvolutionBackwardDataGetSolutionCount"]
    #[doc = ""]
    #[doc = " @param handle           MIOpen handle (input)"]
    #[doc = " @param dyDesc           Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param wDesc            Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param convDesc         Convolution layer descriptor (input)"]
    #[doc = " @param dxDesc           Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param maxSolutionCount The size of the solutions array passed in below (input)"]
    #[doc = " @param solutionCount    The size of the solutions array returned (output)"]
    #[doc = " @param solutions        A pointer to an array of type miopenConvSolution_t allocated by the user,"]
    #[doc = "                         filled in by MIOpen with applicable solutions. (output)"]
    #[doc = " @return                 miopenStatus_t"]
    #[doc = ""]
    pub fn miopenConvolutionBackwardDataGetSolution(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dxDesc: miopenTensorDescriptor_t,
        maxSolutionCount: usize,
        solutionCount: *mut usize,
        solutions: *mut miopenConvSolution_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Returns the workspace size required for a particular solution id."]
    #[doc = ""]
    #[doc = " This is an optional call for users who may have serialized the solution id and just need the"]
    #[doc = " workspace"]
    #[doc = " size for it. The same information is returned by the miopenConvolutionBackwardDataGetSolution as"]
    #[doc = " part of the"]
    #[doc = " miopenConvSolution_t struct."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc           Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param wDesc            Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param convDesc         Convolution layer descriptor (input)"]
    #[doc = " @param dxDesc           Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param solution_id      ID of the solution for which workspace size is required (input)"]
    #[doc = " @param workSpaceSize  The size of the workspace (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardDataGetSolutionWorkspaceSize(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dxDesc: miopenTensorDescriptor_t,
        solution_id: u64,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Compiles the solution provided by the user, this solution may be acquired by the"]
    #[doc = " miopenConvolutionBackwardDataGetSolution API call above."]
    #[doc = "   Compiling the solution ensures that the first API call to"]
    #[doc = " miopenConvolutionBackwardDataImmediate"]
    #[doc = " does not cause a compile."]
    #[doc = ""]
    #[doc = "   This is an optional step and may be skipped if a slow first"]
    #[doc = " miopenConvolutionBackwardDataImmediate"]
    #[doc = " invocation is acceptable."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param solution_id      ID of the solution to be compiled, as chosen by the user"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardDataCompileSolution(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dxDesc: miopenTensorDescriptor_t,
        solution_id: u64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Executes the Backward convolution w-r-t data  operation based on the provided solution"]
    #[doc = " ID."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param w              Weights tensor w (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param dx             Data delta tensor dx (output)"]
    #[doc = " @param workSpace      Workspace tensor (input)"]
    #[doc = " @param workSpaceSize  Size in bytes of the workspace memory pointed to by workSpace"]
    #[doc = " @param solution_id      ID of the solution to be compiled, as chosen by the user"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardDataImmediate(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
        solution_id: u64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the maximum number of solutions applicable for the given input/output and weights"]
    #[doc = "  tensor descriptor for backward Convolution w-r-t Weights."]
    #[doc = ""]
    #[doc = "  This call returns the maximum number of applicable solutions for a the convolution problem, the"]
    #[doc = " number"]
    #[doc = "  returned may be used to allocate the memory required for the miopenConvAlgoPert2_t which is"]
    #[doc = " required"]
    #[doc = "  by miopenConvolutionBackwardWeightsGetSolution API calls."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dwDesc         Tensor descriptor for weight tensor dw (input)"]
    #[doc = " @param solutionCount  Pointer to memory to return number of applicable solutions (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardWeightsGetSolutionCount(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dwDesc: miopenTensorDescriptor_t,
        solutionCount: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the applicable solutions for a backward convolution w-r-t weights as described by"]
    #[doc = "  input, output and convolution descriptors."]
    #[doc = ""]
    #[doc = "  The returned solutions array is sorted in the order of decreasing performance. The returned"]
    #[doc = " solutions"]
    #[doc = " might be based"]
    #[doc = "  on heuristics and for more consistent performance results the user the advised to run the Find"]
    #[doc = " step."]
    #[doc = "  The maximum length of the solutions array may be queried using"]
    #[doc = " miopenConvolutionBackwardWeightsGetSolutionCount"]
    #[doc = ""]
    #[doc = " @param handle           MIOpen handle (input)"]
    #[doc = " @param dyDesc           Tensor descriptor for data tensor dy (input)"]
    #[doc = " @param xDesc            Tensor descriptor for data tensor x (input)"]
    #[doc = " @param convDesc         Convolution layer descriptor (input)"]
    #[doc = " @param dwDesc           Tensor descriptor for weight tensor dw (input)"]
    #[doc = " @param maxSolutionCount The size of the solutions array passed in below (input)"]
    #[doc = " @param solutionCount    The size of the solutions array returned (output)"]
    #[doc = " @param solutions        A pointer to an array of type miopenConvSolution_t allocated by the user,"]
    #[doc = "                         filled in by MIOpen with applicable solutions. (output)"]
    #[doc = " @return                 miopenStatus_t"]
    #[doc = ""]
    pub fn miopenConvolutionBackwardWeightsGetSolution(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dwDesc: miopenTensorDescriptor_t,
        maxSolutionCount: usize,
        solutionCount: *mut usize,
        solutions: *mut miopenConvSolution_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Returns the workspace size required for a particular solution id."]
    #[doc = ""]
    #[doc = " This is an optional call for users who may have serialized the solution id and just need the"]
    #[doc = " workspace"]
    #[doc = " size for it. The same information is returned by the miopenConvolutionBackwardWeightsGetSolution"]
    #[doc = " as part of the"]
    #[doc = " miopenConvSolution_t struct."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dwDesc         Tensor descriptor for weight tensor dw (input)"]
    #[doc = " @param solution_id      ID of the solution for which workspace size is required (input)"]
    #[doc = " @param workSpaceSize  The size of the workspace (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardWeightsGetSolutionWorkspaceSize(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dwDesc: miopenTensorDescriptor_t,
        solution_id: u64,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Compiles the solution provided by the user, this solution may be acquired by the"]
    #[doc = " miopenConvolutionBackwardWeightsGetSolution API call above."]
    #[doc = "   Compiling the solution ensures that the first API call to"]
    #[doc = " miopenConvolutionBackwardWeightsImmediate"]
    #[doc = " does not cause a compile."]
    #[doc = ""]
    #[doc = "   This is an optional step and may be skipped if a slow first"]
    #[doc = " miopenConvolutionBackwardWeightsImmediate invocation is acceptable."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dwDesc         Tensor descriptor for weight tensor dw (input)"]
    #[doc = " @param solution_id      ID of the solution to be compiled, as chosen by the user"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardWeightsCompileSolution(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dwDesc: miopenTensorDescriptor_t,
        solution_id: u64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Executes the Backward convolution w-r-t weights  operation based on the provided solution"]
    #[doc = " ID."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dwDesc         Tensor descriptor for weight tensor dw (input)"]
    #[doc = " @param dw             Weights delta tensor dw (output)"]
    #[doc = " @param workSpace      Workspace tensor (input)"]
    #[doc = " @param workSpaceSize  Size in bytes of the memory passed in, pointed to by workSpace pointer"]
    #[doc = " above"]
    #[doc = " @param solution_id      ID of the solution to be compiled, as chosen by the user"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardWeightsImmediate(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        dwDesc: miopenTensorDescriptor_t,
        dw: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
        solution_id: u64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the workspace size required for a forward convolution layer"]
    #[doc = ""]
    #[doc = " This call is required and must be executed once before running"]
    #[doc = " miopenFindConvolutionForwardAlgorithm()"]
    #[doc = " in order to determine the largest required allocation for the algorithm search; i.e., the maximum"]
    #[doc = " size"]
    #[doc = " of the memory needed from the set of potential forward convolution algorithm is returned."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param xDesc          Tensor descriptor for input data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param workSpaceSize  Pointer to memory to return size in bytes (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionForwardGetWorkSpaceSize(
        handle: miopenHandle_t,
        wDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        yDesc: miopenTensorDescriptor_t,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Search and run the forward convolutional algorithms and return a list of kernel times."]
    #[doc = ""]
    #[doc = " This function attempts all MIOpen forward convolution algorithms based on"]
    #[doc = " the input configuration, and outputs performance metrics to a"]
    #[doc = " user-allocated array of type miopenConvAlgoPerf_t. These metrics are written"]
    #[doc = " in a sorted fashion where the first element has the lowest compute time."]
    #[doc = " Users can chose the top-most algorithm if they only care about the fastest"]
    #[doc = " algorithm."]
    #[doc = ""]
    #[doc = " This function is mandatory before using miopenConvolutionForward(). In order"]
    #[doc = " to execute this function, miopenConvolutionForwardGetWorkSpaceSize() must be"]
    #[doc = " run to determine the required memory for this search."]
    #[doc = ""]
    #[doc = " * If exhaustiveSearch == 0, MIOpen will look for the first kernel with a configuration match. If"]
    #[doc = " a configuration match is not found, a default configuration will be returned."]
    #[doc = ""]
    #[doc = " * If exhaustiveSearch == 1, MIOpen will look for the best kernel for the provided configuration."]
    #[doc = " If a match is not found, an exhaustive search is performed by running individual algorithms."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle             MIOpen handle (input)"]
    #[doc = " @param xDesc              Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x                  Data tensor x (input)"]
    #[doc = " @param wDesc              Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param w                  Weights tensor w (input)"]
    #[doc = " @param convDesc           Convolution layer descriptor (input)"]
    #[doc = " @param yDesc              Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y                  Data tensor y (output)"]
    #[doc = " @param requestAlgoCount   Number of algorithms to return kernel times (input)"]
    #[doc = " @param returnedAlgoCount  Pointer to number of algorithms returned (output)"]
    #[doc = " @param perfResults        Pointer to union of best algorithm for forward and backwards (input)"]
    #[doc = " @param workSpace          Pointer to workspace required for the search (output)"]
    #[doc = " @param workSpaceSize      Size in bytes of the memory needed for find (output)"]
    #[doc = " @param exhaustiveSearch   A boolean to toggle a full search of all algorithms and configurations"]
    #[doc = " (input)"]
    #[doc = " @return                   miopenStatus_t"]
    pub fn miopenFindConvolutionForwardAlgorithm(
        handle: miopenHandle_t,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        requestAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut miopenConvAlgoPerf_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
        exhaustiveSearch: bool,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a forward convolution layer"]
    #[doc = ""]
    #[doc = " Runs the forward convolution layer based on the selected algorithm. The function"]
    #[doc = " miopenFindConvolutionForwardAlgorithm() must have been executed previously to"]
    #[doc = " determine the required memory needed for the workspace and the best convolutional algorithm."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param w              Weights tensor w (inputs)"]
    #[doc = " @param convDesc       Convolution layer descriptor (inputs)"]
    #[doc = " @param algo           Algorithm selected (inputs)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y              Data tensor y (output)"]
    #[doc = " @param workSpace      Pointer to workspace required (input)"]
    #[doc = " @param workSpaceSize  Size in bytes of the memory determined by the find step (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionForward(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        algo: miopenConvFwdAlgorithm_t,
        beta: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Calculate element-wise scale and shift of a tensor via a bias tensor"]
    #[doc = ""]
    #[doc = "  This function applies an element-wise bias to a data tensor from an input bias tensor."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param bDesc          Tensor descriptor for bias tensor b (input)"]
    #[doc = " @param b              Bias tensor b (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for data tensor y (input)"]
    #[doc = " @param y              Data tensor y (input and output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionForwardBias(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        bDesc: miopenTensorDescriptor_t,
        b: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the GPU memory required for the backward data convolution algorithm."]
    #[doc = ""]
    #[doc = " For a provided tensor descriptors and algorithm selection, this function calculates and returns"]
    #[doc = " the workspace size required for back propagation on data. This call is required and must be"]
    #[doc = " executed once before running miopenFindConvolutionBackwardDataAlgorithm() in order to determine"]
    #[doc = " the largest required allocation for the algorithm search; i.e., the maximum size of the memory"]
    #[doc = " needed from the set of potential backward convolution algorithm is returned."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param workSpaceSize  Size in bytes of the memory required (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardDataGetWorkSpaceSize(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dxDesc: miopenTensorDescriptor_t,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Search and run the backwards data convolution algorithms and return a list of kernel"]
    #[doc = " times."]
    #[doc = ""]
    #[doc = " This function attempts all MIOpen backward data convolution algorithms, and outputs the"]
    #[doc = " performance metrics to a user-allocated array of type miopenConvAlgoPerf_t."]
    #[doc = " These metrics are written in sorted fashion where the first element has the lowest compute time."]
    #[doc = " This function is mandatory before using backwards convolutions. Users can chose the top-most"]
    #[doc = " algorithm if they only care about the fastest algorithm."]
    #[doc = ""]
    #[doc = " This function is mandatory before using miopenConvolutionBackwardData(). In order to"]
    #[doc = " execute this function, miopenConvolutionBackwardsDataGetWorkSpaceSize() must be run to determine"]
    #[doc = " the required memory for this search."]
    #[doc = ""]
    #[doc = " * If exhaustiveSearch == 0, MIOpen will look for the first kernel with a configuration match. If"]
    #[doc = " a configuration match is not found, a default configuration will be returned."]
    #[doc = ""]
    #[doc = " * If exhaustiveSearch == 1, MIOpen will look for the best kernel for the provided configuration."]
    #[doc = " If a match is not found, an exhaustive search is performed by running individual algorithms."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle             MIOpen handle (input)"]
    #[doc = " @param dyDesc             Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param dy                 Data delta tensor dy (input)"]
    #[doc = " @param wDesc              Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param w                  Weights tensor w (input)"]
    #[doc = " @param convDesc           Convolution layer descriptor (input)"]
    #[doc = " @param dxDesc             Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param dx                 Data delta tensor dx (input)"]
    #[doc = " @param requestAlgoCount   Number of algorithms to return kernel times (input)"]
    #[doc = " @param returnedAlgoCount  Pointer to number of algorithms returned (output)"]
    #[doc = " @param perfResults        Pointer to union of best algorithm for forward and backwards (output)"]
    #[doc = " @param workSpace          Pointer to workspace required for the search (output)"]
    #[doc = " @param workSpaceSize      Size in bytes of the memory needed for find (output)"]
    #[doc = " @param exhaustiveSearch   A boolean to toggle a full search of all algorithms and configurations"]
    #[doc = " (input)"]
    #[doc = " @return                   miopenStatus_t"]
    pub fn miopenFindConvolutionBackwardDataAlgorithm(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        requestAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut miopenConvAlgoPerf_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
        exhaustiveSearch: bool,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a backward data convolution layer"]
    #[doc = ""]
    #[doc = " Runs the backward data convolution layer based on the selected algorithm. The function"]
    #[doc = " miopenFindConvolutionBackwardDataAlgorithm() must have been executed previously to"]
    #[doc = " determine the required memory needed for the workspace and the best convolutional"]
    #[doc = " algorithm."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param wDesc          Tensor descriptor for weight tensor w (input)"]
    #[doc = " @param w              Weights tensor w (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param algo           Algorithm selected (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param dx             Data delta tensor dx (output)"]
    #[doc = " @param workSpace      Pointer to workspace required for the search (input)"]
    #[doc = " @param workSpaceSize  Size in bytes of the memory needed for find (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardData(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        algo: miopenConvBwdDataAlgorithm_t,
        beta: *const ::libc::c_void,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the GPU memory required for the backward weights convolution algorithm."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " For a provided tensor descriptors and algorithm selection, this function calculates and returns"]
    #[doc = " the workspace size required for back propagation on data. This call is required and must be"]
    #[doc = " executed once before running miopenFindConvolutionBackwardWeightsAlgorithm() in order to"]
    #[doc = " determine"]
    #[doc = " the largest required allocation for the algorithm search; i.e., the maximum size of the memory"]
    #[doc = " needed from the set of potential backward weights convolution algorithm is returned."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param dwDesc         Tensor descriptor for output weights tensor dw (input)"]
    #[doc = " @param workSpaceSize  Size in bytes of the memory required (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardWeightsGetWorkSpaceSize(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        dwDesc: miopenTensorDescriptor_t,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Search and run the backwards weights convolutional algorithms and return a list of kernel"]
    #[doc = " times."]
    #[doc = ""]
    #[doc = " This function attempts all MIOpen backward weights convolution algorithms, and outputs"]
    #[doc = " the performance metrics to a user-allocated array of type miopenConvAlgoPerf_t. These metrics are"]
    #[doc = " written in sorted fashion where the first element has the lowest compute time."]
    #[doc = " This function is mandatory before using backwards weight convolutions. Users can chose the"]
    #[doc = " top-most algorithm if they only care about the fastest algorithm."]
    #[doc = ""]
    #[doc = " This function is mandatory before using miopenConvolutionBackwardWeights(). In order to"]
    #[doc = " execute this function, miopenConvolutionBackwardsWeightsGetWorkSpaceSize() must be run to"]
    #[doc = " determine the required memory for this search."]
    #[doc = ""]
    #[doc = " * If exhaustiveSearch == 0, MIOpen will look for the first kernel with a configuration match. If"]
    #[doc = " a configuration match is not found, a default configuration will be returned."]
    #[doc = ""]
    #[doc = " * If exhaustiveSearch == 1, MIOpen will look for the best kernel for the provided configuration."]
    #[doc = " If a match is not found, an exhaustive search is performed by running individual algorithms."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle             MIOpen handle (input)"]
    #[doc = " @param dyDesc             Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param dy                 Data delta tensor dy (input)"]
    #[doc = " @param xDesc              Tensor descriptor for output data tensor x (input)"]
    #[doc = " @param x                  Data delta tensor dx (input)"]
    #[doc = " @param convDesc           Convolution layer descriptor (input)"]
    #[doc = " @param dwDesc             Tensor descriptor for weight tensor dw (input)"]
    #[doc = " @param dw                 Weights delta tensor dw (input)"]
    #[doc = " @param requestAlgoCount   Number of algorithms to return kernel times (input)"]
    #[doc = " @param returnedAlgoCount  Pointer to number of algorithms returned (output)"]
    #[doc = " @param perfResults        Pointer to union of best algorithm for forward and backwards (output)"]
    #[doc = " @param workSpace          Pointer to workspace required for the search (output)"]
    #[doc = " @param workSpaceSize      Size in bytes of the memory needed for find (output)"]
    #[doc = " @param exhaustiveSearch   A boolean to toggle a full search of all algorithms and configurations"]
    #[doc = " (input)"]
    #[doc = " @return                   miopenStatus_t"]
    pub fn miopenFindConvolutionBackwardWeightsAlgorithm(
        handle: miopenHandle_t,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        dwDesc: miopenTensorDescriptor_t,
        dw: *mut ::libc::c_void,
        requestAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        perfResults: *mut miopenConvAlgoPerf_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
        exhaustiveSearch: bool,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a backward weights convolution layer"]
    #[doc = ""]
    #[doc = " Runs the backward weights convolution layer based on the selected algorithm. The function"]
    #[doc = " miopenFindConvolutionBackwardWeightsAlgorithm() must have"]
    #[doc = " been executed previously to determine the required memory needed for the workspace and the"]
    #[doc = " best convolutional algorithm."]
    #[doc = ""]
    #[doc = " If using Group/Depthwise convolution mode, call miopenSetConvolutionGroupCount() before running"]
    #[doc = " this."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param algo           Algorithm selected (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param dwDesc         Tensor descriptor for weight tensor dw (input)"]
    #[doc = " @param dw             Weights delta tensor dw (output)"]
    #[doc = " @param workSpace      Pointer to workspace required for the search (input)"]
    #[doc = " @param workSpaceSize  Size in bytes of the memory needed for find (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardWeights(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        convDesc: miopenConvolutionDescriptor_t,
        algo: miopenConvBwdWeightsAlgorithm_t,
        beta: *const ::libc::c_void,
        dwDesc: miopenTensorDescriptor_t,
        dw: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Calculates the gradient with respect to the bias."]
    #[doc = ""]
    #[doc = " Compute the convolution backwards gradient with respect to the bias tensor."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param dbDesc         Tensor descriptor for input bias tensor db (input)"]
    #[doc = " @param db             Bias delta tensor db (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenConvolutionBackwardBias(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dbDesc: miopenTensorDescriptor_t,
        db: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a pooling layer descriptor"]
    #[doc = ""]
    #[doc = " @param poolDesc   Pointer to a pooling layer descriptor (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenCreatePoolingDescriptor(
        poolDesc: *mut miopenPoolingDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set index data type for pooling layer. The default indexing type is uint8_t."]
    #[doc = " Users can set the index type to any of the miopenIndexType_t sizes; 8, 16, 32, or 64 bit"]
    #[doc = " unsigned integers."]
    #[doc = ""]
    #[doc = " @param poolDesc     Pointer to a pooling layer descriptor (input)"]
    #[doc = " @param index_type   Index type (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenSetPoolingIndexType(
        poolDesc: miopenPoolingDescriptor_t,
        index_type: miopenIndexType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the index data type for pooling layer. The index type to any of the"]
    #[doc = " miopenIndexType_t sizes; 8, 16, 32, or 64 bit unsigned integers."]
    #[doc = ""]
    #[doc = " @param poolDesc     Pointer to a pooling layer descriptor (input)"]
    #[doc = " @param index_type   Index type (output)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenGetPoolingIndexType(
        poolDesc: miopenPoolingDescriptor_t,
        index_type: *mut miopenIndexType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets a 2-D pooling layer descriptor details."]
    #[doc = ""]
    #[doc = " Sets the window shape, padding, and stride for a previously created 2-D pooling descriptor."]
    #[doc = ""]
    #[doc = " @param poolDesc       Pointer to a pooling layer descriptor (output)"]
    #[doc = " @param mode           Pooling mode enum (input)"]
    #[doc = " @param windowHeight   Input window height dimension (input)"]
    #[doc = " @param windowWidth    Input window width dimension (input)"]
    #[doc = " @param pad_h          Number of elements to pad height (input)"]
    #[doc = " @param pad_w          Number of elements to pad width (input)"]
    #[doc = " @param stride_h       Vertical stride (input)"]
    #[doc = " @param stride_w       Horizontal stride (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenSet2dPoolingDescriptor(
        poolDesc: miopenPoolingDescriptor_t,
        mode: miopenPoolingMode_t,
        windowHeight: ::libc::c_int,
        windowWidth: ::libc::c_int,
        pad_h: ::libc::c_int,
        pad_w: ::libc::c_int,
        stride_h: ::libc::c_int,
        stride_w: ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets a 2-D pooling layer descriptor details"]
    #[doc = ""]
    #[doc = " Gets the window shape, padding, and stride for a previously created 2-D pooling descriptor."]
    #[doc = ""]
    #[doc = " @param poolDesc       Pointer to a pooling layer descriptor (input)"]
    #[doc = " @param mode           Pooling mode enum (output)"]
    #[doc = " @param windowHeight   Input window height dimension (output)"]
    #[doc = " @param windowWidth    Input window width dimension (output)"]
    #[doc = " @param pad_h          Number of elements to pad height (output)"]
    #[doc = " @param pad_w          Number of elements to pad width (output)"]
    #[doc = " @param stride_h       Vertical stride (output)"]
    #[doc = " @param stride_w       Horizontal stride (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenGet2dPoolingDescriptor(
        poolDesc: miopenPoolingDescriptor_t,
        mode: *mut miopenPoolingMode_t,
        windowHeight: *mut ::libc::c_int,
        windowWidth: *mut ::libc::c_int,
        pad_h: *mut ::libc::c_int,
        pad_w: *mut ::libc::c_int,
        stride_h: *mut ::libc::c_int,
        stride_w: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets the shape of the output tensor for 2-D pooling"]
    #[doc = ""]
    #[doc = " Retrieve the tensor dimensions for the forward 2-D pooling. This call is required for"]
    #[doc = " the forward if the output dimensions are different than the input tensor"]
    #[doc = " dimensions."]
    #[doc = ""]
    #[doc = " @param poolDesc   Pointer to a pooling layer descriptor (input)"]
    #[doc = " @param tensorDesc Input tensor descriptor (input)"]
    #[doc = " @param n\t         Mini-batch dim (output)"]
    #[doc = " @param c\t         Number of channels (output)"]
    #[doc = " @param h          Heights of input map (output)"]
    #[doc = " @param w          Width of input map (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGetPoolingForwardOutputDim(
        poolDesc: miopenPoolingDescriptor_t,
        tensorDesc: miopenTensorDescriptor_t,
        n: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set details of a N-D pooling layer descriptor"]
    #[doc = ""]
    #[doc = " Set the window shape, padding, and stride for a previously created N-D pooling descriptor."]
    #[doc = ""]
    #[doc = " @param poolDesc     Pointer to a pooling layer descriptor (input/output)"]
    #[doc = " @param mode         Pooling mode enum (input)"]
    #[doc = " @param nbDims       Dimension of the pooling (input)"]
    #[doc = " @param windowDimA   Array of input window dimensions with length equal to or larger than"]
    #[doc = " dimsRequested (input)"]
    #[doc = " @param padA         Array of number of elements to padding with length equal to or larger than"]
    #[doc = " dimsRequested (input)"]
    #[doc = " @param stridesA     Array of stride parameter with length equal to or larger than dimsRequested"]
    #[doc = " (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenSetNdPoolingDescriptor(
        poolDesc: miopenPoolingDescriptor_t,
        mode: miopenPoolingMode_t,
        nbDims: ::libc::c_int,
        windowDimA: *mut ::libc::c_int,
        padA: *mut ::libc::c_int,
        stridesA: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get details of a N-D pooling layer descriptor"]
    #[doc = ""]
    #[doc = " Get the window shape, padding, and stride for a previously created N-D pooling descriptor."]
    #[doc = ""]
    #[doc = " @param poolDesc         Pointer to a pooling layer descriptor (input)"]
    #[doc = " @param nbDimsRequested  Dimension of the expected pooling descriptor (input)"]
    #[doc = " @param mode             Pooling mode enum (output)"]
    #[doc = " @param nbDims           Actual dimension of the pooling descriptor (output)"]
    #[doc = " @param windowDimA       Array of input window dimensions with length equal to or larger than"]
    #[doc = " dimsRequested (output)"]
    #[doc = " @param padA             Array of number of elements to padding with length equal to or larger"]
    #[doc = " than dimsRequested (output)"]
    #[doc = " @param stridesA         Array of stride parameter with length equal to or larger than"]
    #[doc = " dimsRequested (output)"]
    #[doc = " @return                 miopenStatus_t"]
    pub fn miopenGetNdPoolingDescriptor(
        poolDesc: miopenPoolingDescriptor_t,
        nbDimsRequested: ::libc::c_int,
        mode: *mut miopenPoolingMode_t,
        nbDims: *mut ::libc::c_int,
        windowDimA: *mut ::libc::c_int,
        padA: *mut ::libc::c_int,
        stridesA: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets the shape of the output tensor for N-D pooling"]
    #[doc = ""]
    #[doc = " Retrieve the tensor dimensions for the forward N-D pooling. This call is required for"]
    #[doc = " the forward if the output dimensions are different than the input tensor"]
    #[doc = " dimensions."]
    #[doc = ""]
    #[doc = " @param poolDesc      Pointer to a pooling layer descriptor (input)"]
    #[doc = " @param tensorDesc    Input tensor descriptor (input)"]
    #[doc = " @param dims          Dimension of the pooling (input)"]
    #[doc = " @param tensorDimArr  Array of tensor dimension (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGetPoolingNdForwardOutputDim(
        poolDesc: miopenPoolingDescriptor_t,
        tensorDesc: miopenTensorDescriptor_t,
        dims: ::libc::c_int,
        tensorDimArr: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the amount of GPU memory required for pooling"]
    #[doc = ""]
    #[doc = " Retrieves the amount of workspace in bytes require for pooling. This call is required to"]
    #[doc = " determine the amount of GPU memory needed for the backwards pooling algorithms. For max-"]
    #[doc = " pooling, an assumption is that index data type is uint8_t, therefore the returned"]
    #[doc = " workspace size will be based on this assumption even if the user sets the index type with"]
    #[doc = " miopenSetPoolingIndexType()."]
    #[doc = ""]
    #[doc = " @param yDesc          Descriptor for pooling layer (input)"]
    #[doc = " @param workSpaceSize  Pointer to workSpaceSize (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenPoolingGetWorkSpaceSize(
        yDesc: miopenTensorDescriptor_t,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the amount of GPU memory required for pooling"]
    #[doc = ""]
    #[doc = " Retrieves the amount of workspace in bytes require for pooling. This call is required to"]
    #[doc = " determine the amount of GPU memory needed for the backwards pooling algorithms. For max-"]
    #[doc = " pooling, there is no assumption on index data type. As the user can set the index datatype"]
    #[doc = " size using miopenSetPoolingIndexType()."]
    #[doc = ""]
    #[doc = " @param poolDesc       Pointer to a pooling layer descriptor (input)"]
    #[doc = " @param yDesc          Descriptor for pooling layer (input)"]
    #[doc = " @param workSpaceSize  Pointer to workSpaceSize (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenPoolingGetWorkSpaceSizeV2(
        poolDesc: miopenPoolingDescriptor_t,
        yDesc: miopenTensorDescriptor_t,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a forward pooling layer"]
    #[doc = ""]
    #[doc = " Runs forward pooling. miopenGetPoolingForwardOutputDim() should be called before"]
    #[doc = " miopenPoolingForward()."]
    #[doc = " If the parameter do_backward == 0, then set workSpace = nullptr and workSpaceSize = 0. However,"]
    #[doc = " for back-propagation do_backwards must be set to 1 in miopenPoolingForward()."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param poolDesc       Descriptor for pooling layer (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y              Data tensor y (output)"]
    #[doc = " @param do_backward    Boolean to toggle save data in workspace for backwards pass (input)"]
    #[doc = " @param workSpace      Pointer user allocated memory (input)"]
    #[doc = " @param workSpaceSize  Size in bytes of the memory needed (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenPoolingForward(
        handle: miopenHandle_t,
        poolDesc: miopenPoolingDescriptor_t,
        alpha: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        do_backward: bool,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a backward pooling layer"]
    #[doc = ""]
    #[doc = " Runs backward pooling. miopenPoolingGetWorkSpaceSize() must be called before"]
    #[doc = " miopenPoolingBackward() to determine the amount of workSpace to be allocated."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param poolDesc       Descriptor for pooling layer (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y              Data tensor y (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for output data tensor x (input)"]
    #[doc = " @param x              Data tensor x (output)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for tensor dx (input)"]
    #[doc = " @param dx             Weights delta tensor dx (output)"]
    #[doc = " @param workSpace      Pointer to user allocated workspace (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenPoolingBackward(
        handle: miopenHandle_t,
        poolDesc: miopenPoolingDescriptor_t,
        alpha: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        workSpace: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys the pooling descriptor object"]
    #[doc = ""]
    #[doc = " @param poolDesc Pooling tensor descriptor type (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenDestroyPoolingDescriptor(poolDesc: miopenPoolingDescriptor_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @addtogroup LRN"]
    #[doc = ""]
    #[doc = "  @{"]
    #[doc = ""]
    #[doc = " @param lrnDesc    Pointer to a local response normalization layer descriptor type"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenCreateLRNDescriptor(lrnDesc: *mut miopenLRNDescriptor_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets a LRN layer descriptor details"]
    #[doc = ""]
    #[doc = " Sets all of the descriptor details for the LRN layer. The number of window elements lrnN is"]
    #[doc = " a diameter and always odd."]
    #[doc = ""]
    #[doc = " @param lrnDesc      Pointer to a LRN layer descriptor (output)"]
    #[doc = " @param mode         LRN mode enum (input)"]
    #[doc = " @param lrnN         Number of normalization window elements (input)"]
    #[doc = " @param lrnAlpha     Scaling factor (input)"]
    #[doc = " @param lrnBeta      Shift factor (input)"]
    #[doc = " @param lrnK         K factor (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenSetLRNDescriptor(
        lrnDesc: miopenLRNDescriptor_t,
        mode: miopenLRNMode_t,
        lrnN: ::libc::c_uint,
        lrnAlpha: f64,
        lrnBeta: f64,
        lrnK: f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets a LRN layer descriptor details"]
    #[doc = ""]
    #[doc = " Retrieve the LRN descriptor details."]
    #[doc = ""]
    #[doc = " @param lrnDesc      Pointer to a LRN layer descriptor (input)"]
    #[doc = " @param mode         LRN mode enum (output)"]
    #[doc = " @param lrnN         Number of normalization window elements (output)"]
    #[doc = " @param lrnAlpha     Scaling factor (output)"]
    #[doc = " @param lrnBeta      Shift factor (output)"]
    #[doc = " @param lrnK         K factor (output)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenGetLRNDescriptor(
        lrnDesc: miopenLRNDescriptor_t,
        mode: *mut miopenLRNMode_t,
        lrnN: *mut ::libc::c_uint,
        lrnAlpha: *mut f64,
        lrnBeta: *mut f64,
        lrnK: *mut f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Determine the workspace requirements."]
    #[doc = ""]
    #[doc = " This function determines the GPU memory allocation required to execute the LRN layer based on the"]
    #[doc = " LRN descriptor."]
    #[doc = ""]
    #[doc = " @param yDesc           Pointer to a LRN layer descriptor (input)"]
    #[doc = " @param workSpaceSize   Output variable for workspace size (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenLRNGetWorkSpaceSize(
        yDesc: miopenTensorDescriptor_t,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a LRN forward layer"]
    #[doc = ""]
    #[doc = " Runs the forward layer normalization in the forward direction. If do_backward == 0, then"]
    #[doc = " set workSpace = nullptr and workSpaceSize = 0. However, if the user wishes to execute backwards,"]
    #[doc = " then they must set do_backwards = 1 in miopenLRNForward()."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param lrnDesc        Descriptor for LRN layer (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y              Data tensor y (output)"]
    #[doc = " @param do_backward    Boolean to toggle save data in workspace for backwards pass (input)"]
    #[doc = " @param workSpace      Pointer user allocated memory (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenLRNForward(
        handle: miopenHandle_t,
        lrnDesc: miopenLRNDescriptor_t,
        alpha: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        do_backward: bool,
        workSpace: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a LRN backward layer"]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param lrnDesc        Descriptor for LRN layer (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for data input tensor y (input)"]
    #[doc = " @param y              Data tensor y (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for data input tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for input data tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for output data tensor dx(input)"]
    #[doc = " @param dx             Data delta tensor x (output)"]
    #[doc = " @param workSpace      Pointer user allocated memory (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenLRNBackward(
        handle: miopenHandle_t,
        lrnDesc: miopenLRNDescriptor_t,
        alpha: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        workSpace: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys the LRN descriptor object"]
    #[doc = ""]
    #[doc = " @param lrnDesc   LRN tensor descriptor type (input)"]
    #[doc = " @return          miopenStatus_t"]
    pub fn miopenDestroyLRNDescriptor(lrnDesc: miopenLRNDescriptor_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Derive tensor for gamma and beta from input tensor descriptor"]
    #[doc = ""]
    #[doc = " This function takes the input tensor descriptor and outputs a derived tensor for the"]
    #[doc = " normalization scale (gamma) and shift (beta) tensors."]
    #[doc = ""]
    #[doc = " For an input tensor NCHW and spatial mode, the output derived tensor is 1C11, while for"]
    #[doc = " per-activation the derived tensor is 1CHW."]
    #[doc = ""]
    #[doc = " For an input tensor NCDHW and spatial mode, the output derived tensor is 1C111, while for"]
    #[doc = " per-activation the derived tensor is 1CDHW."]
    #[doc = ""]
    #[doc = " @param derivedBnDesc   Output derived tensor descriptor (output)"]
    #[doc = " @param xDesc           Input tensor descriptor (input)"]
    #[doc = " @param bn_mode         Batch Normalization mode (input)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenDeriveBNTensorDescriptor(
        derivedBnDesc: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        bn_mode: miopenBatchNormMode_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute forward training layer for batch normalization"]
    #[doc = ""]
    #[doc = " Batch normalization pass for forward training pass."]
    #[doc = " Takes in batch normalization mode bn_mode and input tensor x, output tensor y, bnBias and bnScale"]
    #[doc = " with their descriptor."]
    #[doc = ""]
    #[doc = " If either resultSaveMean, or resultSaveInvVariance are null pointers then the values for the mean"]
    #[doc = " and inverse variance will not be used."]
    #[doc = ""]
    #[doc = " Likewise, if either resultRunningMean, or resultRunningVariance are null pointers then the values"]
    #[doc = " for the running mean and variance will not be saved."]
    #[doc = " Running averages and variances are scaled using an exponential averaging factor: \\f["]
    #[doc = " \\mu_{old} = \\mu_{new}*factor + \\mu_{old}*(1-factor)"]
    #[doc = " \\f]"]
    #[doc = " where \\f["]
    #[doc = " factor=1/(1+iteration)"]
    #[doc = " \\f]"]
    #[doc = ""]
    #[doc = " @param handle                    MIOpen handle (input)"]
    #[doc = " @param bn_mode                   Batch normalization mode (input)"]
    #[doc = " @param alpha                     Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta                      Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param xDesc                     Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x                         Data tensor x (input)"]
    #[doc = " @param yDesc                     Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y                         Data tensor y (output)"]
    #[doc = " @param bnScaleBiasMeanVarDesc    Tensor descriptor for BN scaling, shifting, saved variance and"]
    #[doc = " mean (input)"]
    #[doc = " @param bnScale                   Batch norm scaling, gamma, tensor (input)"]
    #[doc = " @param bnBias                    Batch norm bias, beta, tensor (input)"]
    #[doc = " @param expAvgFactor              Exponential averaging factor (input)"]
    #[doc = " @param resultRunningMean         Running average saved for inference (output)"]
    #[doc = " @param resultRunningVariance     Running variance saved for inference (output)"]
    #[doc = " @param epsilon                   Value to stablize inverse variance calculation (input)"]
    #[doc = " @param resultSaveMean            Saved mini-batch mean for backwards pass (output)"]
    #[doc = " @param resultSaveInvVariance     Saved mini-batch inverse variance for backwards pass (output)"]
    #[doc = " @return                          miopenStatus_t"]
    pub fn miopenBatchNormalizationForwardTraining(
        handle: miopenHandle_t,
        bn_mode: miopenBatchNormMode_t,
        alpha: *mut ::libc::c_void,
        beta: *mut ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        bnScaleBiasMeanVarDesc: miopenTensorDescriptor_t,
        bnScale: *mut ::libc::c_void,
        bnBias: *mut ::libc::c_void,
        expAvgFactor: f64,
        resultRunningMean: *mut ::libc::c_void,
        resultRunningVariance: *mut ::libc::c_void,
        epsilon: f64,
        resultSaveMean: *mut ::libc::c_void,
        resultSaveInvVariance: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute forward inference layer for batch normalization"]
    #[doc = ""]
    #[doc = " Batch normalization pass for forward inference pass."]
    #[doc = " Takes in batch normalization mode bn_mode and input tensor x, output tensor y, bnBias and bnScale"]
    #[doc = " with their descriptor."]
    #[doc = ""]
    #[doc = " If either estimatedMean, or estimatedVariance are null pointers then the values for the mean and"]
    #[doc = " variance will not be used."]
    #[doc = ""]
    #[doc = " @param handle                    MIOpen handle (input)"]
    #[doc = " @param bn_mode                   Batch normalization mode (input)"]
    #[doc = " @param alpha                     Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta                      Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param xDesc                     Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x                         Data tensor x (input)"]
    #[doc = " @param yDesc                     Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y                         Data tensor y (output)"]
    #[doc = " @param bnScaleBiasMeanVarDesc    Tensor descriptor for BN scaling, shifting, saved variance and"]
    #[doc = " mean (input)"]
    #[doc = " @param bnScale                   Batch norm scaling, gamma, tensor (input)"]
    #[doc = " @param bnBias                    Batch norm bias, beta, tensor (input)"]
    #[doc = " @param estimatedMean             Running average saved during forward training (input)"]
    #[doc = " @param estimatedVariance         Running variance saved during forward training (input)"]
    #[doc = " @param epsilon                   Value to stabilize inverse variance calculation (input)"]
    #[doc = " @return                          miopenStatus_t"]
    pub fn miopenBatchNormalizationForwardInference(
        handle: miopenHandle_t,
        bn_mode: miopenBatchNormMode_t,
        alpha: *mut ::libc::c_void,
        beta: *mut ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        bnScaleBiasMeanVarDesc: miopenTensorDescriptor_t,
        bnScale: *mut ::libc::c_void,
        bnBias: *mut ::libc::c_void,
        estimatedMean: *mut ::libc::c_void,
        estimatedVariance: *mut ::libc::c_void,
        epsilon: f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute backwards propagation layer for batch normalization"]
    #[doc = ""]
    #[doc = " Batch normalization pass for backwards propagation training pass."]
    #[doc = " The method for backwards propagation batch normalization."]
    #[doc = ""]
    #[doc = " Takes in batch normalization mode bn_mode and input tensor data x, input activation tensor dy,"]
    #[doc = " output tensor dx, the learned tensors resultBNBiasDiff and resultBNScaleDiff with their"]
    #[doc = " descriptor."]
    #[doc = ""]
    #[doc = " If BOTH savedMean, and savedVariance are not null pointers then the method will use the saved"]
    #[doc = " mean and variance calculated by the forward training phase."]
    #[doc = ""]
    #[doc = " @param handle                    MIOpen handle (input)"]
    #[doc = " @param bn_mode                   Batch normalization mode (input)"]
    #[doc = " @param alphaDataDiff             Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param betaDataDiff              Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param alphaParamDiff            Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param betaParamDiff             Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param xDesc                     Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x                         Data tensor x (input)"]
    #[doc = " @param dyDesc                    Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param dy                        Data tensor y (input)"]
    #[doc = " @param dxDesc                    Tensor descriptor for output data tensor dx (input)"]
    #[doc = " @param dx                        Data delta tensor dx (output)"]
    #[doc = " @param bnScaleBiasDiffDesc       Tensor descriptor for BN scaling, shifting, saved variance and"]
    #[doc = " mean (input)"]
    #[doc = " @param bnScale                   Batch norm scaling, gamma, tensor (input)"]
    #[doc = " @param resultBnScaleDiff         Tensor for dscale (output)"]
    #[doc = " @param resultBnBiasDiff          Tensor for dbias (output)"]
    #[doc = " @param epsilon                   Value to stabilize inverse variance calculation (input)"]
    #[doc = " @param savedMean                 Saved mini-batch mean for backwards pass (input)"]
    #[doc = " @param savedInvVariance          Saved mini-bathc inverse variance for backwards pass (input)"]
    #[doc = " @return                          miopenStatus_t"]
    pub fn miopenBatchNormalizationBackward(
        handle: miopenHandle_t,
        bn_mode: miopenBatchNormMode_t,
        alphaDataDiff: *const ::libc::c_void,
        betaDataDiff: *const ::libc::c_void,
        alphaParamDiff: *const ::libc::c_void,
        betaParamDiff: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        bnScaleBiasDiffDesc: miopenTensorDescriptor_t,
        bnScale: *const ::libc::c_void,
        resultBnScaleDiff: *mut ::libc::c_void,
        resultBnBiasDiff: *mut ::libc::c_void,
        epsilon: f64,
        savedMean: *const ::libc::c_void,
        savedInvVariance: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @addtogroup activation"]
    #[doc = ""]
    #[doc = "  @{"]
    #[doc = ""]
    #[doc = " @param activDesc Pointer to an activation tensor descriptor type"]
    #[doc = " @return          miopenStatus_t"]
    pub fn miopenCreateActivationDescriptor(
        activDesc: *mut miopenActivationDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets the activation layer descriptor details"]
    #[doc = ""]
    #[doc = " Sets all of the descriptor details for the activation layer"]
    #[doc = ""]
    #[doc = " @param activDesc    Pointer to a activation layer descriptor (output)"]
    #[doc = " @param mode         Activation mode enum (input)"]
    #[doc = " @param activAlpha   Alpha value for some activation modes (input)"]
    #[doc = " @param activBeta    Beta value for some activation modes (input)"]
    #[doc = " @param activGamma   Gamma value for some activation modes (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenSetActivationDescriptor(
        activDesc: miopenActivationDescriptor_t,
        mode: miopenActivationMode_t,
        activAlpha: f64,
        activBeta: f64,
        activGamma: f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets the activation layer descriptor details"]
    #[doc = ""]
    #[doc = " Retrieves all of the descriptor details for the activation layer."]
    #[doc = ""]
    #[doc = " @param activDesc    Pointer to a activation layer descriptor (input)"]
    #[doc = " @param mode         Activation mode enum (output)"]
    #[doc = " @param activAlpha   Alpha value for some activation modes (output)"]
    #[doc = " @param activBeta    Beta value for some activation modes (output)"]
    #[doc = " @param activGamma   Gamma value for some activation modes (output)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenGetActivationDescriptor(
        activDesc: miopenActivationDescriptor_t,
        mode: *mut miopenActivationMode_t,
        activAlpha: *mut f64,
        activBeta: *mut f64,
        activGamma: *mut f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute an activation forward layer"]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param activDesc      Descriptor for activation layer (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y              Data tensor y (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenActivationForward(
        handle: miopenHandle_t,
        activDesc: miopenActivationDescriptor_t,
        alpha: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a activation backwards layer"]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param activDesc      Descriptor for activation layer (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for input data tensor y (input)"]
    #[doc = " @param y              Data tensor y (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for input data tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for data output tensor dx (input)"]
    #[doc = " @param dx             Output data delta tensor dx (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenActivationBackward(
        handle: miopenHandle_t,
        activDesc: miopenActivationDescriptor_t,
        alpha: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys the activation descriptor object"]
    #[doc = ""]
    #[doc = " @param activDesc   Activation tensor descriptor type (input)"]
    #[doc = " @return            miopenStatus_t"]
    pub fn miopenDestroyActivationDescriptor(
        activDesc: miopenActivationDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @addtogroup softmax"]
    #[doc = ""]
    #[doc = "  @{"]
    #[doc = ""]
    #[doc = " This API only implements the SOFTMAX_MODE_CHANNEL in SOFTMAX_ACCURATE path."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y              Data tensor y (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenSoftmaxForward(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a softmax backwards layer"]
    #[doc = ""]
    #[doc = " This API only implements the SOFTMAX_MODE_CHANNEL in SOFTMAX_ACCURATE path."]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for input data tensor y (input)"]
    #[doc = " @param y              Data tensor y (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for input data tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for data output tensor dx (input)"]
    #[doc = " @param dx             Output data delta tensor dx (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenSoftmaxBackward(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a softmax forward layer with expanded modes and algorithms"]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param xDesc          Tensor descriptor for data input tensor x (input)"]
    #[doc = " @param x              Data tensor x (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for output data tensor y (input)"]
    #[doc = " @param y              Data tensor y (output)"]
    #[doc = " @param algorithm      Softmax implementation algorithm (input)"]
    #[doc = " @param mode           Softmax mode (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenSoftmaxForward_V2(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        algorithm: miopenSoftmaxAlgorithm_t,
        mode: miopenSoftmaxMode_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute a softmax backwards layer with expanded modes and algorithms"]
    #[doc = ""]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param yDesc          Tensor descriptor for input data tensor y (input)"]
    #[doc = " @param y              Data tensor y (input)"]
    #[doc = " @param dyDesc         Tensor descriptor for input data tensor dy (input)"]
    #[doc = " @param dy             Data delta tensor dy (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param dxDesc         Tensor descriptor for data output tensor dx (input)"]
    #[doc = " @param dx             Output data delta tensor dx (output)"]
    #[doc = " @param algorithm      Softmax implementation algorithm (input)"]
    #[doc = " @param mode           Softmax mode (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenSoftmaxBackward_V2(
        handle: miopenHandle_t,
        alpha: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        algorithm: miopenSoftmaxAlgorithm_t,
        mode: miopenSoftmaxMode_t,
    ) -> miopenStatus_t;
}
#[doc = " @ingroup FUSION"]
#[doc = " @brief MIOpen fusion interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenFusionPlanDescriptor {}
#[test]
fn bindgen_test_layout_miopenFusionPlanDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenFusionPlanDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenFusionPlanDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenFusionPlanDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenFusionPlanDescriptor))
    );
}
pub type miopenFusionPlanDescriptor_t = *mut miopenFusionPlanDescriptor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenOperatorDescriptor {}
#[test]
fn bindgen_test_layout_miopenOperatorDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<miopenOperatorDescriptor>(),
        0usize,
        concat!("Size of: ", stringify!(miopenOperatorDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenOperatorDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenOperatorDescriptor))
    );
}
pub type miopenOperatorDescriptor_t = *mut miopenOperatorDescriptor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct miopenOperatorArgs {}
#[test]
fn bindgen_test_layout_miopenOperatorArgs() {
    assert_eq!(
        ::std::mem::size_of::<miopenOperatorArgs>(),
        0usize,
        concat!("Size of: ", stringify!(miopenOperatorArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<miopenOperatorArgs>(),
        1usize,
        concat!("Alignment of ", stringify!(miopenOperatorArgs))
    );
}
pub type miopenOperatorArgs_t = *mut miopenOperatorArgs;
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenFusionDirection_t"]
#[doc = " @brief Kernel fusion direction in the network"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenFusionDirection_t {
    #[doc = "< fuses layers vertically, current the only supported mode"]
    miopenVerticalFusion = 0,
    #[doc = "< fuses layers horizontally, this is unimplemented"]
    miopenHorizontalFusion = 1,
}
extern "C" {
    #[doc = " @brief Creates the kenrel fusion plan descriptor object"]
    #[doc = ""]
    #[doc = " @param fusePlanDesc  Pointer to a fusion plan (output)"]
    #[doc = " @param fuseDirection Horizontal or Vertical fusion (input)"]
    #[doc = " @param inputDesc     Descriptor to tensor for the input (input)"]
    #[doc = " @return              miopenStatus_t"]
    pub fn miopenCreateFusionPlan(
        fusePlanDesc: *mut miopenFusionPlanDescriptor_t,
        fuseDirection: miopenFusionDirection_t,
        inputDesc: miopenTensorDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroy the fusion plan descriptor object"]
    #[doc = ""]
    #[doc = " @param fusePlanDesc  A fusion plan descriptor type"]
    #[doc = " @return              miopenStatus_t"]
    pub fn miopenDestroyFusionPlan(fusePlanDesc: miopenFusionPlanDescriptor_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Compiles the fusion plan"]
    #[doc = ""]
    #[doc = " @param handle           MIOpen handle (input)"]
    #[doc = " @param fusePlanDesc A fusion plan descriptor (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenCompileFusionPlan(
        handle: miopenHandle_t,
        fusePlanDesc: miopenFusionPlanDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Allows access to the operators in a fusion plan"]
    #[doc = " @details This api call does bounds checking on the supplied op_idx and would"]
    #[doc = "          return miopenStatusError if the index is out of bounds"]
    #[doc = ""]
    #[doc = " @param fusePlanDesc A fusion plan descriptor (input)"]
    #[doc = " @param op_idx Index of the required operator in the fusion plan, in the order of insertion"]
    #[doc = " @param op returned pointer to the operator"]
    #[doc = " @return miopenStatus_t"]
    pub fn miopenFusionPlanGetOp(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        op_idx: ::libc::c_int,
        op: *mut miopenFusionOpDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the workspace size required for the fusion plan"]
    #[doc = ""]
    #[doc = " @param fusePlanDesc   A fusion plan descriptor (input)"]
    #[doc = " @param workSpaceSize  Pointer to memory to return size in bytes (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenFusionPlanGetWorkSpaceSize(
        handle: miopenHandle_t,
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        workSpaceSize: *mut usize,
        algo: miopenConvFwdAlgorithm_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Returns the supported algorithms for the convolution operator in the Fusion Plan"]
    #[doc = ""]
    #[doc = " @details A Convolution operator in a fusion plan may be implemented by different algorithms"]
    #[doc = " representing different tradeoffs of memory and performance. The returned list of algorithms"]
    #[doc = " is sorted in decreasing order of priority. Therefore, if the user does not request an"]
    #[doc = " algorithm to be set using the miopenFusionPlanConvolutionSetAlgo call, the first algorithm"]
    #[doc = " in the list would be used to execute the convolution in the fusion plan. Moreover this call"]
    #[doc = " must be immediately preceded by the miopenCreateOpConvForward call for the op in question."]
    #[doc = ""]
    #[doc = " @param fusePlanDesc A fusion plan descriptor (input)"]
    #[doc = " @param requestAlgoCount Number of algorithms to return (input)"]
    #[doc = " @param returnedAlgoCount The actual number of returned algorithms; always be less than"]
    #[doc = " equal to requestAlgoCount (output)"]
    #[doc = " @param returnedAlgos Pointer to the list of supported algorithms"]
    #[doc = " @return miopenStatus_t"]
    pub fn miopenFusionPlanConvolutionGetAlgo(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        requestAlgoCount: ::libc::c_int,
        returnedAlgoCount: *mut ::libc::c_int,
        returnedAlgos: *mut miopenConvFwdAlgorithm_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Requests the fusion runtime to choose a particular algorithm for the added convolution"]
    #[doc = " operation"]
    #[doc = ""]
    #[doc = " @details Please see the description for miopenFusionPlanConvolutionGetAlgo"]
    #[doc = ""]
    #[doc = " @param fusePlanDesc A fusion plan descriptor (input)"]
    #[doc = " @param algo Requested algorithm for the convolution operator (input)"]
    #[doc = " @return miopenStatus_t"]
    pub fn miopenFusionPlanConvolutionSetAlgo(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        algo: miopenConvFwdAlgorithm_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates forward convolution operator."]
    #[doc = ""]
    #[doc = " @param fusePlanDesc   A fusion plan descriptor (input)"]
    #[doc = " @param convOp         Pointer to an operator type (output)"]
    #[doc = " @param convDesc       Convolution layer descriptor (input)"]
    #[doc = " @param wDesc          Descriptor for the weights tensor (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenCreateOpConvForward(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        convOp: *mut miopenFusionOpDescriptor_t,
        convDesc: miopenConvolutionDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a forward activation operator."]
    #[doc = ""]
    #[doc = " @param fusePlanDesc    A fusion plan descriptor (input)"]
    #[doc = " @param activFwdOp         Pointer to an operator type (output)"]
    #[doc = " @param mode            Activation version (input)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenCreateOpActivationForward(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        activFwdOp: *mut miopenFusionOpDescriptor_t,
        mode: miopenActivationMode_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a backward activation operator."]
    #[doc = ""]
    #[doc = " @param fusePlanDesc    A fusion plan descriptor (input)"]
    #[doc = " @param activBwdOp         Pointer to an operator type (output)"]
    #[doc = " @param mode            Activation version (input)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenCreateOpActivationBackward(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        activBwdOp: *mut miopenFusionOpDescriptor_t,
        mode: miopenActivationMode_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a forward bias operator."]
    #[doc = ""]
    #[doc = " @param fusePlanDesc   A fusion plan descriptor (input)"]
    #[doc = " @param biasOp         Pointer to an operator type (output)"]
    #[doc = " @param bDesc          bias tensor descriptor (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenCreateOpBiasForward(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        biasOp: *mut miopenFusionOpDescriptor_t,
        bDesc: miopenTensorDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a forward inference batch normalization operator."]
    #[doc = ""]
    #[doc = " @param fusePlanDesc           A fusion plan descriptor (input)"]
    #[doc = " @param bnOp                   Pointer to an operator type (output)"]
    #[doc = " @param bn_mode                Batch normalization layer mode (input)"]
    #[doc = " @param bnScaleBiasMeanVarDesc Gamma, beta, mean, variance tensor descriptor (input)"]
    #[doc = " @return                       miopenStatus_t"]
    pub fn miopenCreateOpBatchNormInference(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        bnOp: *mut miopenFusionOpDescriptor_t,
        bn_mode: miopenBatchNormMode_t,
        bnScaleBiasMeanVarDesc: miopenTensorDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a forward training batch normalization operator."]
    #[doc = ""]
    #[doc = " @param fusePlanDesc           A fusion plan descriptor (input)"]
    #[doc = " @param bnFwdOp                   Pointer to an operator type (output)"]
    #[doc = " @param bn_mode                Batch normalization layer mode (input)"]
    #[doc = " @param runningMeanVariance    Toggles whether or not to save population statistics for inference;"]
    #[doc = " batch statistic are required (input)"]
    #[doc = " @return                       miopenStatus_t"]
    pub fn miopenCreateOpBatchNormForward(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        bnFwdOp: *mut miopenFusionOpDescriptor_t,
        bn_mode: miopenBatchNormMode_t,
        runningMeanVariance: bool,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates a back propagation batch normalization operator."]
    #[doc = ""]
    #[doc = " @param fusePlanDesc           A fusion plan descriptor (input)"]
    #[doc = " @param bnBwdOp                   Pointer to an operator type (output)"]
    #[doc = " @param bn_mode                Batch normalization layer mode (input)"]
    #[doc = " @return                       miopenStatus_t"]
    pub fn miopenCreateOpBatchNormBackward(
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        bnBwdOp: *mut miopenFusionOpDescriptor_t,
        bn_mode: miopenBatchNormMode_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Creates an operator argument object"]
    #[doc = ""]
    #[doc = " @param args        Pointer to an operator argument type (output)"]
    #[doc = " @return            miopenStatus_t"]
    pub fn miopenCreateOperatorArgs(args: *mut miopenOperatorArgs_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys an operator argument object"]
    #[doc = ""]
    #[doc = " @param args        An operator argument type (output)"]
    #[doc = " @return            miopenStatus_t"]
    pub fn miopenDestroyOperatorArgs(args: miopenOperatorArgs_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets the arguments for forward convolution op"]
    #[doc = ""]
    #[doc = " @param args    An arguments object type (output)"]
    #[doc = " @param convOp  Forward convolution operator (input)"]
    #[doc = " @param alpha   Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta    Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param w       Pointer to tensor memory  (input)"]
    #[doc = " @return        miopenStatus_t"]
    pub fn miopenSetOpArgsConvForward(
        args: miopenOperatorArgs_t,
        convOp: miopenFusionOpDescriptor_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        w: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets the arguments for forward activation op"]
    #[doc = ""]
    #[doc = " @param args    An arguments object type (output)"]
    #[doc = " @param activFwdOp   Activation backwards operator (input)"]
    #[doc = " @param alpha   Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta    Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param activAlpha  Double precision activation parameter which depends on activation mode (input)"]
    #[doc = " @param activBeta   Double precision activation parameter which depends on activation mode (input)"]
    #[doc = " @param activGamma  Double precision activation parameter which depends on activation mode (input)"]
    #[doc = " @return        miopenStatus_t"]
    pub fn miopenSetOpArgsActivForward(
        args: miopenOperatorArgs_t,
        activFwdOp: miopenFusionOpDescriptor_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        activAlpha: f64,
        activBeta: f64,
        activGamma: f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets the arguments for backward activation op"]
    #[doc = ""]
    #[doc = " @param args    An arguments object type (output)"]
    #[doc = " @param activBwdOp   Activation backwards operator (input)"]
    #[doc = " @param alpha   Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta    Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param y        Data tensor y, output of activations in the forward direction (input)"]
    #[doc = " @param reserved    Data tensor reserved memory space; currently should be nullptr (input)"]
    #[doc = " @param activAlpha  Double precision activation parameter which depends on activation mode (input)"]
    #[doc = " @param activBeta   Double precision activation parameter which depends on activation mode (input)"]
    #[doc = " @param activGamma  Double precision activation parameter which depends on activation mode (input)"]
    #[doc = " @return        miopenStatus_t"]
    pub fn miopenSetOpArgsActivBackward(
        args: miopenOperatorArgs_t,
        activBwdOp: miopenFusionOpDescriptor_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        y: *const ::libc::c_void,
        reserved: *const ::libc::c_void,
        activAlpha: f64,
        activBeta: f64,
        activGamma: f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets the arguments for inference batch normalization op"]
    #[doc = ""]
    #[doc = " @param args               An arguments object type (output)"]
    #[doc = " @param bnOp               Batch normalization inference operator (input)"]
    #[doc = " @param alpha              Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta               Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param bnScale            Pointer to the gamma tensor memory  (input)"]
    #[doc = " @param bnBias             Pointer to the beta tensor memory  (input)"]
    #[doc = " @param estimatedMean      Pointer to population mean memory  (input)"]
    #[doc = " @param estimatedVariance  Pointer to population variance memory  (input)"]
    #[doc = " @param epsilon            Scalar value for numerical stability (input)"]
    #[doc = " @return                   miopenStatus_t"]
    pub fn miopenSetOpArgsBatchNormInference(
        args: miopenOperatorArgs_t,
        bnOp: miopenFusionOpDescriptor_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        bnScale: *const ::libc::c_void,
        bnBias: *const ::libc::c_void,
        estimatedMean: *const ::libc::c_void,
        estimatedVariance: *const ::libc::c_void,
        epsilon: f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets the arguments for forward batch normalization op"]
    #[doc = ""]
    #[doc = " @param args               An arguments object type (output)"]
    #[doc = " @param bnOp               Batch normalization forward operator (input)"]
    #[doc = " @param alpha              Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta               Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param bnScale            Pointer to the gamma tensor memory  (input)"]
    #[doc = " @param bnBias             Pointer to the beta tensor memory  (input)"]
    #[doc = " @param savedMean          Pointer to batch mean memory  (input)"]
    #[doc = " @param savedInvVariance   Pointer to batch inverse variance memory  (input)"]
    #[doc = " @param runningMean        Pointer to population mean memory  (input)"]
    #[doc = " @param runningVariance    Pointer to population variance memory  (input)"]
    #[doc = " @param expAvgFactor       Scalar value for control of population statistics (input)"]
    #[doc = " @param epsilon            Scalar value for numerical stability (input)"]
    #[doc = " @return                   miopenStatus_t"]
    pub fn miopenSetOpArgsBatchNormForward(
        args: miopenOperatorArgs_t,
        bnOp: miopenFusionOpDescriptor_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        bnScale: *const ::libc::c_void,
        bnBias: *const ::libc::c_void,
        savedMean: *mut ::libc::c_void,
        savedInvVariance: *mut ::libc::c_void,
        runningMean: *mut ::libc::c_void,
        runningVariance: *mut ::libc::c_void,
        expAvgFactor: f64,
        epsilon: f64,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets the arguments for backward batch normalization op"]
    #[doc = ""]
    #[doc = " @param args               An arguments object type (output)"]
    #[doc = " @param bnOp               Batch normalization forward operator (input)"]
    #[doc = " @param alpha              Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta               Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param x                  Pointer to the forward input tensor memory  (input)"]
    #[doc = " @param bnScale            Pointer to the gamma tensor memory  (input)"]
    #[doc = " @param bnBias             Pointer to the beta tensor memory  (input)"]
    #[doc = " @param resultBnScaleDiff  Pointer to the gamma gradient tensor memory  (output)"]
    #[doc = " @param resultBnBiasDiff   Pointer to the beta gradient tensor memory  (output)"]
    #[doc = " @param savedMean          Pointer to batch mean memory  (input)"]
    #[doc = " @param savedInvVariance   Pointer to batch inverse variance memory  (input)"]
    #[doc = " @return                   miopenStatus_t"]
    pub fn miopenSetOpArgsBatchNormBackward(
        args: miopenOperatorArgs_t,
        bnOp: miopenFusionOpDescriptor_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        x: *const ::libc::c_void,
        bnScale: *const ::libc::c_void,
        bnBias: *const ::libc::c_void,
        resultBnScaleDiff: *mut ::libc::c_void,
        resultBnBiasDiff: *mut ::libc::c_void,
        savedMean: *const ::libc::c_void,
        savedInvVariance: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets the arguments for forward bias op"]
    #[doc = ""]
    #[doc = " @param args           An arguments object type (output)"]
    #[doc = " @param biasOp         Forward bias operator (input)"]
    #[doc = " @param alpha          Floating point scaling factor, allocated on the host (input)"]
    #[doc = " @param beta           Floating point shift factor, allocated on the host (input)"]
    #[doc = " @param bias           Pointer to the forward bias input tensor memory  (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenSetOpArgsBiasForward(
        args: miopenOperatorArgs_t,
        biasOp: miopenFusionOpDescriptor_t,
        alpha: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        bias: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Executes the fusion plan"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param handle           MIOpen handle (input)"]
    #[doc = " @param fusePlanDesc     fused plan descriptor (input)"]
    #[doc = " @param inputDesc        Descriptor of the input tensor (input)"]
    #[doc = " @param input            Source data tensor  (input)"]
    #[doc = " @param outputDesc       Decriptor of the output tensor (input)"]
    #[doc = " @param output           Destination data tensor  (output)"]
    #[doc = " @param args             An argument object of the fused kernel (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenExecuteFusionPlan(
        handle: miopenHandle_t,
        fusePlanDesc: miopenFusionPlanDescriptor_t,
        inputDesc: miopenTensorDescriptor_t,
        input: *const ::libc::c_void,
        outputDesc: miopenTensorDescriptor_t,
        output: *mut ::libc::c_void,
        args: miopenOperatorArgs_t,
    ) -> miopenStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = "  @enum miopenRNNMode_t"]
#[doc = " RNN mode selection for rnn layer preference"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenRNNMode_t {
    #[doc = "< RNN with ReLU activation"]
    miopenRNNRELU = 0,
    #[doc = "< RNN with tanh activation"]
    miopenRNNTANH = 1,
    #[doc = "< LSTM"]
    miopenLSTM = 2,
    #[doc = "< GRU"]
    miopenGRU = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenRNNInputMode_t"]
#[doc = " Recurrent Neural Network layer initial input mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenRNNInputMode_t {
    #[doc = "< Matrix multiplication at the input of the first layer"]
    miopenRNNlinear = 0,
    #[doc = "< No operation is performed at the input of the first layer."]
    miopenRNNskip = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenRNNAlgo_t"]
#[doc = " Recurrent Neural Network algorithm mode"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenRNNAlgo_t {
    #[doc = "< Use dedicated gate-operation kernel for LSTM and fundamental"]
    #[doc = "algorithm for vanilla RNN & GRU"]
    miopenRNNdefault = 0,
    miopenRNNfundamental = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenRNNDirectionMode_t"]
#[doc = " Recurrent Neural Network bi-directional behavior"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenRNNDirectionMode_t {
    #[doc = "< Forward in time only."]
    miopenRNNunidirection = 0,
    #[doc = "< Forward and backwards in time."]
    miopenRNNbidirection = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenRNNBiasMode_t"]
#[doc = " Recurrent Neural Network add on bias"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenRNNBiasMode_t {
    #[doc = "< No Biases will be applied to GEMM operations"]
    miopenRNNNoBias = 0,
    #[doc = "< Biases will be applied to GEMM operations"]
    miopenRNNwithBias = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenRNNGEMMalgoMode_t"]
#[doc = " Recurrent Neural Network add on bias"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenRNNGEMMalgoMode_t {
    miopenRNNAlgoGEMM = 0,
}
extern "C" {
    #[doc = " @brief Create a RNN layer Descriptor"]
    #[doc = ""]
    #[doc = " API for creating an uninitialized RNN layer descriptor."]
    #[doc = " @param rnnDesc    Pointer to a tensor descriptor type"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenCreateRNNDescriptor(rnnDesc: *mut miopenRNNDescriptor_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Retrieves a RNN layer descriptor's details"]
    #[doc = ""]
    #[doc = " @param rnnDesc    RNN layer descriptor (input)"]
    #[doc = " @param rnnMode    RNN mode (output)"]
    #[doc = " @param algoMode   RNN algorithm mode (output)"]
    #[doc = " @param inputMode  RNN data input mode (output)"]
    #[doc = " @param dirMode    Uni or bi direction mode (output)"]
    #[doc = " @param biasMode   Bias used (output)"]
    #[doc = " @param hiddenSize Size of hidden state (output)"]
    #[doc = " @param layer      Number of stacked layers (output)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenGetRNNDescriptor(
        rnnDesc: miopenRNNDescriptor_t,
        rnnMode: *mut miopenRNNMode_t,
        algoMode: *mut miopenRNNAlgo_t,
        inputMode: *mut miopenRNNInputMode_t,
        dirMode: *mut miopenRNNDirectionMode_t,
        biasMode: *mut miopenRNNBiasMode_t,
        hiddenSize: *mut ::libc::c_int,
        layer: *mut ::libc::c_int,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Retrieves a RNN layer descriptor's details version 2. This version enables retrieving"]
    #[doc = " information of the dropout descriptor of the rnn descriptor."]
    #[doc = ""]
    #[doc = " @param rnnDesc     RNN layer descriptor (input)"]
    #[doc = " @param hiddenSize  Size of hidden state (output)"]
    #[doc = " @param layer       Number of stacked layers (output)"]
    #[doc = " @param dropoutDesc Pre-configured dropout descriptor for dropout layer in between RNN layers"]
    #[doc = " (output)"]
    #[doc = " @param inputMode   RNN data input mode (output)"]
    #[doc = " @param dirMode     Uni or bi direction mode (output)"]
    #[doc = " @param rnnMode     RNN mode (output)"]
    #[doc = " @param biasMode    Bias used (output)"]
    #[doc = " @param algoMode    RNN algorithm mode (output)"]
    #[doc = " @param dataType    Data type of RNN (output)"]
    #[doc = " @return            miopenStatus_t"]
    pub fn miopenGetRNNDescriptor_V2(
        rnnDesc: miopenRNNDescriptor_t,
        hiddenSize: *mut ::libc::c_int,
        layer: *mut ::libc::c_int,
        dropoutDesc: *mut miopenDropoutDescriptor_t,
        inputMode: *mut miopenRNNInputMode_t,
        dirMode: *mut miopenRNNDirectionMode_t,
        rnnMode: *mut miopenRNNMode_t,
        biasMode: *mut miopenRNNBiasMode_t,
        algoMode: *mut miopenRNNAlgo_t,
        dataType: *mut miopenDataType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys the tensor descriptor object"]
    #[doc = ""]
    #[doc = " @param rnnDesc RNN tensor descriptor type (input)"]
    #[doc = " @return           miopenStatus_t"]
    pub fn miopenDestroyRNNDescriptor(rnnDesc: miopenRNNDescriptor_t) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set the details of the RNN descriptor"]
    #[doc = ""]
    #[doc = " Interface for setting the values of the RNN descriptor object. This function requires specific"]
    #[doc = " algorithm selection."]
    #[doc = " @param rnnDesc      RNN layer descriptor type (input)"]
    #[doc = " @param hsize        Hidden layer size (input)"]
    #[doc = " @param nlayers      Number of layers (input)"]
    #[doc = " @param inMode       RNN first layer input mode (input)"]
    #[doc = " @param direction    RNN direction (input)"]
    #[doc = " @param rnnMode      RNN model type (input)"]
    #[doc = " @param biasMode     RNN bias included (input)"]
    #[doc = " @param algo         RNN algorithm selected (input)"]
    #[doc = " @param dataType     Only fp32 currently supported for RNNs (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenSetRNNDescriptor(
        rnnDesc: miopenRNNDescriptor_t,
        hsize: ::libc::c_int,
        nlayers: ::libc::c_int,
        inMode: miopenRNNInputMode_t,
        direction: miopenRNNDirectionMode_t,
        rnnMode: miopenRNNMode_t,
        biasMode: miopenRNNBiasMode_t,
        algo: miopenRNNAlgo_t,
        dataType: miopenDataType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set the details of the RNN descriptor version 2. This version enables the use of dropout"]
    #[doc = " in rnn."]
    #[doc = ""]
    #[doc = " Interface for setting the values of the RNN descriptor object. This function requires specific"]
    #[doc = " algorithm selection."]
    #[doc = " @param rnnDesc      RNN layer descriptor type (input/output)"]
    #[doc = " @param hsize        Hidden layer size (input)"]
    #[doc = " @param nlayers      Number of layers (input)"]
    #[doc = " @param dropoutDesc  Pre-initialized dropout descriptor for dropout layer in between RNN layers"]
    #[doc = " (input)"]
    #[doc = " @param inMode       RNN first layer input mode (input)"]
    #[doc = " @param direction    RNN direction (input)"]
    #[doc = " @param rnnMode      RNN model type (input)"]
    #[doc = " @param biasMode     RNN bias included (input)"]
    #[doc = " @param algo         RNN algorithm selected (input)"]
    #[doc = " @param dataType     Only fp32 currently supported for RNNs (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenSetRNNDescriptor_V2(
        rnnDesc: miopenRNNDescriptor_t,
        hsize: ::libc::c_int,
        nlayers: ::libc::c_int,
        dropoutDesc: miopenDropoutDescriptor_t,
        inMode: miopenRNNInputMode_t,
        direction: miopenRNNDirectionMode_t,
        rnnMode: miopenRNNMode_t,
        biasMode: miopenRNNBiasMode_t,
        algo: miopenRNNAlgo_t,
        dataType: miopenDataType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the amount of memory required to execute the RNN layer"]
    #[doc = ""]
    #[doc = " This function calculates the amount of memory required to run the RNN layer given an RNN"]
    #[doc = " descriptor and a tensor descriptor."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param sequenceLen     Number of iteration unrolls (input)"]
    #[doc = " @param xDesc           An array of tensor descriptors. These are the"]
    #[doc = " input descriptors to each time step. The first dimension of each descriptor is the"]
    #[doc = " batch size and may decrease from element n to element n+1 and not increase in size."]
    #[doc = " The second dimension is the same for all descriptors in the array and is the input"]
    #[doc = " vector length. (input)"]
    #[doc = " @param numBytes        Number of bytes required for RNN layer execution (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNWorkspaceSize(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        sequenceLen: ::libc::c_int,
        xDesc: *const miopenTensorDescriptor_t,
        numBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the amount of memory required for RNN training"]
    #[doc = ""]
    #[doc = " This function calculates the amount of memory required to train the RNN layer given an"]
    #[doc = " RNN descriptor and a tensor descriptor."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param sequenceLen     Number of iteration unrolls (input)"]
    #[doc = " @param xDesc           An array of tensor descriptors. These are the"]
    #[doc = " input descriptors to each time step. The first dimension of each descriptor is the"]
    #[doc = " batch size and may decrease from element n to element n+1 and not increase in size."]
    #[doc = " The second dimension is the same for all descriptors in the array and is the input"]
    #[doc = " vector length. (input)"]
    #[doc = " @param numBytes        Number of bytes required for RNN layer execution (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNTrainingReserveSize(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        sequenceLen: ::libc::c_int,
        xDesc: *const miopenTensorDescriptor_t,
        numBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the amount of parameter memory required for RNN training"]
    #[doc = ""]
    #[doc = " This function calculates the amount of parameter memory required to train the RNN layer given an"]
    #[doc = " RNN descriptor and a tensor descriptor."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param xDesc           A tensor descriptor (input)"]
    #[doc = " @param numBytes        Number of bytes required for RNN layer execution (output)"]
    #[doc = " @param dtype           MIOpen data type enum (input)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNParamsSize(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        numBytes: *mut usize,
        dtype: miopenDataType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Obtain a weight tensor descriptor for RNNs"]
    #[doc = ""]
    #[doc = " This function populates a weight descriptor that describes the memory layout of the"]
    #[doc = " weight matrix."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         Fully populated RNN layer descriptor type (input)"]
    #[doc = " @param xDesc           A previously populated tensor descriptor (input)"]
    #[doc = " @param wDesc           A previously allocated tensor descriptor (output)"]
    #[doc = " @param dtype           MIOpen data type enum, currently only fp32 is supported (input)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNParamsDescriptor(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        dtype: miopenDataType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Obtain a the size in bytes of the RNN input tensor"]
    #[doc = ""]
    #[doc = " This function determines the size in bytes of the allocation needed for the input data"]
    #[doc = " tensor for an RNN layer. The number of bytes is derived from the array of"]
    #[doc = " tensor descriptors."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         Fully populated RNN layer descriptor (input)"]
    #[doc = " @param seqLen          Number of iteration unrolls (input)"]
    #[doc = " @param xDesc           An array of tensor descriptors. These are the"]
    #[doc = " input descriptors to each time step. The first dimension of each descriptor is the"]
    #[doc = " batch size and may decrease from element n to element n+1 and not increase in size."]
    #[doc = " The second dimension is the same for all descriptors in the array and is the input"]
    #[doc = " vector length. (input)"]
    #[doc = " @param numBytes        Number of bytes required for input tensor (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNInputTensorSize(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        seqLen: ::libc::c_int,
        xDesc: *mut miopenTensorDescriptor_t,
        numBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Obtain a the size in bytes of the RNN hidden tensor"]
    #[doc = ""]
    #[doc = " This function determines the size in bytes of the allocation needed for the"]
    #[doc = " hidden tensor over all layers"]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         Fully populated RNN layer descriptor type (input)"]
    #[doc = " @param seqLen          Number of iteration unrolls (input)"]
    #[doc = " @param xDesc           An array of previously populated tensor descriptors (input)"]
    #[doc = " @param numBytes        Number of bytes required for input tensor (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNHiddenTensorSize(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        seqLen: ::libc::c_int,
        xDesc: *mut miopenTensorDescriptor_t,
        numBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets the number of bytes of a parameter matrix"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " For RNN vanilla miopenRNNRELU and miopenRNNTANH, paramID == 0 retrieves the"]
    #[doc = " weight matrix associated with the in input GEMM, while paramID == 1 retrieves"]
    #[doc = " the weight matrix associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " For miopenLSTM paramID 0 to 3 refer to the weight matrices associated"]
    #[doc = " with the input GEMM, 4-7 are associated with matrices associated with the"]
    #[doc = " hidden state GEMM."]
    #[doc = ""]
    #[doc = " * paramID 0 and 4 are for the input gate."]
    #[doc = ""]
    #[doc = " * paramID 1 and 5 are for the forget gate."]
    #[doc = ""]
    #[doc = " * paramID 2 and 6 are for the output gate."]
    #[doc = ""]
    #[doc = " * paramID 3 and 7 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For miopenGRU paramID 0 to 2 refer to the weight matrix offset associated"]
    #[doc = " with the input GEMM, while 3 through 5 are associated with the hidden state"]
    #[doc = " GEMM."]
    #[doc = ""]
    #[doc = " * paramID 0 and 3 are for the update gate."]
    #[doc = ""]
    #[doc = " * paramID 1 and 4 are for the reset gate."]
    #[doc = ""]
    #[doc = " * paramID 2 and 5 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For bi-directional RNNs the backwards in time direction is numbered as the layer"]
    #[doc = " directly after the forward in time direction."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param layer           The layer number in the RNN stack (input)"]
    #[doc = " @param xDesc           A tensor descriptor to input (input)"]
    #[doc = " @param paramID         ID of the internal parameter tensor (input)"]
    #[doc = " @param numBytes        The number of bytes of the layer's parameter matrix (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNLayerParamSize(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        layer: ::libc::c_int,
        xDesc: miopenTensorDescriptor_t,
        paramID: ::libc::c_int,
        numBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets the number of bytes of a bias"]
    #[doc = ""]
    #[doc = " For RNN vanilla miopenRNNRELU and miopenRNNTANH, biasID == 0 retrieves the"]
    #[doc = " weight matrix associated with the in input GEMM, while biasID == 1 retrieves"]
    #[doc = " the bias associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " For miopenLSTM biasID 0 to 3 refer to the biases associated"]
    #[doc = " with the input GEMM, 4-7 are associated with biases associated with the"]
    #[doc = " hidden state GEMM."]
    #[doc = ""]
    #[doc = " * biasID 0 and 4 are for the input gate."]
    #[doc = ""]
    #[doc = " * biasID 1 and 5 are for the forget gate."]
    #[doc = ""]
    #[doc = " * biasID 2 and 6 are for the output gate."]
    #[doc = ""]
    #[doc = " * biasID 3 and 7 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For miopenGRU biasID 0 to 2 refer to the biases associated with the input GEMM,"]
    #[doc = " while 3 through 5 are associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " * biasID 0 and 3 are for the update gate."]
    #[doc = ""]
    #[doc = " * biasID 1 and 4 are for the reset gate."]
    #[doc = ""]
    #[doc = " * biasID 2 and 5 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For bi-directional RNNs the backwards in time direction is numbered as the layer"]
    #[doc = " directly after the forward in time direction."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param layer           The layer number in the RNN stack (input)"]
    #[doc = " @param biasID          ID of the internal parameter tensor (input)"]
    #[doc = " @param numBytes        The number of bytes of the layer's bias (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNLayerBiasSize(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        layer: ::libc::c_int,
        biasID: ::libc::c_int,
        numBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets a weight matrix for a specific layer in an RNN stack"]
    #[doc = ""]
    #[doc = " This function retrieves the weight matrix data for a specific layer and parameter ID"]
    #[doc = " and copies the data into previously allocated device memory."]
    #[doc = ""]
    #[doc = " For RNN vanilla miopenRNNRELU and miopenRNNTANH, paramID == 0 retrieves the"]
    #[doc = " weight matrix associated with the in input GEMM, while paramID == 1 retrieves"]
    #[doc = " the weight matrix associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " For miopenLSTM paramID 0 to 3 refer to the weight matrices associated"]
    #[doc = " with the input GEMM, 4-7 are associated with matrices associated with the"]
    #[doc = " hidden state GEMM."]
    #[doc = ""]
    #[doc = " * paramID 0 and 4 are for the input gate."]
    #[doc = ""]
    #[doc = " * paramID 1 and 5 are for the forget gate."]
    #[doc = ""]
    #[doc = " * paramID 2 and 6 are for the output gate."]
    #[doc = ""]
    #[doc = " * paramID 3 and 7 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For miopenGRU paramID 0 to 2 refer to the weight matrix offset associated"]
    #[doc = " with the input GEMM, while 3 through 5 are associated with the hidden state"]
    #[doc = " GEMM."]
    #[doc = ""]
    #[doc = " * paramID 0 and 3 are for the update gate."]
    #[doc = ""]
    #[doc = " * paramID 1 and 4 are for the reset gate."]
    #[doc = ""]
    #[doc = " * paramID 2 and 5 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For bi-directional RNNs the backwards in time direction is numbered as the layer"]
    #[doc = " directly after the forward in time direction."]
    #[doc = ""]
    #[doc = " The output argument paramDesc is a previously created tensor descriptor that is populated"]
    #[doc = " to describe the memory layout of the parameter matrix. It is full packed and is used when"]
    #[doc = " calling to miopenSetRNNLayerParam()"]
    #[doc = ""]
    #[doc = " The argument layerParam should either be nullptr, or have device memory allocated"]
    #[doc = " to allow copying of the entire layer parameter matrix into it. If layerParam is"]
    #[doc = " nullptr then only the paramDesc is populated and returned. The size in bytes of the"]
    #[doc = " layer parameter matrix can be determined by using miopenGetRNNLayerParamSize()."]
    #[doc = ""]
    #[doc = " Note: When inputSkip mode is selected there is no input layer matrix operation,"]
    #[doc = " and therefore no associated memory. In this case miopenGetRNNLayerParam() will return"]
    #[doc = " a error status miopenStatusBadParm for input paramID associated with the input GEMM."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param layer           The layer number in the RNN stack (input)"]
    #[doc = " @param xDesc           A tensor descriptor to input (input)"]
    #[doc = " @param wDesc           A tensor descriptor to the parameter tensor (input)"]
    #[doc = " @param w               Pointer to memory containing parameter tensor (input)"]
    #[doc = " @param paramID         ID of the internal parameter tensor (input)"]
    #[doc = " @param paramDesc       Tensor descriptor for the fully packed output parameter tensor (output)"]
    #[doc = " @param layerParam      Pointer to the memory location of the parameter tensor (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNLayerParam(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        layer: ::libc::c_int,
        xDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        paramID: ::libc::c_int,
        paramDesc: miopenTensorDescriptor_t,
        layerParam: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets a bias for a specific layer in an RNN stack"]
    #[doc = ""]
    #[doc = " This function retrieves the bias data for a specific layer and bias ID and copies"]
    #[doc = " the data into previously allocated device memory."]
    #[doc = ""]
    #[doc = " For RNN vanilla miopenRNNRELU and miopenRNNTANH, biasID == 0 retrieves the"]
    #[doc = " bias associated with the in input GEMM, while biasID == 1 retrieves"]
    #[doc = " the bias associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " For miopenLSTM biasID 0 to 3 refer to the biases associated"]
    #[doc = " with the input GEMM, 4-7 are associated with biases associated with the"]
    #[doc = " hidden state GEMM."]
    #[doc = ""]
    #[doc = " * biasID 0 and 4 are for the input gate."]
    #[doc = ""]
    #[doc = " * biasID 1 and 5 are for the forget gate."]
    #[doc = ""]
    #[doc = " * biasID 2 and 6 are for the output gate."]
    #[doc = ""]
    #[doc = " * biasID 3 and 7 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For miopenGRU biasID 0 to 2 refer to the biases associated with the input GEMM,"]
    #[doc = " while 3 through 5 are associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " * biasID 0 and 3 are for the update gate."]
    #[doc = ""]
    #[doc = " * biasID 1 and 4 are for the reset gate."]
    #[doc = ""]
    #[doc = " * biasID 2 and 5 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For bi-directional RNNs the backwards in time direction is numbered as the layer"]
    #[doc = " directly after the forward in time direction."]
    #[doc = ""]
    #[doc = " The output argument biasDesc is a previously created tensor descriptor that is populated"]
    #[doc = " to describe the memory layout of the bias. It is full packed and is used when"]
    #[doc = " calling to miopenSetRNNLayerBias()"]
    #[doc = ""]
    #[doc = " The argument layerBias should either be nullptr, or have device memory allocated"]
    #[doc = " to allow copying of the entire layer bias into it. If layerBias is"]
    #[doc = " nullptr then only the biasDesc is populated and returned. The size in bytes of the"]
    #[doc = " layer bias can be determined by using miopenGetRNNLayerBiasSize()."]
    #[doc = ""]
    #[doc = " Note: When inputSkip mode is selected there is no input layer matrix operation,"]
    #[doc = " and therefore no associated memory. In this case miopenGetRNNLayerBias() will return"]
    #[doc = " a error status miopenStatusBadParm for input biasID associated with the input GEMM."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param layer           The layer number in the RNN stack (input)"]
    #[doc = " @param xDesc           A tensor descriptor to input (input)"]
    #[doc = " @param wDesc           A tensor descriptor to the parameter tensor (input)"]
    #[doc = " @param w               Pointer to memory containing parameter tensor (input)"]
    #[doc = " @param biasID          ID of the internal parameter tensor (input)"]
    #[doc = " @param biasDesc        Descriptor of the parameter tensor (output)"]
    #[doc = " @param layerBias       Pointer to the memory location of the bias tensor (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNLayerBias(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        layer: ::libc::c_int,
        xDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        biasID: ::libc::c_int,
        biasDesc: miopenTensorDescriptor_t,
        layerBias: *mut ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets an index offset for a specific weight matrix for a layer in the"]
    #[doc = "  RNN stack"]
    #[doc = ""]
    #[doc = " This function retrieves the index offset for a weight matrix in a layer."]
    #[doc = ""]
    #[doc = " For RNN vanilla miopenRNNRELU and miopenRNNTANH, paramID == 0 retrieves the"]
    #[doc = " weight matrix offset associated with the in input GEMM, while paramID == 1"]
    #[doc = " retrieves the weight matrix offset associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " For miopenLSTM paramID 0 to 3 refer to the weight matrix offsets associated"]
    #[doc = " with the input GEMM, 4-7 are associated with matrix offset associated with the"]
    #[doc = " hidden state GEMM."]
    #[doc = ""]
    #[doc = " * paramID 0 and 4 are for the input gate."]
    #[doc = ""]
    #[doc = " * paramID 1 and 5 are for the forget gate."]
    #[doc = ""]
    #[doc = " * paramID 2 and 6 are for the output gate."]
    #[doc = ""]
    #[doc = " * paramID 3 and 7 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For miopenGRU paramID 0 to 2 refer to the weight matrix offset associated"]
    #[doc = " with the input GEMM, while 3 through 5 are associated with the hidden state"]
    #[doc = " GEMM."]
    #[doc = ""]
    #[doc = " * paramID 0 and 3 are for the update gate."]
    #[doc = ""]
    #[doc = " * paramID 1 and 4 are for the reset gate."]
    #[doc = ""]
    #[doc = " * paramID 2 and 5 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For bi-directional RNNs the backwards in time direction is numbered as the layer"]
    #[doc = " directly after the forward in time direction."]
    #[doc = ""]
    #[doc = " The output argument paramDesc is a previously created tensor descriptor that is populated"]
    #[doc = " to describe the memory layout of the parameter matrix. It is full packed and is used when"]
    #[doc = " calling to miopenSetRNNLayerParam()."]
    #[doc = ""]
    #[doc = " The argument layerParamOffset should either be nullptr, or an address to place the"]
    #[doc = " offset. If layerParamOffset is nullptr then only the paramDesc is populated and returned."]
    #[doc = ""]
    #[doc = " Note: When inputSkip mode is selected there is no input layer matrix operation,"]
    #[doc = " and therefore no associated memory. In this case miopenGetRNNLayerParamOffset() will return"]
    #[doc = " a error status miopenStatusBadParm for input paramID associated with the input GEMM."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param rnnDesc           RNN layer descriptor type (input)"]
    #[doc = " @param layer             The layer number in the RNN stack (input)"]
    #[doc = " @param xDesc             A tensor descriptor to input (input)"]
    #[doc = " @param paramID           ID of the internal parameter tensor (input)"]
    #[doc = " @param paramDesc         Tensor descriptor for the fully packed output parameter tensor (output)"]
    #[doc = " @param layerParamOffset  Location for the parameter offset (output)"]
    #[doc = " @return                  miopenStatus_t"]
    pub fn miopenGetRNNLayerParamOffset(
        rnnDesc: miopenRNNDescriptor_t,
        layer: ::libc::c_int,
        xDesc: miopenTensorDescriptor_t,
        paramID: ::libc::c_int,
        paramDesc: miopenTensorDescriptor_t,
        layerParamOffset: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Gets a bias index offset for a specific layer in an RNN stack"]
    #[doc = ""]
    #[doc = " This function retrieves the bias index offset for a specific layer and bias ID."]
    #[doc = ""]
    #[doc = " For RNN vanilla miopenRNNRELU and miopenRNNTANH, biasID == 0 retrieves the"]
    #[doc = " bias associated with the in input GEMM, while biasID == 1 retrieves"]
    #[doc = " the weight matrix associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " For miopenLSTM biasID 0 to 3 refer to the bias offset associated"]
    #[doc = " with the input GEMM, 4-7 are the bias offsets associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " * biasID 0 and 4 are for the input gate."]
    #[doc = ""]
    #[doc = " * biasID 1 and 5 are for the forget gate."]
    #[doc = ""]
    #[doc = " * biasID 2 and 6 are for the output gate."]
    #[doc = ""]
    #[doc = " * biasID 3 and 7 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For miopenGRU biasID 0 to 2 refer to the biases associated with the input GEMM,"]
    #[doc = " while 3 through 5 are associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " * biasID 0 and 3 are for the update gate."]
    #[doc = ""]
    #[doc = " * biasID 1 and 4 are for the reset gate."]
    #[doc = ""]
    #[doc = " * biasID 2 and 5 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For bi-directional RNNs the backwards in time direction is numbered as the layer"]
    #[doc = " directly after the forward in time direction."]
    #[doc = ""]
    #[doc = " The output argument biasDesc is a previously created tensor descriptor that is populated"]
    #[doc = " to describe the memory layout of the bias. It is full packed and is used when"]
    #[doc = " calling to miopenSetRNNLayerBias()"]
    #[doc = ""]
    #[doc = " The argument layerBiasOffset should either be nullptr, or point to an output address."]
    #[doc = " If layerBias is nullptr then only the biasDesc is populated and returned."]
    #[doc = ""]
    #[doc = " Note: When inputSkip mode is selected there is no input layer matrix operation,"]
    #[doc = " and therefore no associated memory. In this case miopenGetRNNLayerBiasOffset() will return"]
    #[doc = " a error status miopenStatusBadParm for input biasID associated with the input GEMM."]
    #[doc = ""]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param layer           The layer number in the RNN stack (input)"]
    #[doc = " @param xDesc           A tensor descriptor to input (input)"]
    #[doc = " @param biasID          ID of the internal parameter tensor (input)"]
    #[doc = " @param biasDesc        Descriptor of the parameter tensor (output)"]
    #[doc = " @param layerBiasOffset Pointer to the memory location of the bias tensor (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenGetRNNLayerBiasOffset(
        rnnDesc: miopenRNNDescriptor_t,
        layer: ::libc::c_int,
        xDesc: miopenTensorDescriptor_t,
        biasID: ::libc::c_int,
        biasDesc: miopenTensorDescriptor_t,
        layerBiasOffset: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets a weight matrix for a specific layer in an RNN stack"]
    #[doc = ""]
    #[doc = " This function sets the weight matrix data for a specific layer and parameter ID."]
    #[doc = ""]
    #[doc = " For RNN vanilla miopenRNNRELU and miopenRNNTANH, paramID == 0 sets the"]
    #[doc = " weight matrix associated with the in input GEMM, while paramID == 1 sets"]
    #[doc = " the weight matrix associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " For miopenLSTM paramID 0 to 3 refer to the weight matrices associated"]
    #[doc = " with the input GEMM, 4-7 are associated with matrices associated with the"]
    #[doc = " hidden state GEMM."]
    #[doc = ""]
    #[doc = " * paramID 0 and 4 are for the input gate."]
    #[doc = ""]
    #[doc = " * paramID 1 and 5 are for the forget gate."]
    #[doc = ""]
    #[doc = " * paramID 2 and 6 are for the output gate."]
    #[doc = ""]
    #[doc = " * paramID 3 and 7 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For miopenGRU paramID 0 to 2 refer to the weight matrix offset associated"]
    #[doc = " with the input GEMM, while 3 through 5 are associated with the hidden state"]
    #[doc = " GEMM."]
    #[doc = ""]
    #[doc = " * paramID 0 and 3 are for the update gate."]
    #[doc = ""]
    #[doc = " * paramID 1 and 4 are for the reset gate."]
    #[doc = ""]
    #[doc = " * paramID 2 and 5 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For bi-directional RNNs the backwards in time direction is numbered as the layer"]
    #[doc = " directly after the forward in time direction."]
    #[doc = ""]
    #[doc = " The input argument paramDesc is a previously populated tensor descriptor typically"]
    #[doc = " by first calling miopenGetRNNLayerParam()."]
    #[doc = ""]
    #[doc = " Note: When inputSkip mode is selected there is no input layer matrix operation,"]
    #[doc = " and therefore no associated memory. In this case miopenSetRNNLayerParam() will return"]
    #[doc = " a error status miopenStatusBadParm for input paramID associated with the input GEMM."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param layer           The layer number in the RNN stack (input)"]
    #[doc = " @param xDesc           A tensor descriptor to input (input)"]
    #[doc = " @param wDesc           A tensor descriptor to the parameter tensor (input)"]
    #[doc = " @param w               Pointer to memory containing parameter tensor (input)"]
    #[doc = " @param paramID         ID of the internal parameter tensor (input)"]
    #[doc = " @param paramDesc       Descriptor of the parameter tensor (input)"]
    #[doc = " @param layerParam      Pointer to the memory location of the parameter tensor (input)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenSetRNNLayerParam(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        layer: ::libc::c_int,
        xDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        w: *mut ::libc::c_void,
        paramID: ::libc::c_int,
        paramDesc: miopenTensorDescriptor_t,
        layerParam: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Sets a bias for a specific layer in an RNN stack"]
    #[doc = ""]
    #[doc = " This function sets the bias data for a specific layer and bias ID."]
    #[doc = ""]
    #[doc = " For RNN vanilla miopenRNNRELU and miopenRNNTANH, biasID == 0 retrieves the"]
    #[doc = " weight matrix associated with the in input GEMM, while biasID == 1 retrieves"]
    #[doc = " the bias associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " For miopenLSTM biasID 0 to 3 refer to the biases associated"]
    #[doc = " with the input GEMM, 4-7 are associated with the biases associated with the"]
    #[doc = " hidden state GEMM."]
    #[doc = ""]
    #[doc = " * biasID 0 and 4 are for the input gate."]
    #[doc = ""]
    #[doc = " * biasID 1 and 5 are for the forget gate."]
    #[doc = ""]
    #[doc = " * biasID 2 and 6 are for the output gate."]
    #[doc = ""]
    #[doc = " * biasID 3 and 7 are for the new memory gate."]
    #[doc = ""]
    #[doc = " For miopenGRU biasID 0 to 2 refer to the biases associated with the input GEMM,"]
    #[doc = " while 3 through 5 are associated with the hidden state GEMM."]
    #[doc = ""]
    #[doc = " * biasID 0 and 3 are for the update gate."]
    #[doc = ""]
    #[doc = " * biasID 1 and 4 are for the reset gate."]
    #[doc = ""]
    #[doc = " * biasID 2 and 5 are for the new new memory gate."]
    #[doc = ""]
    #[doc = " For bi-directional RNNs the backwards in time direction is numbered as the layer"]
    #[doc = " directly after the forward in time direction."]
    #[doc = ""]
    #[doc = " The input argument biasDesc is a previously populated tensor descriptor typically"]
    #[doc = " by first calling miopenGetRNNLayeBias()."]
    #[doc = ""]
    #[doc = " Note: When inputSkip mode is selected there is no input layer matrix operation,"]
    #[doc = " and therefore no associated memory. In this case miopenSetRNNLayerBias will return"]
    #[doc = " a error status miopenStatusBadParm for input biasID associated with the input GEMM."]
    #[doc = ""]
    #[doc = " @param handle          MIOpen handle (input)"]
    #[doc = " @param rnnDesc         RNN layer descriptor type (input)"]
    #[doc = " @param layer           The layer number in the RNN stack (input)"]
    #[doc = " @param xDesc           A tensor descriptor to input (input)"]
    #[doc = " @param wDesc           A tensor descriptor to the bias tensor (input)"]
    #[doc = " @param w               Pointer to memory containing bias tensor (input)"]
    #[doc = " @param biasID          ID of the internal bias tensor (input)"]
    #[doc = " @param biasDesc        Descriptor of the bias tensor (output)"]
    #[doc = " @param layerBias       Pointer to the memory location of the bias tensor (output)"]
    #[doc = " @return                miopenStatus_t"]
    pub fn miopenSetRNNLayerBias(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        layer: ::libc::c_int,
        xDesc: miopenTensorDescriptor_t,
        wDesc: miopenTensorDescriptor_t,
        w: *mut ::libc::c_void,
        biasID: ::libc::c_int,
        biasDesc: miopenTensorDescriptor_t,
        layerBias: *const ::libc::c_void,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute forward training for recurrent layer"]
    #[doc = ""]
    #[doc = " Interface for executing the forward training pass on a RNN."]
    #[doc = ""]
    #[doc = " @param handle                MIOpen handle (input)"]
    #[doc = " @param rnnDesc               RNN layer descriptor type (input)"]
    #[doc = " @param sequenceLen           Temporal iterations to unroll (input)"]
    #[doc = " @param xDesc                 An array of tensor descriptors. These are the"]
    #[doc = " input descriptors to each time step. The first dimension of each descriptor is the"]
    #[doc = " batch size and may decrease from element n to element n+1 and not increase in size."]
    #[doc = " The second dimension is the same for all descriptors in the array and is the input"]
    #[doc = " vector length. (input)"]
    #[doc = " @param x                     Pointer to input tensor (input)"]
    #[doc = " @param hxDesc                A hidden tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param hx                    Pointer to the hidden layer input tensor. If hx is NULL,"]
    #[doc = " then the initial hidden state will be zero initialized. (input)"]
    #[doc = " @param cxDesc                A cell tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param cx                    Pointer to the cell layer input tensor. If cx is NULL,"]
    #[doc = " then the initial cell state will be zero initialized. (input)"]
    #[doc = " @param wDesc                 A weights tensor descriptor (input)"]
    #[doc = " @param w                     Pointer to input weights tensor (input)"]
    #[doc = " @param yDesc                 An array of fully packed tensor descriptors associated"]
    #[doc = " with the output from each time step. The first dimension of the tensor descriptors"]
    #[doc = " must equal the first dimension of the first descriptor (batch size) in the xDesc"]
    #[doc = " tensor array. The second dimension of the element of the descriptor array"]
    #[doc = " depends on the direction mode selected. If the direction mode is unidirectional,"]
    #[doc = " the second dimension is the hiddenSize. If direction mode is bidirectional"]
    #[doc = " the second dimension is twice the hiddenSize. (input)"]
    #[doc = " @param y                     Pointer to output tensor (output)"]
    #[doc = " @param hyDesc                A hidden tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param hy                    Pointer to the hidden layer output tensor. If hy is NULL,"]
    #[doc = " then the final hidden state will not be saved. (output)"]
    #[doc = " @param cyDesc                A cell tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param cy                    Pointer to the cell layer output tensor. If hy is NULL,"]
    #[doc = " then the final cell state will not be saved. (output)"]
    #[doc = " @param workSpace             Pointer to memory allocated for forward training (input)"]
    #[doc = " @param workSpaceNumBytes     Number of allocated bytes in memory for the workspace (input)"]
    #[doc = " @param reserveSpace          Pointer to memory allocated for random states (input / output)"]
    #[doc = " @param reserveSpaceNumBytes  Number of allocated bytes in memory for use in the forward  (input)"]
    #[doc = " @return                      miopenStatus_t"]
    pub fn miopenRNNForwardTraining(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        sequenceLen: ::libc::c_int,
        xDesc: *const miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: miopenTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: miopenTensorDescriptor_t,
        cx: *const ::libc::c_void,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        yDesc: *const miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        hyDesc: miopenTensorDescriptor_t,
        hy: *mut ::libc::c_void,
        cyDesc: miopenTensorDescriptor_t,
        cy: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceNumBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceNumBytes: usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute backward data for recurrent layer"]
    #[doc = ""]
    #[doc = " Interface for executing the backward data pass on a RNN."]
    #[doc = ""]
    #[doc = " @param handle                MIOpen handle (input)"]
    #[doc = " @param rnnDesc               RNN layer descriptor type (input)"]
    #[doc = " @param sequenceLen           Temporal iterations to unroll (input)"]
    #[doc = " @param yDesc                 An array of tensor descriptors (input)"]
    #[doc = " @param y                     Pointer to input tensor (input)"]
    #[doc = " @param dyDesc                An array of fully packed tensor descriptors associated"]
    #[doc = " with the output from each time step. The first dimension of the tensor descriptors"]
    #[doc = " must equal the first dimension of the first descriptor (batch size) in the xDesc"]
    #[doc = " tensor array. The second dimension of the element of the descriptor array"]
    #[doc = " depends on the direction mode selected. If the direction mode is unidirectional,"]
    #[doc = " the second dimension is the hiddenSize. If direction mode is bidirectional"]
    #[doc = " the second dimension is twice the hiddenSize. (input)"]
    #[doc = " @param dy                    Pointer to the hidden layer input tensor (input)"]
    #[doc = " @param dhyDesc               A hidden tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param dhy                   Pointer to the cell layer input tensor (input)"]
    #[doc = " @param dcyDesc               A cell tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param dcy                   Pointer to the cell layer input tensor. If dcy is NULL,"]
    #[doc = " then the initial delta cell state will be zero initialized. (input)"]
    #[doc = " @param wDesc                 A weights tensor descriptor (input)"]
    #[doc = " @param w                     Pointer to input weights tensor (input)"]
    #[doc = " @param hxDesc                An input hidden tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param hx                    Pointer to the hidden layer input tensor. If hx is NULL,"]
    #[doc = " then the initial hidden state will be zero initialized. (input)"]
    #[doc = " @param cxDesc                A input cell tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param cx                    Pointer to the hidden layer input tensor. If cx is NULL,"]
    #[doc = " then the initial cell state will be zero initialized. (input)"]
    #[doc = " @param dxDesc                An array of tensor descriptors. These are the"]
    #[doc = " input descriptors to each time step. The first dimension of each descriptor is the"]
    #[doc = " batch size and may decrease from element n to element n+1 and not increase in size."]
    #[doc = " The second dimension is the same for all descriptors in the array and is the input"]
    #[doc = " vector length. (input)"]
    #[doc = " @param dx                    Pointer to the cell layer output tensor (output)"]
    #[doc = " @param dhxDesc               A hidden tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param dhx                   Pointer to the delta hidden layer output tensor. If dhx is NULL"]
    #[doc = " the hidden gradient will not ouput. (output)"]
    #[doc = " @param dcxDesc               A tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param dcx                   Pointer to the cell layer output tensor. If dcx is NULL"]
    #[doc = " the cell gradient will not ouput. (output)"]
    #[doc = " @param workSpace             Pointer to memory allocated for forward training (input)"]
    #[doc = " @param workSpaceNumBytes     Number of allocated bytes in memory for the workspace (input)"]
    #[doc = " @param reserveSpace          Pointer to memory allocated for random states (input / output)"]
    #[doc = " @param reserveSpaceNumBytes  Number of allocated bytes in memory for use in the forward (input)"]
    #[doc = " @return                      miopenStatus_t"]
    pub fn miopenRNNBackwardData(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        sequenceLen: ::libc::c_int,
        yDesc: *const miopenTensorDescriptor_t,
        y: *const ::libc::c_void,
        dyDesc: *const miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        dhyDesc: miopenTensorDescriptor_t,
        dhy: *const ::libc::c_void,
        dcyDesc: miopenTensorDescriptor_t,
        dcy: *const ::libc::c_void,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        hxDesc: miopenTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: miopenTensorDescriptor_t,
        cx: *const ::libc::c_void,
        dxDesc: *const miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        dhxDesc: miopenTensorDescriptor_t,
        dhx: *mut ::libc::c_void,
        dcxDesc: miopenTensorDescriptor_t,
        dcx: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceNumBytes: usize,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceNumBytes: usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute backward weights for recurrent layer"]
    #[doc = ""]
    #[doc = " Interface for executing the backward weights pass on a RNN."]
    #[doc = ""]
    #[doc = " @param handle                MIOpen handle (input)"]
    #[doc = " @param rnnDesc               RNN layer descriptor type (input)"]
    #[doc = " @param sequenceLen           Temporal iterations to unroll (input)"]
    #[doc = " @param xDesc                 An array of tensor descriptors. These are the"]
    #[doc = " input descriptors to each time step. The first dimension of each descriptor is the"]
    #[doc = " batch size and may decrease from element n to element n+1 and not increase in size."]
    #[doc = " The second dimension is the same for all descriptors in the array and is the input"]
    #[doc = " vector length. (input)"]
    #[doc = " @param x                     Pointer to input tensor (input)"]
    #[doc = " @param hxDesc                A hidden tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param hx                    Pointer to the hidden layer input tensor. If hx is NULL,"]
    #[doc = " then the initial hidden state will be zero initialized. (input)"]
    #[doc = " @param yDesc                 An array of fully packed tensor descriptors associated"]
    #[doc = " with the output from each time step. The first dimension of the tensor descriptors"]
    #[doc = " must equal the first dimension of the first descriptor (batch size) in the xDesc"]
    #[doc = " tensor array. The second dimension of the element of the descriptor array"]
    #[doc = " depends on the direction mode selected. If the direction mode is unidirectional,"]
    #[doc = " the second dimension is the hiddenSize. If direction mode is bidirectional"]
    #[doc = " the second dimension is twice the hiddenSize. (input)"]
    #[doc = " @param y                     Pointer to the output tensor (input)"]
    #[doc = " @param dwDesc                A weights tensor descriptor (input)"]
    #[doc = " @param dw                    Pointer to input weights tensor (input / output)"]
    #[doc = " @param workSpace             Pointer to memory allocated for forward training (input)"]
    #[doc = " @param workSpaceNumBytes     Number of allocated bytes in memory for the workspace (input)"]
    #[doc = " @param reserveSpace          Pointer to memory allocated for random states (input)"]
    #[doc = " @param reserveSpaceNumBytes  Number of allocated bytes in memory for use in the forward (input)"]
    #[doc = " @return                      miopenStatus_t"]
    pub fn miopenRNNBackwardWeights(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        sequenceLen: ::libc::c_int,
        xDesc: *const miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: miopenTensorDescriptor_t,
        hx: *const ::libc::c_void,
        yDesc: *const miopenTensorDescriptor_t,
        y: *const ::libc::c_void,
        dwDesc: miopenTensorDescriptor_t,
        dw: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceNumBytes: usize,
        reserveSpace: *const ::libc::c_void,
        reserveSpaceNumBytes: usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute forward inference for RNN layer"]
    #[doc = ""]
    #[doc = " Interface for executing the forward inference pass on a RNN."]
    #[doc = ""]
    #[doc = " @param handle                MIOpen handle (input)"]
    #[doc = " @param rnnDesc               RNN layer descriptor type (input)"]
    #[doc = " @param sequenceLen           Temporal iterations to unroll (input)"]
    #[doc = " @param xDesc                 An array of tensor descriptors. These are the"]
    #[doc = " input descriptors to each time step. The first dimension of each descriptor is the"]
    #[doc = " batch size and may decrease from element n to element n+1 and not increase in size."]
    #[doc = " The second dimension is the same for all descriptors in the array and is the input"]
    #[doc = " vector length. (input)"]
    #[doc = " @param x                     Pointer to input tensor (input)"]
    #[doc = " @param hxDesc                A hidden tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param hx                    Pointer to the hidden layer input tensor. If hx is NULL,"]
    #[doc = " then the initial hidden state will be zero initialized. (input)"]
    #[doc = " @param cxDesc                A cell tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param cx                    Pointer to the cell layer input tensor. If cx is NULL,"]
    #[doc = " then the initial cell state will be zero initialized. (input)"]
    #[doc = " @param wDesc                 A weights tensor descriptor (input)"]
    #[doc = " @param w                     Pointer to input weights tensor (input)"]
    #[doc = " @param yDesc                 An array of fully packed tensor descriptors associated"]
    #[doc = " with the output from each time step. The first dimension of the tensor descriptors"]
    #[doc = " must equal the first dimension of the first descriptor (batch size) in the xDesc"]
    #[doc = " tensor array. The second dimension of the element of the descriptor array"]
    #[doc = " depends on the direction mode selected. If the direction mode is unidirectional,"]
    #[doc = " the second dimension is the hiddenSize. If direction mode is bidirectional"]
    #[doc = " the second dimension is twice the hiddenSize. (input)"]
    #[doc = " @param y                     Pointer to output tensor (output)"]
    #[doc = " @param hyDesc                A hidden tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param hy                    Pointer to the hidden layer output tensor. If hy is NULL,"]
    #[doc = " then the final hidden state will not be saved. (output)"]
    #[doc = " @param cyDesc                A output cell tensor descriptor that has as its first dimension"]
    #[doc = " of the number of layers if the direction mode is unidirectional and twice the"]
    #[doc = " number of layers if the direction mode is bidirectional. The second dimension of"]
    #[doc = " the descriptor must equal the largest first dimension of the xDesc tensor descriptor"]
    #[doc = " array. The third dimension equals the hiddenSize. (input)"]
    #[doc = " @param cy                    Pointer to the cell layer output tensor. If cy is NULL,"]
    #[doc = " then the final cell state will not be saved. (output)"]
    #[doc = " @param workSpace             Pointer to memory allocated for forward training (input)"]
    #[doc = " @param workSpaceNumBytes     Number of allocated bytes in memory for the workspace (input)"]
    #[doc = " @return                      miopenStatus_t"]
    pub fn miopenRNNForwardInference(
        handle: miopenHandle_t,
        rnnDesc: miopenRNNDescriptor_t,
        sequenceLen: ::libc::c_int,
        xDesc: *const miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        hxDesc: miopenTensorDescriptor_t,
        hx: *const ::libc::c_void,
        cxDesc: miopenTensorDescriptor_t,
        cx: *const ::libc::c_void,
        wDesc: miopenTensorDescriptor_t,
        w: *const ::libc::c_void,
        yDesc: *const miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        hyDesc: miopenTensorDescriptor_t,
        hy: *mut ::libc::c_void,
        cyDesc: miopenTensorDescriptor_t,
        cy: *mut ::libc::c_void,
        workSpace: *mut ::libc::c_void,
        workSpaceNumBytes: usize,
    ) -> miopenStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @enum miopenCTCLossAlgo_t"]
#[doc = " Algorithms available to execute the CTC loss operation"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenCTCLossAlgo_t {
    #[doc = "< Results are guaranteed to be reproducible"]
    MIOPEN_CTC_LOSS_ALGO_DETERMINISTIC = 0,
}
extern "C" {
    #[doc = " @brief Create a CTC loss function Descriptor"]
    #[doc = ""]
    #[doc = " API for creating an uninitialized CTC loss function descriptor."]
    #[doc = " @param ctcLossDesc  Pointer to the CTC loss function descriptor type (output)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenCreateCTCLossDescriptor(
        ctcLossDesc: *mut miopenCTCLossDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Retrieves a CTC loss function descriptor's details"]
    #[doc = ""]
    #[doc = " @param ctcLossDesc          CTC loss function descriptor (input)"]
    #[doc = " @param dataType             Data type used in this CTC loss operation, only fp32 currently"]
    #[doc = " supported (output)"]
    #[doc = " @param blank_label_id       User defined index for blank label (output)"]
    #[doc = " @param apply_softmax_layer  Boolean to toggle input layer property (output)"]
    #[doc = " @return                     miopenStatus_t"]
    pub fn miopenGetCTCLossDescriptor(
        ctcLossDesc: miopenCTCLossDescriptor_t,
        dataType: *mut miopenDataType_t,
        blank_label_id: *mut ::libc::c_int,
        apply_softmax_layer: *mut bool,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys a CTC loss function descriptor object"]
    #[doc = ""]
    #[doc = " @param ctcLossDesc  CTC loss function descriptor type (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenDestroyCTCLossDescriptor(ctcLossDesc: miopenCTCLossDescriptor_t)
        -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Set the details of a CTC loss function descriptor"]
    #[doc = ""]
    #[doc = " @param ctcLossDesc          CTC loss function descriptor type (input)"]
    #[doc = " @param dataType             Data type used in this CTC loss operation, only fp32 currently"]
    #[doc = " supported (input)"]
    #[doc = " @param blank_label_id       User defined index for blank label, default 0 (input)"]
    #[doc = " @param apply_softmax_layer  Boolean to toggle input layer property (input)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenSetCTCLossDescriptor(
        ctcLossDesc: miopenCTCLossDescriptor_t,
        dataType: miopenDataType_t,
        blank_label_id: ::libc::c_int,
        apply_softmax_layer: bool,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the amount of memory required to execute miopenCTCLoss"]
    #[doc = ""]
    #[doc = " This function calculates the amount of memory required to run the CTC loss function given a CTC"]
    #[doc = " loss function descriptor with the specified algorithm."]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param probsDesc      Tensor descriptor for probabilities (input)"]
    #[doc = " @param gradientsDesc  Tensor descriptor for gradients (input)"]
    #[doc = " @param labels         Pointer to the flattened labels list (input)"]
    #[doc = " @param labelLengths   Pointer to the lengths list for \"labels\" (input)"]
    #[doc = " @param inputLengths   Pointer to the list of the time steps in each batch (input)"]
    #[doc = " @param algo           CTC loss algorithm selected (input)"]
    #[doc = " @param ctcLossDesc    CTC loss function descriptor type (input)"]
    #[doc = " @param workSpaceSize  Number of bytes of workspace required for CTC loss operation with selected"]
    #[doc = " algorithm (output)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenGetCTCLossWorkspaceSize(
        handle: miopenHandle_t,
        probsDesc: miopenTensorDescriptor_t,
        gradientsDesc: miopenTensorDescriptor_t,
        labels: *const ::libc::c_int,
        labelLengths: *const ::libc::c_int,
        inputLengths: *const ::libc::c_int,
        algo: miopenCTCLossAlgo_t,
        ctcLossDesc: miopenCTCLossDescriptor_t,
        workSpaceSize: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute forward inference for CTCLoss layer"]
    #[doc = ""]
    #[doc = " Interface for executing the forward inference pass on a CTCLoss."]
    #[doc = " @param handle         MIOpen handle (input)"]
    #[doc = " @param probsDesc      Tensor descriptor for probabilities (input)"]
    #[doc = " @param probs          Pointer to the probabilities tensor (input)"]
    #[doc = " @param labels         Pointer to the flattened labels list (input)"]
    #[doc = " @param labelLengths   Pointer to the lengths list for \"labels\" (input)"]
    #[doc = " @param inputLengths   Pointer to the list of the time steps in each batch (input)"]
    #[doc = " @param losses         Pointer to the computed losses of CTC (Output)"]
    #[doc = " @param gradientsDesc  Tensor descriptor for gradients (input)"]
    #[doc = " @param gradients      Pointer to the computed gradients of CTC (Output)"]
    #[doc = " @param algo           CTC loss algorithm selected (input)"]
    #[doc = " @param ctcLossDesc    CTC loss function descriptor type (input)"]
    #[doc = " @param workSpace      Pointer to memory allocated for execute CTC loss operation (input)"]
    #[doc = " @param workSpaceSize  Number of bytes of workspace required for CTC loss operation with selected"]
    #[doc = " algorithm (input)"]
    #[doc = " @return               miopenStatus_t"]
    pub fn miopenCTCLoss(
        handle: miopenHandle_t,
        probsDesc: miopenTensorDescriptor_t,
        probs: *const ::libc::c_void,
        labels: *const ::libc::c_int,
        labelLengths: *const ::libc::c_int,
        inputLengths: *const ::libc::c_int,
        losses: *mut ::libc::c_void,
        gradientsDesc: miopenTensorDescriptor_t,
        gradients: *mut ::libc::c_void,
        algo: miopenCTCLossAlgo_t,
        ctcLossDesc: miopenCTCLossDescriptor_t,
        workSpace: *mut ::libc::c_void,
        workSpaceSize: usize,
    ) -> miopenStatus_t;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = "  @enum miopenRNGType_t"]
#[doc = " random number generator type"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum miopenRNGType_t {
    #[doc = "< XORWOW pseudorandom generator"]
    MIOPEN_RNG_PSEUDO_XORWOW = 0,
}
extern "C" {
    #[doc = " @brief Creates the dropout descriptor object"]
    #[doc = ""]
    #[doc = " @param dropoutDesc Pointer to a dropout descriptor type"]
    #[doc = " @return            miopenStatus_t"]
    pub fn miopenCreateDropoutDescriptor(
        dropoutDesc: *mut miopenDropoutDescriptor_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Destroys the dropout descriptor object"]
    #[doc = ""]
    #[doc = " @param dropoutDesc Dropout descriptor type (input)"]
    #[doc = " @return            miopenStatus_t"]
    pub fn miopenDestroyDropoutDescriptor(dropoutDesc: miopenDropoutDescriptor_t)
        -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the amount of memory required to run dropout"]
    #[doc = ""]
    #[doc = " This function calculates the amount of memory required to run dropout."]
    #[doc = " @param xDesc                    Tensor descriptor for data tensor x (input)"]
    #[doc = " @param reserveSpaceSizeInBytes  Number of bytes of reservespace required for executing dropout"]
    #[doc = " (Output)"]
    #[doc = " @return                         miopenStatus_t"]
    pub fn miopenDropoutGetReserveSpaceSize(
        xDesc: miopenTensorDescriptor_t,
        reserveSpaceSizeInBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Query the amount of memory required to store the states of the random number generators"]
    #[doc = ""]
    #[doc = " This function calculates the amount of memory required to store the states of the random number"]
    #[doc = " generators used by miopenDropoutForward."]
    #[doc = " @param handle            MIOpen handle (input)"]
    #[doc = " @param stateSizeInBytes  Number of bytes required to store random generator states (Output)"]
    #[doc = " @return                  miopenStatus_t"]
    pub fn miopenDropoutGetStatesSize(
        handle: miopenHandle_t,
        stateSizeInBytes: *mut usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Get the details of the dropout descriptor"]
    #[doc = ""]
    #[doc = " Interface for querying the dropout descriptor"]
    #[doc = " @param dropoutDesc  Dropout layer descriptor (input)"]
    #[doc = " @param handle       MIOpen handle (input)"]
    #[doc = " @param dropout      The probability by which the input is set to 0 in the dropout layer (Output)"]
    #[doc = " @param states       Pointer to memory that holds random number generator states (Output)"]
    #[doc = " @param seed         Seed used to initialize random number generator states (Output)"]
    #[doc = " @param use_mask     Boolean flag indicating whether to use a saved mask (an existing or"]
    #[doc = " user-defined dropout layout) in reserveSpace (Output)"]
    #[doc = " @param state_evo    Boolean flag indicating whether to adopt state evolution strategy to update"]
    #[doc = " the PRNG states by the end of each implementation (Output placeholder, currently not enabled)"]
    #[doc = " @param rng_mode     Random number generator used to generate parallel random number sequences"]
    #[doc = " (Output)"]
    #[doc = " @return             miopenStatus_t"]
    pub fn miopenGetDropoutDescriptor(
        dropoutDesc: miopenDropoutDescriptor_t,
        handle: miopenHandle_t,
        dropout: *mut f32,
        states: *mut *mut ::libc::c_void,
        seed: *mut ::libc::c_ulonglong,
        use_mask: *mut bool,
        state_evo: *mut bool,
        rng_mode: *mut miopenRNGType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Restore the dropout descriptor to a saved state"]
    #[doc = ""]
    #[doc = " This function restores the state of dropout descriptor using the address of a state buffer with"]
    #[doc = " previously saved PRNG state pattern, without launching the expensive PRNG initialization process."]
    #[doc = ""]
    #[doc = " Interface for restoring the dropout descriptor"]
    #[doc = " @param dropoutDesc       Dropout layer descriptor (input/Output)"]
    #[doc = " @param handle            MIOpen handle (input)"]
    #[doc = " @param dropout           The probability by which the input is set to 0 in the dropout layer"]
    #[doc = " (input)"]
    #[doc = " @param states            Pointer to memory that holds random number generator states (input)"]
    #[doc = " @param stateSizeInBytes  Number of bytes holding random generator states (input)"]
    #[doc = " @param seed              Seed used to initialize random number generator states (input)"]
    #[doc = " @param use_mask          Boolean flag indicating whether to use a saved mask (an existing or"]
    #[doc = " user-defined dropout layout) in reserveSpace (input)"]
    #[doc = " @param state_evo         Boolean flag indicating whether to adopt state evolution strategy to"]
    #[doc = " update the PRNG states by the end of each implementation (input placeholder, currently not"]
    #[doc = " enabled)"]
    #[doc = " @param rng_mode          Random number generator used to generate parallel random number"]
    #[doc = " sequences (input)"]
    #[doc = " @return                  miopenStatus_t"]
    pub fn miopenRestoreDropoutDescriptor(
        dropoutDesc: miopenDropoutDescriptor_t,
        handle: miopenHandle_t,
        dropout: f32,
        states: *mut ::libc::c_void,
        stateSizeInBytes: usize,
        seed: ::libc::c_ulonglong,
        use_mask: bool,
        state_evo: bool,
        rng_mode: miopenRNGType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Initialize the dropout descriptor"]
    #[doc = ""]
    #[doc = " Interface for setting up the dropout descriptor"]
    #[doc = " @param dropoutDesc       Dropout layer descriptor (input/Output)"]
    #[doc = " @param handle            MIOpen handle (input)"]
    #[doc = " @param dropout           The probability by which the input is set to 0 in the dropout layer"]
    #[doc = " (input)"]
    #[doc = " @param states            Pointer to memory that holds random number generator states (input)"]
    #[doc = " @param stateSizeInBytes  Number of bytes provided for random generator states (input)"]
    #[doc = " @param seed              Seed used to initialize random number generator states (input)"]
    #[doc = " @param use_mask          Boolean flag indicating whether to use a saved mask (an existing or"]
    #[doc = " user-defined dropout layout) in reserveSpace (input)"]
    #[doc = " @param state_evo         Boolean flag indicating whether to adopt state evolution strategy to"]
    #[doc = " update the PRNG states by the end of each implementation (input placeholder, currently not"]
    #[doc = " enabled)"]
    #[doc = " @param rng_mode          Random number generator used to generate parallel random number"]
    #[doc = " sequences (input)"]
    #[doc = " @return                  miopenStatus_t"]
    pub fn miopenSetDropoutDescriptor(
        dropoutDesc: miopenDropoutDescriptor_t,
        handle: miopenHandle_t,
        dropout: f32,
        states: *mut ::libc::c_void,
        stateSizeInBytes: usize,
        seed: ::libc::c_ulonglong,
        use_mask: bool,
        state_evo: bool,
        rng_mode: miopenRNGType_t,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute forward dropout operation"]
    #[doc = ""]
    #[doc = " Interface for executing the forward pass on a Dropout."]
    #[doc = " @param handle                   MIOpen handle (input)"]
    #[doc = " @param dropoutDesc              Dropout layer descriptor (input)"]
    #[doc = " @param noise_shape              Tensor descriptor for noise shape (input placeholder, currently"]
    #[doc = " not enabled)"]
    #[doc = " @param xDesc                    Tensor descriptor for data tensor x (input)"]
    #[doc = " @param x                        Data tensor x (input)"]
    #[doc = " @param yDesc                    Tensor descriptor for data tensor y (input)"]
    #[doc = " @param y                        Data tensor y (Output)"]
    #[doc = " @param reserveSpace             Pointer to memory allocated for executing forward dropout,"]
    #[doc = " expecting reserveSpace unchanged before next call of miopenDropoutBackward (Output)"]
    #[doc = " @param reserveSpaceSizeInBytes  Number of bytes of reservespace required for executing forward"]
    #[doc = " dropout (input)"]
    #[doc = " @return                         miopenStatus_t"]
    pub fn miopenDropoutForward(
        handle: miopenHandle_t,
        dropoutDesc: miopenDropoutDescriptor_t,
        noise_shape: miopenTensorDescriptor_t,
        xDesc: miopenTensorDescriptor_t,
        x: *const ::libc::c_void,
        yDesc: miopenTensorDescriptor_t,
        y: *mut ::libc::c_void,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> miopenStatus_t;
}
extern "C" {
    #[doc = " @brief Execute backward dropout operation"]
    #[doc = ""]
    #[doc = " Interface for executing the backward pass on a Dropout."]
    #[doc = " @param handle                   MIOpen handle (input)"]
    #[doc = " @param dropoutDesc              Dropout layer descriptor (input)"]
    #[doc = " @param noise_shape              Tensor descriptor for noise shape (input placeholder, currently"]
    #[doc = " not enabled)"]
    #[doc = " @param dyDesc                   Tensor descriptor for data delta tensor dy (input)"]
    #[doc = " @param dy                       Data delta tensor dy (input)"]
    #[doc = " @param dxDesc                   Tensor descriptor for data delta tensor dx (input)"]
    #[doc = " @param dx                       Data delta tensor dx (Output)"]
    #[doc = " @param reserveSpace             Pointer to memory allocated for executing backward dropout,"]
    #[doc = " expecting reserveSpace unchanged after previous call of miopenDropoutForward (input)"]
    #[doc = " @param reserveSpaceSizeInBytes  Number of bytes of reservespace required for executing backward"]
    #[doc = " dropout (input)"]
    #[doc = " @return                         miopenStatus_t"]
    pub fn miopenDropoutBackward(
        handle: miopenHandle_t,
        dropoutDesc: miopenDropoutDescriptor_t,
        noise_shape: miopenTensorDescriptor_t,
        dyDesc: miopenTensorDescriptor_t,
        dy: *const ::libc::c_void,
        dxDesc: miopenTensorDescriptor_t,
        dx: *mut ::libc::c_void,
        reserveSpace: *mut ::libc::c_void,
        reserveSpaceSizeInBytes: usize,
    ) -> miopenStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
